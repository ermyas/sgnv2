// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: seal.proto

package seal

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TxMsgStatus int32

const (
	TxMsgStatus_NULL    TxMsgStatus = 0
	TxMsgStatus_SENT    TxMsgStatus = 1
	TxMsgStatus_SUCCEED TxMsgStatus = 2
	TxMsgStatus_FAILED  TxMsgStatus = 3
)

var TxMsgStatus_name = map[int32]string{
	0: "NULL",
	1: "SENT",
	2: "SUCCEED",
	3: "FAILED",
}

var TxMsgStatus_value = map[string]int32{
	"NULL":    0,
	"SENT":    1,
	"SUCCEED": 2,
	"FAILED":  3,
}

func (x TxMsgStatus) String() string {
	return proto.EnumName(TxMsgStatus_name, int32(x))
}

func (TxMsgStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a02c8d155741ea4f, []int{0}
}

type TransactorLog struct {
	MsgNum          uint32            `protobuf:"varint,1,opt,name=msg_num,json=msgNum,proto3" json:"msg_num,omitempty"`
	MsgType         map[string]uint32 `protobuf:"bytes,2,rep,name=msg_type,json=msgType,proto3" json:"msg_type,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Sender          string            `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	TxHash          string            `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	MsgsId          uint32            `protobuf:"varint,5,opt,name=msgs_id,json=msgsId,proto3" json:"msgs_id,omitempty"`
	Status          TxMsgStatus       `protobuf:"varint,6,opt,name=status,proto3,enum=TxMsgStatus" json:"status,omitempty"`
	GasWanted       int64             `protobuf:"varint,7,opt,name=gas_wanted,json=gasWanted,proto3" json:"gas_wanted,omitempty"`
	GasUsed         int64             `protobuf:"varint,8,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	StartTimestamp  int64             `protobuf:"varint,99,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	ExecutionTimeMs float64           `protobuf:"fixed64,100,opt,name=execution_time_ms,json=executionTimeMs,proto3" json:"execution_time_ms,omitempty"`
	Error           []string          `protobuf:"bytes,101,rep,name=error,proto3" json:"error,omitempty"`
	Warn            []string          `protobuf:"bytes,102,rep,name=warn,proto3" json:"warn,omitempty"`
}

func (m *TransactorLog) Reset()         { *m = TransactorLog{} }
func (m *TransactorLog) String() string { return proto.CompactTextString(m) }
func (*TransactorLog) ProtoMessage()    {}
func (*TransactorLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02c8d155741ea4f, []int{0}
}
func (m *TransactorLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactorLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactorLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransactorLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactorLog.Merge(m, src)
}
func (m *TransactorLog) XXX_Size() int {
	return m.Size()
}
func (m *TransactorLog) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactorLog.DiscardUnknown(m)
}

var xxx_messageInfo_TransactorLog proto.InternalMessageInfo

func (m *TransactorLog) GetMsgNum() uint32 {
	if m != nil {
		return m.MsgNum
	}
	return 0
}

func (m *TransactorLog) GetMsgType() map[string]uint32 {
	if m != nil {
		return m.MsgType
	}
	return nil
}

func (m *TransactorLog) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *TransactorLog) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *TransactorLog) GetMsgsId() uint32 {
	if m != nil {
		return m.MsgsId
	}
	return 0
}

func (m *TransactorLog) GetStatus() TxMsgStatus {
	if m != nil {
		return m.Status
	}
	return TxMsgStatus_NULL
}

func (m *TransactorLog) GetGasWanted() int64 {
	if m != nil {
		return m.GasWanted
	}
	return 0
}

func (m *TransactorLog) GetGasUsed() int64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *TransactorLog) GetStartTimestamp() int64 {
	if m != nil {
		return m.StartTimestamp
	}
	return 0
}

func (m *TransactorLog) GetExecutionTimeMs() float64 {
	if m != nil {
		return m.ExecutionTimeMs
	}
	return 0
}

func (m *TransactorLog) GetError() []string {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *TransactorLog) GetWarn() []string {
	if m != nil {
		return m.Warn
	}
	return nil
}

type MsgLog struct {
	Type            string       `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	EthAddress      string       `protobuf:"bytes,2,opt,name=eth_address,json=ethAddress,proto3" json:"eth_address,omitempty"`
	PubKey          string       `protobuf:"bytes,3,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
	Transactors     []string     `protobuf:"bytes,4,rep,name=transactors,proto3" json:"transactors,omitempty"`
	ValAddr         string       `protobuf:"bytes,5,opt,name=val_addr,json=valAddr,proto3" json:"val_addr,omitempty"`
	DelAddr         string       `protobuf:"bytes,6,opt,name=del_addr,json=delAddr,proto3" json:"del_addr,omitempty"`
	Signer          string       `protobuf:"bytes,7,opt,name=signer,proto3" json:"signer,omitempty"`
	Updates         []*Update    `protobuf:"bytes,8,rep,name=updates,proto3" json:"updates,omitempty"`
	Govern          *Govern      `protobuf:"bytes,9,opt,name=govern,proto3" json:"govern,omitempty"`
	Slash           *Slash       `protobuf:"bytes,10,opt,name=slash,proto3" json:"slash,omitempty"`
	ChanInfo        *ChannelInfo `protobuf:"bytes,11,opt,name=chan_info,json=chanInfo,proto3" json:"chan_info,omitempty"`
	Sender          string       `protobuf:"bytes,99,opt,name=sender,proto3" json:"sender,omitempty"`
	ExecutionTimeMs float64      `protobuf:"fixed64,100,opt,name=execution_time_ms,json=executionTimeMs,proto3" json:"execution_time_ms,omitempty"`
	Error           []string     `protobuf:"bytes,101,rep,name=error,proto3" json:"error,omitempty"`
	Warn            []string     `protobuf:"bytes,102,rep,name=warn,proto3" json:"warn,omitempty"`
}

func (m *MsgLog) Reset()         { *m = MsgLog{} }
func (m *MsgLog) String() string { return proto.CompactTextString(m) }
func (*MsgLog) ProtoMessage()    {}
func (*MsgLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02c8d155741ea4f, []int{1}
}
func (m *MsgLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgLog.Merge(m, src)
}
func (m *MsgLog) XXX_Size() int {
	return m.Size()
}
func (m *MsgLog) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgLog.DiscardUnknown(m)
}

var xxx_messageInfo_MsgLog proto.InternalMessageInfo

func (m *MsgLog) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MsgLog) GetEthAddress() string {
	if m != nil {
		return m.EthAddress
	}
	return ""
}

func (m *MsgLog) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *MsgLog) GetTransactors() []string {
	if m != nil {
		return m.Transactors
	}
	return nil
}

func (m *MsgLog) GetValAddr() string {
	if m != nil {
		return m.ValAddr
	}
	return ""
}

func (m *MsgLog) GetDelAddr() string {
	if m != nil {
		return m.DelAddr
	}
	return ""
}

func (m *MsgLog) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgLog) GetUpdates() []*Update {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *MsgLog) GetGovern() *Govern {
	if m != nil {
		return m.Govern
	}
	return nil
}

func (m *MsgLog) GetSlash() *Slash {
	if m != nil {
		return m.Slash
	}
	return nil
}

func (m *MsgLog) GetChanInfo() *ChannelInfo {
	if m != nil {
		return m.ChanInfo
	}
	return nil
}

func (m *MsgLog) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgLog) GetExecutionTimeMs() float64 {
	if m != nil {
		return m.ExecutionTimeMs
	}
	return 0
}

func (m *MsgLog) GetError() []string {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *MsgLog) GetWarn() []string {
	if m != nil {
		return m.Warn
	}
	return nil
}

type Slash struct {
	Nonce   uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ValAddr string `protobuf:"bytes,2,opt,name=val_addr,json=valAddr,proto3" json:"val_addr,omitempty"`
	Reason  string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *Slash) Reset()         { *m = Slash{} }
func (m *Slash) String() string { return proto.CompactTextString(m) }
func (*Slash) ProtoMessage()    {}
func (*Slash) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02c8d155741ea4f, []int{2}
}
func (m *Slash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Slash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Slash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Slash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Slash.Merge(m, src)
}
func (m *Slash) XXX_Size() int {
	return m.Size()
}
func (m *Slash) XXX_DiscardUnknown() {
	xxx_messageInfo_Slash.DiscardUnknown(m)
}

var xxx_messageInfo_Slash proto.InternalMessageInfo

func (m *Slash) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *Slash) GetValAddr() string {
	if m != nil {
		return m.ValAddr
	}
	return ""
}

func (m *Slash) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type Update struct {
	Id   uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *Update) Reset()         { *m = Update{} }
func (m *Update) String() string { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()    {}
func (*Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02c8d155741ea4f, []int{3}
}
func (m *Update) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Update.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Update.Merge(m, src)
}
func (m *Update) XXX_Size() int {
	return m.Size()
}
func (m *Update) XXX_DiscardUnknown() {
	xxx_messageInfo_Update.DiscardUnknown(m)
}

var xxx_messageInfo_Update proto.InternalMessageInfo

func (m *Update) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Update) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type Govern struct {
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Deposit    string `protobuf:"bytes,2,opt,name=deposit,proto3" json:"deposit,omitempty"`
	Option     string `protobuf:"bytes,3,opt,name=option,proto3" json:"option,omitempty"`
}

func (m *Govern) Reset()         { *m = Govern{} }
func (m *Govern) String() string { return proto.CompactTextString(m) }
func (*Govern) ProtoMessage()    {}
func (*Govern) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02c8d155741ea4f, []int{4}
}
func (m *Govern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Govern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Govern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Govern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Govern.Merge(m, src)
}
func (m *Govern) XXX_Size() int {
	return m.Size()
}
func (m *Govern) XXX_DiscardUnknown() {
	xxx_messageInfo_Govern.DiscardUnknown(m)
}

var xxx_messageInfo_Govern proto.InternalMessageInfo

func (m *Govern) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *Govern) GetDeposit() string {
	if m != nil {
		return m.Deposit
	}
	return ""
}

func (m *Govern) GetOption() string {
	if m != nil {
		return m.Option
	}
	return ""
}

type ChannelInfo struct {
	ChanId        string   `protobuf:"bytes,1,opt,name=chan_id,json=chanId,proto3" json:"chan_id,omitempty"`
	PeerFrom      string   `protobuf:"bytes,2,opt,name=peer_from,json=peerFrom,proto3" json:"peer_from,omitempty"`
	SeqNum        uint64   `protobuf:"varint,3,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	TriggerTxHash string   `protobuf:"bytes,4,opt,name=trigger_tx_hash,json=triggerTxHash,proto3" json:"trigger_tx_hash,omitempty"`
	GuardTxHash   string   `protobuf:"bytes,5,opt,name=guard_tx_hash,json=guardTxHash,proto3" json:"guard_tx_hash,omitempty"`
	Guards        []string `protobuf:"bytes,6,rep,name=guards,proto3" json:"guards,omitempty"`
	GuardIndex    uint32   `protobuf:"varint,7,opt,name=guard_index,json=guardIndex,proto3" json:"guard_index,omitempty"`
	TriggerBlknum uint64   `protobuf:"varint,8,opt,name=trigger_blknum,json=triggerBlknum,proto3" json:"trigger_blknum,omitempty"`
	GuardBlknum   uint64   `protobuf:"varint,9,opt,name=guard_blknum,json=guardBlknum,proto3" json:"guard_blknum,omitempty"`
}

func (m *ChannelInfo) Reset()         { *m = ChannelInfo{} }
func (m *ChannelInfo) String() string { return proto.CompactTextString(m) }
func (*ChannelInfo) ProtoMessage()    {}
func (*ChannelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a02c8d155741ea4f, []int{5}
}
func (m *ChannelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelInfo.Merge(m, src)
}
func (m *ChannelInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChannelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelInfo proto.InternalMessageInfo

func (m *ChannelInfo) GetChanId() string {
	if m != nil {
		return m.ChanId
	}
	return ""
}

func (m *ChannelInfo) GetPeerFrom() string {
	if m != nil {
		return m.PeerFrom
	}
	return ""
}

func (m *ChannelInfo) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *ChannelInfo) GetTriggerTxHash() string {
	if m != nil {
		return m.TriggerTxHash
	}
	return ""
}

func (m *ChannelInfo) GetGuardTxHash() string {
	if m != nil {
		return m.GuardTxHash
	}
	return ""
}

func (m *ChannelInfo) GetGuards() []string {
	if m != nil {
		return m.Guards
	}
	return nil
}

func (m *ChannelInfo) GetGuardIndex() uint32 {
	if m != nil {
		return m.GuardIndex
	}
	return 0
}

func (m *ChannelInfo) GetTriggerBlknum() uint64 {
	if m != nil {
		return m.TriggerBlknum
	}
	return 0
}

func (m *ChannelInfo) GetGuardBlknum() uint64 {
	if m != nil {
		return m.GuardBlknum
	}
	return 0
}

func init() {
	proto.RegisterEnum("TxMsgStatus", TxMsgStatus_name, TxMsgStatus_value)
	proto.RegisterType((*TransactorLog)(nil), "TransactorLog")
	proto.RegisterMapType((map[string]uint32)(nil), "TransactorLog.MsgTypeEntry")
	proto.RegisterType((*MsgLog)(nil), "MsgLog")
	proto.RegisterType((*Slash)(nil), "Slash")
	proto.RegisterType((*Update)(nil), "Update")
	proto.RegisterType((*Govern)(nil), "Govern")
	proto.RegisterType((*ChannelInfo)(nil), "ChannelInfo")
}

func init() { proto.RegisterFile("seal.proto", fileDescriptor_a02c8d155741ea4f) }

var fileDescriptor_a02c8d155741ea4f = []byte{
	// 882 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0x23, 0x45,
	0x17, 0x4d, 0xdb, 0x4e, 0xdb, 0x7d, 0x1d, 0x27, 0xfe, 0x4a, 0x9f, 0x42, 0xc3, 0x80, 0xc7, 0x63,
	0x0d, 0x60, 0x46, 0x8c, 0x23, 0x05, 0x09, 0xa1, 0x2c, 0x90, 0x66, 0x32, 0x1e, 0xb0, 0x48, 0x22,
	0xd4, 0x71, 0x84, 0x04, 0x8b, 0x56, 0xd9, 0x55, 0x69, 0xb7, 0xe2, 0xae, 0xea, 0xa9, 0xaa, 0x76,
	0xec, 0xb7, 0xe0, 0x3d, 0x78, 0x0a, 0x16, 0x48, 0x2c, 0x67, 0xc9, 0x12, 0x25, 0x2f, 0x82, 0x6e,
	0x55, 0xdb, 0xd8, 0x0f, 0xc0, 0xae, 0xce, 0xb9, 0x3f, 0xbe, 0xbe, 0xe7, 0xe8, 0x36, 0x80, 0xe6,
	0x74, 0x3e, 0xc8, 0x95, 0x34, 0xb2, 0xf7, 0x47, 0x15, 0x5a, 0x63, 0x45, 0x85, 0xa6, 0x53, 0x23,
	0xd5, 0x85, 0x4c, 0xc8, 0x07, 0x50, 0xcf, 0x74, 0x12, 0x8b, 0x22, 0x0b, 0xbd, 0xae, 0xd7, 0x6f,
	0x45, 0x7e, 0xa6, 0x93, 0xab, 0x22, 0x23, 0x5f, 0x43, 0x03, 0x03, 0x66, 0x95, 0xf3, 0xb0, 0xd2,
	0xad, 0xf6, 0x9b, 0xa7, 0x4f, 0x06, 0x3b, 0xa5, 0x83, 0x4b, 0x9d, 0x8c, 0x57, 0x39, 0x1f, 0x0a,
	0xa3, 0x56, 0x11, 0x76, 0x41, 0x44, 0x8e, 0xc1, 0xd7, 0x5c, 0x30, 0xae, 0xc2, 0x6a, 0xd7, 0xeb,
	0x07, 0x51, 0x89, 0xf0, 0x87, 0xcc, 0x32, 0x9e, 0x51, 0x3d, 0x0b, 0x6b, 0x2e, 0x60, 0x96, 0xdf,
	0x53, 0x3d, 0x2b, 0x27, 0xd0, 0x71, 0xca, 0xc2, 0xfd, 0xcd, 0x04, 0x7a, 0xc4, 0xc8, 0x73, 0xf0,
	0xb5, 0xa1, 0xa6, 0xd0, 0xa1, 0xdf, 0xf5, 0xfa, 0x87, 0xa7, 0x07, 0x83, 0xf1, 0xf2, 0x52, 0x27,
	0xd7, 0x96, 0x8b, 0xca, 0x18, 0xf9, 0x04, 0x20, 0xa1, 0x3a, 0xbe, 0xa7, 0xc2, 0x70, 0x16, 0xd6,
	0xbb, 0x5e, 0xbf, 0x1a, 0x05, 0x09, 0xd5, 0x3f, 0x59, 0x82, 0x7c, 0x08, 0x0d, 0x0c, 0x17, 0x9a,
	0xb3, 0xb0, 0x61, 0x83, 0xf5, 0x84, 0xea, 0x1b, 0xcd, 0x19, 0xf9, 0x1c, 0x8e, 0xb4, 0xa1, 0xca,
	0xc4, 0x26, 0xcd, 0xb8, 0x36, 0x34, 0xcb, 0xc3, 0xa9, 0xcd, 0x38, 0xb4, 0xf4, 0x78, 0xcd, 0x92,
	0x17, 0xf0, 0x3f, 0xbe, 0xe4, 0xd3, 0xc2, 0xa4, 0x52, 0xd8, 0xe4, 0x38, 0xd3, 0x21, 0xeb, 0x7a,
	0x7d, 0x2f, 0x3a, 0xda, 0x04, 0x30, 0xfd, 0x52, 0x93, 0xff, 0xc3, 0x3e, 0x57, 0x4a, 0xaa, 0x90,
	0x77, 0xab, 0xfd, 0x20, 0x72, 0x80, 0x10, 0xa8, 0xdd, 0x53, 0x25, 0xc2, 0x5b, 0x4b, 0xda, 0xf7,
	0x47, 0x67, 0x70, 0xb0, 0xbd, 0x41, 0xd2, 0x86, 0xea, 0x1d, 0x5f, 0x59, 0x15, 0x82, 0x08, 0x9f,
	0xd8, 0x6b, 0x41, 0xe7, 0x05, 0xee, 0x1f, 0xf7, 0xe2, 0xc0, 0x59, 0xe5, 0x1b, 0xaf, 0xf7, 0x7b,
	0x15, 0xfc, 0x4b, 0x9d, 0xa0, 0x80, 0x04, 0x6a, 0x56, 0x23, 0x57, 0x67, 0xdf, 0xe4, 0x29, 0x34,
	0xb9, 0x99, 0xc5, 0x94, 0x31, 0xc5, 0xb5, 0xb6, 0xe5, 0x41, 0x04, 0xdc, 0xcc, 0x5e, 0x39, 0x06,
	0x77, 0x9e, 0x17, 0x93, 0x18, 0x7f, 0xaf, 0x54, 0x29, 0x2f, 0x26, 0x3f, 0xf0, 0x15, 0xe9, 0x42,
	0xd3, 0x6c, 0x44, 0xd6, 0x61, 0xcd, 0xce, 0xbb, 0x4d, 0xe1, 0x42, 0x17, 0x74, 0x6e, 0x7b, 0x5b,
	0xbd, 0x82, 0xa8, 0xbe, 0xa0, 0x73, 0x6c, 0x8c, 0x21, 0xc6, 0xcb, 0x90, 0xef, 0x42, 0x8c, 0xbb,
	0x10, 0xba, 0x22, 0x4d, 0x04, 0x57, 0x56, 0x21, 0x74, 0x85, 0x45, 0xe4, 0x19, 0xd4, 0x8b, 0x9c,
	0x51, 0xc3, 0x75, 0xd8, 0xb0, 0x26, 0xab, 0x0f, 0x6e, 0x2c, 0x8e, 0xd6, 0x3c, 0x79, 0x0a, 0x7e,
	0x22, 0x17, 0x5c, 0x89, 0x30, 0xe8, 0x7a, 0x36, 0xe3, 0x3b, 0x0b, 0xa3, 0x92, 0x26, 0x1f, 0xc3,
	0xbe, 0x9e, 0xa3, 0xaf, 0xc0, 0xc6, 0xfd, 0xc1, 0x35, 0xa2, 0xc8, 0x91, 0xe4, 0x0b, 0x08, 0xa6,
	0x33, 0x2a, 0xe2, 0x54, 0xdc, 0xca, 0xb0, 0x69, 0x33, 0x0e, 0x06, 0xe7, 0x33, 0x2a, 0x04, 0x9f,
	0x8f, 0xc4, 0xad, 0x8c, 0x1a, 0x18, 0xc6, 0xd7, 0x96, 0x75, 0xa7, 0x3b, 0xd6, 0xfd, 0x4f, 0xf4,
	0xef, 0xfd, 0x08, 0xfb, 0x76, 0x50, 0x2c, 0x11, 0x52, 0x4c, 0x9d, 0x84, 0xb5, 0xc8, 0x81, 0x9d,
	0x3d, 0x57, 0x76, 0xf7, 0x7c, 0x0c, 0xbe, 0xe2, 0x54, 0x4b, 0xb1, 0x16, 0xcf, 0xa1, 0xde, 0x97,
	0xe0, 0xbb, 0xe5, 0x91, 0x43, 0xa8, 0xa4, 0xac, 0xec, 0x57, 0x49, 0xd9, 0xc6, 0x24, 0x95, 0x7f,
	0x4d, 0xd2, 0xfb, 0x05, 0x7c, 0xb7, 0x48, 0xb4, 0x4b, 0xae, 0x64, 0x2e, 0x35, 0x9d, 0xc7, 0x9b,
	0x32, 0x58, 0x53, 0x23, 0x46, 0x42, 0xa8, 0x33, 0x9e, 0x4b, 0x9d, 0x9a, 0xf5, 0x28, 0x25, 0xc4,
	0x51, 0x64, 0x8e, 0x7f, 0x7f, 0x3d, 0x8a, 0x43, 0xbd, 0xdf, 0x2a, 0xd0, 0xdc, 0x5a, 0x32, 0x1a,
	0xce, 0xa9, 0xc0, 0x4a, 0xa3, 0xfa, 0x76, 0xeb, 0x8c, 0x3c, 0x81, 0x20, 0xe7, 0x5c, 0xc5, 0xb7,
	0x4a, 0x66, 0x65, 0xf3, 0x06, 0x12, 0x6f, 0x95, 0xcc, 0xb0, 0x4a, 0xf3, 0x77, 0xf6, 0x38, 0x55,
	0xed, 0x50, 0xbe, 0xe6, 0xef, 0xf0, 0x38, 0x7d, 0x06, 0x47, 0x46, 0xa5, 0x49, 0xc2, 0x55, 0xbc,
	0x7b, 0x54, 0x5a, 0x25, 0x3d, 0x76, 0xb7, 0xa5, 0x07, 0xad, 0xa4, 0xa0, 0x8a, 0x6d, 0xb2, 0x9c,
	0x63, 0x9b, 0x96, 0x2c, 0x73, 0x8e, 0xc1, 0xb7, 0x10, 0xcf, 0x0c, 0xaa, 0x53, 0x22, 0xdc, 0x8a,
	0xab, 0x4d, 0x05, 0xe3, 0x4b, 0xeb, 0xdb, 0x56, 0x04, 0x96, 0x1a, 0x21, 0x43, 0x3e, 0x85, 0xc3,
	0xf5, 0x10, 0x93, 0xf9, 0x1d, 0x0e, 0xd9, 0xb0, 0x43, 0xae, 0x67, 0x78, 0x6d, 0x49, 0xf2, 0x0c,
	0x0e, 0x5c, 0x9f, 0x32, 0x29, 0xb0, 0x49, 0xae, 0xb7, 0x4b, 0x79, 0x71, 0x06, 0xcd, 0xad, 0xd3,
	0x46, 0x1a, 0x50, 0xbb, 0xba, 0xb9, 0xb8, 0x68, 0xef, 0xe1, 0xeb, 0x7a, 0x78, 0x35, 0x6e, 0x7b,
	0xa4, 0x09, 0xf5, 0xeb, 0x9b, 0xf3, 0xf3, 0xe1, 0xf0, 0x4d, 0xbb, 0x42, 0x00, 0xfc, 0xb7, 0xaf,
	0x46, 0x17, 0xc3, 0x37, 0xed, 0xea, 0xeb, 0x6f, 0xff, 0x7c, 0xe8, 0x78, 0xef, 0x1f, 0x3a, 0xde,
	0xdf, 0x0f, 0x1d, 0xef, 0xd7, 0xc7, 0xce, 0xde, 0xfb, 0xc7, 0xce, 0xde, 0x5f, 0x8f, 0x9d, 0xbd,
	0x9f, 0x9f, 0x27, 0xa9, 0x99, 0x15, 0x93, 0xc1, 0x54, 0x66, 0x27, 0x53, 0x3e, 0xe7, 0xea, 0xa5,
	0xe0, 0xe6, 0x5e, 0xaa, 0xbb, 0x13, 0x9d, 0x88, 0x97, 0x8b, 0xd3, 0x13, 0xfc, 0x30, 0x4c, 0x7c,
	0xfb, 0x65, 0xf8, 0xea, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5c, 0xbe, 0xc4, 0x56, 0x27, 0x06,
	0x00, 0x00,
}

func (m *TransactorLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactorLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransactorLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Warn) > 0 {
		for iNdEx := len(m.Warn) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Warn[iNdEx])
			copy(dAtA[i:], m.Warn[iNdEx])
			i = encodeVarintSeal(dAtA, i, uint64(len(m.Warn[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Error) > 0 {
		for iNdEx := len(m.Error) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Error[iNdEx])
			copy(dAtA[i:], m.Error[iNdEx])
			i = encodeVarintSeal(dAtA, i, uint64(len(m.Error[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.ExecutionTimeMs != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExecutionTimeMs))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa1
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x98
	}
	if m.GasUsed != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x40
	}
	if m.GasWanted != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.GasWanted))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.MsgsId != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.MsgsId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MsgType) > 0 {
		for k := range m.MsgType {
			v := m.MsgType[k]
			baseI := i
			i = encodeVarintSeal(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSeal(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSeal(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.MsgNum != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.MsgNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Warn) > 0 {
		for iNdEx := len(m.Warn) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Warn[iNdEx])
			copy(dAtA[i:], m.Warn[iNdEx])
			i = encodeVarintSeal(dAtA, i, uint64(len(m.Warn[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.Error) > 0 {
		for iNdEx := len(m.Error) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Error[iNdEx])
			copy(dAtA[i:], m.Error[iNdEx])
			i = encodeVarintSeal(dAtA, i, uint64(len(m.Error[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.ExecutionTimeMs != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ExecutionTimeMs))))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa1
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0x9a
	}
	if m.ChanInfo != nil {
		{
			size, err := m.ChanInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.Slash != nil {
		{
			size, err := m.Slash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Govern != nil {
		{
			size, err := m.Govern.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSeal(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSeal(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DelAddr) > 0 {
		i -= len(m.DelAddr)
		copy(dAtA[i:], m.DelAddr)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.DelAddr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ValAddr) > 0 {
		i -= len(m.ValAddr)
		copy(dAtA[i:], m.ValAddr)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.ValAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Transactors) > 0 {
		for iNdEx := len(m.Transactors) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Transactors[iNdEx])
			copy(dAtA[i:], m.Transactors[iNdEx])
			i = encodeVarintSeal(dAtA, i, uint64(len(m.Transactors[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EthAddress) > 0 {
		i -= len(m.EthAddress)
		copy(dAtA[i:], m.EthAddress)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.EthAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Slash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Slash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Slash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValAddr) > 0 {
		i -= len(m.ValAddr)
		copy(dAtA[i:], m.ValAddr)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.ValAddr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Nonce != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Govern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Govern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Govern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Option) > 0 {
		i -= len(m.Option)
		copy(dAtA[i:], m.Option)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Option)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChannelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GuardBlknum != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.GuardBlknum))
		i--
		dAtA[i] = 0x48
	}
	if m.TriggerBlknum != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.TriggerBlknum))
		i--
		dAtA[i] = 0x40
	}
	if m.GuardIndex != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.GuardIndex))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Guards) > 0 {
		for iNdEx := len(m.Guards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Guards[iNdEx])
			copy(dAtA[i:], m.Guards[iNdEx])
			i = encodeVarintSeal(dAtA, i, uint64(len(m.Guards[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.GuardTxHash) > 0 {
		i -= len(m.GuardTxHash)
		copy(dAtA[i:], m.GuardTxHash)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.GuardTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TriggerTxHash) > 0 {
		i -= len(m.TriggerTxHash)
		copy(dAtA[i:], m.TriggerTxHash)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.TriggerTxHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.SeqNum != 0 {
		i = encodeVarintSeal(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PeerFrom) > 0 {
		i -= len(m.PeerFrom)
		copy(dAtA[i:], m.PeerFrom)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.PeerFrom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChanId) > 0 {
		i -= len(m.ChanId)
		copy(dAtA[i:], m.ChanId)
		i = encodeVarintSeal(dAtA, i, uint64(len(m.ChanId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSeal(dAtA []byte, offset int, v uint64) int {
	offset -= sovSeal(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TransactorLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgNum != 0 {
		n += 1 + sovSeal(uint64(m.MsgNum))
	}
	if len(m.MsgType) > 0 {
		for k, v := range m.MsgType {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSeal(uint64(len(k))) + 1 + sovSeal(uint64(v))
			n += mapEntrySize + 1 + sovSeal(uint64(mapEntrySize))
		}
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	if m.MsgsId != 0 {
		n += 1 + sovSeal(uint64(m.MsgsId))
	}
	if m.Status != 0 {
		n += 1 + sovSeal(uint64(m.Status))
	}
	if m.GasWanted != 0 {
		n += 1 + sovSeal(uint64(m.GasWanted))
	}
	if m.GasUsed != 0 {
		n += 1 + sovSeal(uint64(m.GasUsed))
	}
	if m.StartTimestamp != 0 {
		n += 2 + sovSeal(uint64(m.StartTimestamp))
	}
	if m.ExecutionTimeMs != 0 {
		n += 10
	}
	if len(m.Error) > 0 {
		for _, s := range m.Error {
			l = len(s)
			n += 2 + l + sovSeal(uint64(l))
		}
	}
	if len(m.Warn) > 0 {
		for _, s := range m.Warn {
			l = len(s)
			n += 2 + l + sovSeal(uint64(l))
		}
	}
	return n
}

func (m *MsgLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.EthAddress)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	if len(m.Transactors) > 0 {
		for _, s := range m.Transactors {
			l = len(s)
			n += 1 + l + sovSeal(uint64(l))
		}
	}
	l = len(m.ValAddr)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.DelAddr)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovSeal(uint64(l))
		}
	}
	if m.Govern != nil {
		l = m.Govern.Size()
		n += 1 + l + sovSeal(uint64(l))
	}
	if m.Slash != nil {
		l = m.Slash.Size()
		n += 1 + l + sovSeal(uint64(l))
	}
	if m.ChanInfo != nil {
		l = m.ChanInfo.Size()
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 2 + l + sovSeal(uint64(l))
	}
	if m.ExecutionTimeMs != 0 {
		n += 10
	}
	if len(m.Error) > 0 {
		for _, s := range m.Error {
			l = len(s)
			n += 2 + l + sovSeal(uint64(l))
		}
	}
	if len(m.Warn) > 0 {
		for _, s := range m.Warn {
			l = len(s)
			n += 2 + l + sovSeal(uint64(l))
		}
	}
	return n
}

func (m *Slash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovSeal(uint64(m.Nonce))
	}
	l = len(m.ValAddr)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	return n
}

func (m *Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSeal(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	return n
}

func (m *Govern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovSeal(uint64(m.ProposalId))
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.Option)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	return n
}

func (m *ChannelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChanId)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.PeerFrom)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovSeal(uint64(m.SeqNum))
	}
	l = len(m.TriggerTxHash)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	l = len(m.GuardTxHash)
	if l > 0 {
		n += 1 + l + sovSeal(uint64(l))
	}
	if len(m.Guards) > 0 {
		for _, s := range m.Guards {
			l = len(s)
			n += 1 + l + sovSeal(uint64(l))
		}
	}
	if m.GuardIndex != 0 {
		n += 1 + sovSeal(uint64(m.GuardIndex))
	}
	if m.TriggerBlknum != 0 {
		n += 1 + sovSeal(uint64(m.TriggerBlknum))
	}
	if m.GuardBlknum != 0 {
		n += 1 + sovSeal(uint64(m.GuardBlknum))
	}
	return n
}

func sovSeal(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSeal(x uint64) (n int) {
	return sovSeal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TransactorLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactorLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactorLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgNum", wireType)
			}
			m.MsgNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgType == nil {
				m.MsgType = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSeal
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSeal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSeal
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSeal
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSeal
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSeal(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSeal
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MsgType[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgsId", wireType)
			}
			m.MsgsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgsId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxMsgStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasWanted", wireType)
			}
			m.GasWanted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasWanted |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 99:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 100:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionTimeMs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExecutionTimeMs = float64(math.Float64frombits(v))
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warn = append(m.Warn, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EthAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EthAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transactors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Transactors = append(m.Transactors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &Update{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Govern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Govern == nil {
				m.Govern = &Govern{}
			}
			if err := m.Govern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Slash == nil {
				m.Slash = &Slash{}
			}
			if err := m.Slash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChanInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChanInfo == nil {
				m.ChanInfo = &ChannelInfo{}
			}
			if err := m.ChanInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionTimeMs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ExecutionTimeMs = float64(math.Float64frombits(v))
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = append(m.Error, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Warn = append(m.Warn, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Slash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Slash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Slash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Govern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Govern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Govern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Option = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerFrom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TriggerTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuardTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guards", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guards = append(m.Guards, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardIndex", wireType)
			}
			m.GuardIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerBlknum", wireType)
			}
			m.TriggerBlknum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerBlknum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardBlknum", wireType)
			}
			m.GuardBlknum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuardBlknum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSeal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSeal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSeal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSeal
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSeal
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSeal
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSeal        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSeal          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSeal = fmt.Errorf("proto: unexpected end of group")
)
