// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/cbridge/v1/cbridge.proto

package types

import (
	fmt "fmt"
	types "github.com/celer-network/sgn-v2/common/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/regen-network/cosmos-proto"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ========== x/cbridge kv value types
// for src transfer id
// normal status flow: after sgn applied user's Send event, status is OK_TO_RELAY. then after apply Relay event
// status is SUCCESS
// can't relay flow: after apply send, status will be BAD_xxx, and there'll be no relay. so user need to InitWithdraw, status becomes
// refund_requested when sgn apply withdrawDone event, status becomes REFUND_DONE
type XferStatus int32

const (
	XferStatus_UNKNOWN XferStatus = 0
	// normal flow only has ok then success
	XferStatus_OK_TO_RELAY XferStatus = 1
	XferStatus_SUCCESS     XferStatus = 2
	// can't relay flow status
	XferStatus_BAD_LIQUIDITY XferStatus = 3
	XferStatus_BAD_SLIPPAGE  XferStatus = 4
	XferStatus_BAD_TOKEN     XferStatus = 5
	// refund, using withdraw flow
	XferStatus_REFUND_REQUESTED  XferStatus = 6
	XferStatus_REFUND_DONE       XferStatus = 7
	XferStatus_BAD_XFER_DISABLED XferStatus = 8
	// come, we should go to refund flow.
	XferStatus_BAD_DEST_CHAIN        XferStatus = 9
	XferStatus_EXCEED_MAX_OUT_AMOUNT XferStatus = 10
	XferStatus_XFER_DELAYED          XferStatus = 11
	// delayThreshold
	XferStatus_BAD_ADDRESS XferStatus = 12
)

var XferStatus_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "OK_TO_RELAY",
	2:  "SUCCESS",
	3:  "BAD_LIQUIDITY",
	4:  "BAD_SLIPPAGE",
	5:  "BAD_TOKEN",
	6:  "REFUND_REQUESTED",
	7:  "REFUND_DONE",
	8:  "BAD_XFER_DISABLED",
	9:  "BAD_DEST_CHAIN",
	10: "EXCEED_MAX_OUT_AMOUNT",
	11: "XFER_DELAYED",
	12: "BAD_ADDRESS",
}

var XferStatus_value = map[string]int32{
	"UNKNOWN":               0,
	"OK_TO_RELAY":           1,
	"SUCCESS":               2,
	"BAD_LIQUIDITY":         3,
	"BAD_SLIPPAGE":          4,
	"BAD_TOKEN":             5,
	"REFUND_REQUESTED":      6,
	"REFUND_DONE":           7,
	"BAD_XFER_DISABLED":     8,
	"BAD_DEST_CHAIN":        9,
	"EXCEED_MAX_OUT_AMOUNT": 10,
	"XFER_DELAYED":          11,
	"BAD_ADDRESS":           12,
}

func (x XferStatus) String() string {
	return proto.EnumName(XferStatus_name, int32(x))
}

func (XferStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{0}
}

// ========== params
type Params struct {
	SignerUpdateDuration      time.Duration `protobuf:"bytes,1,opt,name=signer_update_duration,json=signerUpdateDuration,proto3,stdduration" json:"signer_update_duration,omitempty" yaml:"signer_update_duration"`
	SignAgainCoolDownDuration time.Duration `protobuf:"bytes,2,opt,name=sign_again_cool_down_duration,json=signAgainCoolDownDuration,proto3,stdduration" json:"sign_again_cool_down_duration,omitempty" yaml:"sign_again_cool_down_duration"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetSignerUpdateDuration() time.Duration {
	if m != nil {
		return m.SignerUpdateDuration
	}
	return 0
}

func (m *Params) GetSignAgainCoolDownDuration() time.Duration {
	if m != nil {
		return m.SignAgainCoolDownDuration
	}
	return 0
}

// ========== configs
// use configs to avoid confusion w/ cosmos param
// Next tag: 7
type CbrConfig struct {
	LpFeePerc uint32 `protobuf:"varint,1,opt,name=lp_fee_perc,json=lpFeePerc,proto3" json:"lp_fee_perc,omitempty"`
	// to improve scalability, we'll first pick this many LPs to see if their total liquidity is enough
	// if yes, we'll use weighted random sampling among them until xfer can be fulfilled.
	// if not, we'll continue choose next LPs until we have enough and use all
	// this param is a trade-off between scalability and fairness, if not set, default is 100
	PickLpSize uint32 `protobuf:"varint,4,opt,name=pick_lp_size,json=pickLpSize,proto3" json:"pick_lp_size,omitempty"`
	// onchain relay tx gas cost param to compute base fee
	RelayGasCost []*RelayGasCostParam         `protobuf:"bytes,5,rep,name=relay_gas_cost,json=relayGasCost,proto3" json:"relay_gas_cost,omitempty"`
	Assets       []*ChainAsset                `protobuf:"bytes,2,rep,name=assets,proto3" json:"assets,omitempty"`
	ChainPairs   []*ChainPair                 `protobuf:"bytes,3,rep,name=chain_pairs,json=chainPairs,proto3" json:"chain_pairs,omitempty"`
	CbrContracts []*types.ContractInfo        `protobuf:"bytes,6,rep,name=cbr_contracts,json=cbrContracts,proto3" json:"cbr_contracts,omitempty"`
	Override     []*PerChainPairAssetOverride `protobuf:"bytes,7,rep,name=override,proto3" json:"override,omitempty"`
}

func (m *CbrConfig) Reset()         { *m = CbrConfig{} }
func (m *CbrConfig) String() string { return proto.CompactTextString(m) }
func (*CbrConfig) ProtoMessage()    {}
func (*CbrConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{1}
}
func (m *CbrConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbrConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CbrConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CbrConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbrConfig.Merge(m, src)
}
func (m *CbrConfig) XXX_Size() int {
	return m.Size()
}
func (m *CbrConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CbrConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CbrConfig proto.InternalMessageInfo

func (m *CbrConfig) GetLpFeePerc() uint32 {
	if m != nil {
		return m.LpFeePerc
	}
	return 0
}

func (m *CbrConfig) GetPickLpSize() uint32 {
	if m != nil {
		return m.PickLpSize
	}
	return 0
}

func (m *CbrConfig) GetRelayGasCost() []*RelayGasCostParam {
	if m != nil {
		return m.RelayGasCost
	}
	return nil
}

func (m *CbrConfig) GetAssets() []*ChainAsset {
	if m != nil {
		return m.Assets
	}
	return nil
}

func (m *CbrConfig) GetChainPairs() []*ChainPair {
	if m != nil {
		return m.ChainPairs
	}
	return nil
}

func (m *CbrConfig) GetCbrContracts() []*types.ContractInfo {
	if m != nil {
		return m.CbrContracts
	}
	return nil
}

func (m *CbrConfig) GetOverride() []*PerChainPairAssetOverride {
	if m != nil {
		return m.Override
	}
	return nil
}

// needed for base fee calculation. the value set in genesis is only used when first start.
// then there'll be propose/vote and new price will be saved in x/cbridge kv
type CbrPrice struct {
	UpdateEpoch uint64        `protobuf:"varint,1,opt,name=update_epoch,json=updateEpoch,proto3" json:"update_epoch,omitempty"`
	AssetPrice  []*AssetPrice `protobuf:"bytes,5,rep,name=asset_price,json=assetPrice,proto3" json:"asset_price,omitempty"`
	GasPrice    []*GasPrice   `protobuf:"bytes,6,rep,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
}

func (m *CbrPrice) Reset()         { *m = CbrPrice{} }
func (m *CbrPrice) String() string { return proto.CompactTextString(m) }
func (*CbrPrice) ProtoMessage()    {}
func (*CbrPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{2}
}
func (m *CbrPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbrPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CbrPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CbrPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbrPrice.Merge(m, src)
}
func (m *CbrPrice) XXX_Size() int {
	return m.Size()
}
func (m *CbrPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_CbrPrice.DiscardUnknown(m)
}

var xxx_messageInfo_CbrPrice proto.InternalMessageInfo

func (m *CbrPrice) GetUpdateEpoch() uint64 {
	if m != nil {
		return m.UpdateEpoch
	}
	return 0
}

func (m *CbrPrice) GetAssetPrice() []*AssetPrice {
	if m != nil {
		return m.AssetPrice
	}
	return nil
}

func (m *CbrPrice) GetGasPrice() []*GasPrice {
	if m != nil {
		return m.GasPrice
	}
	return nil
}

// needed for gas cost calculation for different chain.
// the equation is cost_base + per_validator * V + per_sig * Sigs, where V is the number of validators
// and Sigs stands for the number of signs needed for quorum
type RelayGasCostParam struct {
	ChainId      uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	CostBase     uint32 `protobuf:"varint,2,opt,name=cost_base,json=costBase,proto3" json:"cost_base,omitempty"`
	PerValidator uint32 `protobuf:"varint,3,opt,name=per_validator,json=perValidator,proto3" json:"per_validator,omitempty"`
	PerSig       uint32 `protobuf:"varint,4,opt,name=per_sig,json=perSig,proto3" json:"per_sig,omitempty"`
}

func (m *RelayGasCostParam) Reset()         { *m = RelayGasCostParam{} }
func (m *RelayGasCostParam) String() string { return proto.CompactTextString(m) }
func (*RelayGasCostParam) ProtoMessage()    {}
func (*RelayGasCostParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{3}
}
func (m *RelayGasCostParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayGasCostParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayGasCostParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayGasCostParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayGasCostParam.Merge(m, src)
}
func (m *RelayGasCostParam) XXX_Size() int {
	return m.Size()
}
func (m *RelayGasCostParam) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayGasCostParam.DiscardUnknown(m)
}

var xxx_messageInfo_RelayGasCostParam proto.InternalMessageInfo

func (m *RelayGasCostParam) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *RelayGasCostParam) GetCostBase() uint32 {
	if m != nil {
		return m.CostBase
	}
	return 0
}

func (m *RelayGasCostParam) GetPerValidator() uint32 {
	if m != nil {
		return m.PerValidator
	}
	return 0
}

func (m *RelayGasCostParam) GetPerSig() uint32 {
	if m != nil {
		return m.PerSig
	}
	return 0
}

// if an asset is not used by any chain as native gas token, no need to set chain_id. eg. USDT
// if an asset is native gas token for some chains, set the chain_ids
// it's possible an asset is only native gas token but NOT used for transfers (ie. not in CbrConfig.assets)
// price is in int(USD float * 1e4)
type AssetPrice struct {
	Symbol string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// these chains uses this asset as native gas token, eg. ETH is gas token for both ethereum and Arbitrum
	ChainIds []uint64 `protobuf:"varint,2,rep,packed,name=chain_ids,json=chainIds,proto3" json:"chain_ids,omitempty"`
	Price    uint32   `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *AssetPrice) Reset()         { *m = AssetPrice{} }
func (m *AssetPrice) String() string { return proto.CompactTextString(m) }
func (*AssetPrice) ProtoMessage()    {}
func (*AssetPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{4}
}
func (m *AssetPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssetPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssetPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssetPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssetPrice.Merge(m, src)
}
func (m *AssetPrice) XXX_Size() int {
	return m.Size()
}
func (m *AssetPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_AssetPrice.DiscardUnknown(m)
}

var xxx_messageInfo_AssetPrice proto.InternalMessageInfo

func (m *AssetPrice) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *AssetPrice) GetChainIds() []uint64 {
	if m != nil {
		return m.ChainIds
	}
	return nil
}

func (m *AssetPrice) GetPrice() uint32 {
	if m != nil {
		return m.Price
	}
	return 0
}

// each chainid's gas price, as it's very dynamic, the goal is only to avoid off too much
type GasPrice struct {
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// price is generally ethclient.SuggestGasPrice big.Int.String(), with special handling for chains whose suggest is off.
	// Will be uploaded somewhere (eg. S3) via a separate service for relayer to read.
	Price string `protobuf:"bytes,2,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *GasPrice) Reset()         { *m = GasPrice{} }
func (m *GasPrice) String() string { return proto.CompactTextString(m) }
func (*GasPrice) ProtoMessage()    {}
func (*GasPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{5}
}
func (m *GasPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasPrice.Merge(m, src)
}
func (m *GasPrice) XXX_Size() int {
	return m.Size()
}
func (m *GasPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_GasPrice.DiscardUnknown(m)
}

var xxx_messageInfo_GasPrice proto.InternalMessageInfo

func (m *GasPrice) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *GasPrice) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

// represent asset detail on one chain.
type ChainAsset struct {
	Symbol       string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	ChainId      uint64 `protobuf:"varint,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Addr         string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	Decimal      uint32 `protobuf:"varint,4,opt,name=decimal,proto3" json:"decimal,omitempty"`
	MaxFeeAmount string `protobuf:"bytes,5,opt,name=max_fee_amount,json=maxFeeAmount,proto3" json:"max_fee_amount,omitempty"`
	XferDisabled bool   `protobuf:"varint,6,opt,name=xfer_disabled,json=xferDisabled,proto3" json:"xfer_disabled,omitempty"`
	MaxOutAmt    string `protobuf:"bytes,7,opt,name=max_out_amt,json=maxOutAmt,proto3" json:"max_out_amt,omitempty"`
}

func (m *ChainAsset) Reset()         { *m = ChainAsset{} }
func (m *ChainAsset) String() string { return proto.CompactTextString(m) }
func (*ChainAsset) ProtoMessage()    {}
func (*ChainAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{6}
}
func (m *ChainAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainAsset.Merge(m, src)
}
func (m *ChainAsset) XXX_Size() int {
	return m.Size()
}
func (m *ChainAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainAsset.DiscardUnknown(m)
}

var xxx_messageInfo_ChainAsset proto.InternalMessageInfo

func (m *ChainAsset) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *ChainAsset) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *ChainAsset) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *ChainAsset) GetDecimal() uint32 {
	if m != nil {
		return m.Decimal
	}
	return 0
}

func (m *ChainAsset) GetMaxFeeAmount() string {
	if m != nil {
		return m.MaxFeeAmount
	}
	return ""
}

func (m *ChainAsset) GetXferDisabled() bool {
	if m != nil {
		return m.XferDisabled
	}
	return false
}

func (m *ChainAsset) GetMaxOutAmt() string {
	if m != nil {
		return m.MaxOutAmt
	}
	return ""
}

// chid1 must be smaller than chid2 order
type ChainPair struct {
	Chid1   uint64 `protobuf:"varint,1,opt,name=chid1,proto3" json:"chid1,omitempty"`
	Chid2   uint64 `protobuf:"varint,2,opt,name=chid2,proto3" json:"chid2,omitempty"`
	Weight1 uint32 `protobuf:"varint,3,opt,name=weight1,proto3" json:"weight1,omitempty"`
	Fee1To2 uint32 `protobuf:"varint,4,opt,name=fee1to2,proto3" json:"fee1to2,omitempty"`
	Fee2To1 uint32 `protobuf:"varint,5,opt,name=fee2to1,proto3" json:"fee2to1,omitempty"`
	ConstA  uint32 `protobuf:"varint,6,opt,name=const_a,json=constA,proto3" json:"const_a,omitempty"`
	// no_curve should only be config in PerChainPairAssetOverride. if set, MUST not set weight1 and const_a
	NoCurve bool `protobuf:"varint,7,opt,name=no_curve,json=noCurve,proto3" json:"no_curve,omitempty"`
}

func (m *ChainPair) Reset()         { *m = ChainPair{} }
func (m *ChainPair) String() string { return proto.CompactTextString(m) }
func (*ChainPair) ProtoMessage()    {}
func (*ChainPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{7}
}
func (m *ChainPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainPair.Merge(m, src)
}
func (m *ChainPair) XXX_Size() int {
	return m.Size()
}
func (m *ChainPair) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainPair.DiscardUnknown(m)
}

var xxx_messageInfo_ChainPair proto.InternalMessageInfo

func (m *ChainPair) GetChid1() uint64 {
	if m != nil {
		return m.Chid1
	}
	return 0
}

func (m *ChainPair) GetChid2() uint64 {
	if m != nil {
		return m.Chid2
	}
	return 0
}

func (m *ChainPair) GetWeight1() uint32 {
	if m != nil {
		return m.Weight1
	}
	return 0
}

func (m *ChainPair) GetFee1To2() uint32 {
	if m != nil {
		return m.Fee1To2
	}
	return 0
}

func (m *ChainPair) GetFee2To1() uint32 {
	if m != nil {
		return m.Fee2To1
	}
	return 0
}

func (m *ChainPair) GetConstA() uint32 {
	if m != nil {
		return m.ConstA
	}
	return 0
}

func (m *ChainPair) GetNoCurve() bool {
	if m != nil {
		return m.NoCurve
	}
	return false
}

// some asset requires different const A/weight, fee percentage than ChainPair
// so we allow per (chain pair, asset) override, if transfer happens between supported chains, these parameters
// will be used instead of ones in ChainPair. asset must be already configued in ChainAsset
// note if override
type PerChainPairAssetOverride struct {
	Symbol string     `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Chpair *ChainPair `protobuf:"bytes,2,opt,name=chpair,proto3" json:"chpair,omitempty"`
}

func (m *PerChainPairAssetOverride) Reset()         { *m = PerChainPairAssetOverride{} }
func (m *PerChainPairAssetOverride) String() string { return proto.CompactTextString(m) }
func (*PerChainPairAssetOverride) ProtoMessage()    {}
func (*PerChainPairAssetOverride) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{8}
}
func (m *PerChainPairAssetOverride) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerChainPairAssetOverride) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerChainPairAssetOverride.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerChainPairAssetOverride) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerChainPairAssetOverride.Merge(m, src)
}
func (m *PerChainPairAssetOverride) XXX_Size() int {
	return m.Size()
}
func (m *PerChainPairAssetOverride) XXX_DiscardUnknown() {
	xxx_messageInfo_PerChainPairAssetOverride.DiscardUnknown(m)
}

var xxx_messageInfo_PerChainPairAssetOverride proto.InternalMessageInfo

func (m *PerChainPairAssetOverride) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *PerChainPairAssetOverride) GetChpair() *ChainPair {
	if m != nil {
		return m.Chpair
	}
	return nil
}

// propose new cbr config, note it must be a whole json
type CbrProposal struct {
	Title       string     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	CbrConfig   *CbrConfig `protobuf:"bytes,3,opt,name=cbr_config,json=cbrConfig,proto3" json:"cbr_config,omitempty"`
	// deposit amount for MsgSubmitProposal
	Deposit github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=deposit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"deposit"`
}

func (m *CbrProposal) Reset()         { *m = CbrProposal{} }
func (m *CbrProposal) String() string { return proto.CompactTextString(m) }
func (*CbrProposal) ProtoMessage()    {}
func (*CbrProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{9}
}
func (m *CbrProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CbrProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CbrProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CbrProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CbrProposal.Merge(m, src)
}
func (m *CbrProposal) XXX_Size() int {
	return m.Size()
}
func (m *CbrProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_CbrProposal.DiscardUnknown(m)
}

var xxx_messageInfo_CbrProposal proto.InternalMessageInfo

func (m *CbrProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *CbrProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CbrProposal) GetCbrConfig() *CbrConfig {
	if m != nil {
		return m.CbrConfig
	}
	return nil
}

// ========== for sync propose
// to be included in sync propose update, broadcast by syncer to tell others
// an onchain event happened. for completeness we include chainid, even though
// propose update also has it
type OnChainEvent struct {
	Chainid uint64 `protobuf:"varint,1,opt,name=chainid,proto3" json:"chainid,omitempty"`
	Evtype  string `protobuf:"bytes,2,opt,name=evtype,proto3" json:"evtype,omitempty"`
	Elog    []byte `protobuf:"bytes,3,opt,name=elog,proto3" json:"elog,omitempty"`
}

func (m *OnChainEvent) Reset()         { *m = OnChainEvent{} }
func (m *OnChainEvent) String() string { return proto.CompactTextString(m) }
func (*OnChainEvent) ProtoMessage()    {}
func (*OnChainEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{10}
}
func (m *OnChainEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OnChainEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OnChainEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OnChainEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OnChainEvent.Merge(m, src)
}
func (m *OnChainEvent) XXX_Size() int {
	return m.Size()
}
func (m *OnChainEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_OnChainEvent.DiscardUnknown(m)
}

var xxx_messageInfo_OnChainEvent proto.InternalMessageInfo

func (m *OnChainEvent) GetChainid() uint64 {
	if m != nil {
		return m.Chainid
	}
	return 0
}

func (m *OnChainEvent) GetEvtype() string {
	if m != nil {
		return m.Evtype
	}
	return ""
}

func (m *OnChainEvent) GetElog() []byte {
	if m != nil {
		return m.Elog
	}
	return nil
}

// ========== onchain tx data
// same proto used by solidity, serialized bytes are signed by sgn nodes then submit onchain to relay function
// x/cbridge will emit tendermint event, relayer monitor and send msg w/ its signature
type RelayOnChain struct {
	Sender        []byte `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Receiver      []byte `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Token         []byte `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	Amount        []byte `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`
	SrcChainId    uint64 `protobuf:"varint,5,opt,name=src_chain_id,json=srcChainId,proto3" json:"src_chain_id,omitempty"`
	DstChainId    uint64 `protobuf:"varint,6,opt,name=dst_chain_id,json=dstChainId,proto3" json:"dst_chain_id,omitempty"`
	SrcTransferId []byte `protobuf:"bytes,7,opt,name=src_transfer_id,json=srcTransferId,proto3" json:"src_transfer_id,omitempty"`
}

func (m *RelayOnChain) Reset()      { *m = RelayOnChain{} }
func (*RelayOnChain) ProtoMessage() {}
func (*RelayOnChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{11}
}
func (m *RelayOnChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RelayOnChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RelayOnChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RelayOnChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RelayOnChain.Merge(m, src)
}
func (m *RelayOnChain) XXX_Size() int {
	return m.Size()
}
func (m *RelayOnChain) XXX_DiscardUnknown() {
	xxx_messageInfo_RelayOnChain.DiscardUnknown(m)
}

var xxx_messageInfo_RelayOnChain proto.InternalMessageInfo

func (m *RelayOnChain) GetSender() []byte {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *RelayOnChain) GetReceiver() []byte {
	if m != nil {
		return m.Receiver
	}
	return nil
}

func (m *RelayOnChain) GetToken() []byte {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *RelayOnChain) GetAmount() []byte {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *RelayOnChain) GetSrcChainId() uint64 {
	if m != nil {
		return m.SrcChainId
	}
	return 0
}

func (m *RelayOnChain) GetDstChainId() uint64 {
	if m != nil {
		return m.DstChainId
	}
	return 0
}

func (m *RelayOnChain) GetSrcTransferId() []byte {
	if m != nil {
		return m.SrcTransferId
	}
	return nil
}

// data when call withdraw onchain
type WithdrawOnchain struct {
	Chainid  uint64 `protobuf:"varint,1,opt,name=chainid,proto3" json:"chainid,omitempty"`
	Seqnum   uint64 `protobuf:"varint,2,opt,name=seqnum,proto3" json:"seqnum,omitempty"`
	Receiver []byte `protobuf:"bytes,3,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Token    []byte `protobuf:"bytes,4,opt,name=token,proto3" json:"token,omitempty"`
	Amount   []byte `protobuf:"bytes,5,opt,name=amount,proto3" json:"amount,omitempty"`
	Refid    []byte `protobuf:"bytes,6,opt,name=refid,proto3" json:"refid,omitempty"`
}

func (m *WithdrawOnchain) Reset()      { *m = WithdrawOnchain{} }
func (*WithdrawOnchain) ProtoMessage() {}
func (*WithdrawOnchain) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{12}
}
func (m *WithdrawOnchain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawOnchain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawOnchain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawOnchain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawOnchain.Merge(m, src)
}
func (m *WithdrawOnchain) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawOnchain) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawOnchain.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawOnchain proto.InternalMessageInfo

func (m *WithdrawOnchain) GetChainid() uint64 {
	if m != nil {
		return m.Chainid
	}
	return 0
}

func (m *WithdrawOnchain) GetSeqnum() uint64 {
	if m != nil {
		return m.Seqnum
	}
	return 0
}

func (m *WithdrawOnchain) GetReceiver() []byte {
	if m != nil {
		return m.Receiver
	}
	return nil
}

func (m *WithdrawOnchain) GetToken() []byte {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *WithdrawOnchain) GetAmount() []byte {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *WithdrawOnchain) GetRefid() []byte {
	if m != nil {
		return m.Refid
	}
	return nil
}

// saved and updated when new sig is added
type XferRelay struct {
	Relay []byte `protobuf:"bytes,1,opt,name=relay,proto3" json:"relay,omitempty"`
	// each sgn node send SendMySig and x/cbridge add to sigs,
	// NOTE sigs need to be sorted by recovered signer address
	SortedSigs  []*AddrSig `protobuf:"bytes,2,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	LastReqTime int64      `protobuf:"varint,3,opt,name=last_req_time,json=lastReqTime,proto3" json:"last_req_time,omitempty"`
	PercFee     []byte     `protobuf:"bytes,4,opt,name=perc_fee,json=percFee,proto3" json:"perc_fee,omitempty"`
	BaseFee     []byte     `protobuf:"bytes,5,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
}

func (m *XferRelay) Reset()         { *m = XferRelay{} }
func (m *XferRelay) String() string { return proto.CompactTextString(m) }
func (*XferRelay) ProtoMessage()    {}
func (*XferRelay) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{13}
}
func (m *XferRelay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *XferRelay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_XferRelay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *XferRelay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_XferRelay.Merge(m, src)
}
func (m *XferRelay) XXX_Size() int {
	return m.Size()
}
func (m *XferRelay) XXX_DiscardUnknown() {
	xxx_messageInfo_XferRelay.DiscardUnknown(m)
}

var xxx_messageInfo_XferRelay proto.InternalMessageInfo

func (m *XferRelay) GetRelay() []byte {
	if m != nil {
		return m.Relay
	}
	return nil
}

func (m *XferRelay) GetSortedSigs() []*AddrSig {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *XferRelay) GetLastReqTime() int64 {
	if m != nil {
		return m.LastReqTime
	}
	return 0
}

func (m *XferRelay) GetPercFee() []byte {
	if m != nil {
		return m.PercFee
	}
	return nil
}

func (m *XferRelay) GetBaseFee() []byte {
	if m != nil {
		return m.BaseFee
	}
	return nil
}

type WithdrawDetail struct {
	WdOnchain   []byte     `protobuf:"bytes,1,opt,name=wd_onchain,json=wdOnchain,proto3" json:"wd_onchain,omitempty"`
	SortedSigs  []*AddrSig `protobuf:"bytes,2,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	Completed   bool       `protobuf:"varint,3,opt,name=completed,proto3" json:"completed,omitempty"`
	LastReqTime int64      `protobuf:"varint,4,opt,name=last_req_time,json=lastReqTime,proto3" json:"last_req_time,omitempty"`
	XferId      []byte     `protobuf:"bytes,5,opt,name=xferId,proto3" json:"xferId,omitempty"`
}

func (m *WithdrawDetail) Reset()         { *m = WithdrawDetail{} }
func (m *WithdrawDetail) String() string { return proto.CompactTextString(m) }
func (*WithdrawDetail) ProtoMessage()    {}
func (*WithdrawDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{14}
}
func (m *WithdrawDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawDetail.Merge(m, src)
}
func (m *WithdrawDetail) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawDetail.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawDetail proto.InternalMessageInfo

func (m *WithdrawDetail) GetWdOnchain() []byte {
	if m != nil {
		return m.WdOnchain
	}
	return nil
}

func (m *WithdrawDetail) GetSortedSigs() []*AddrSig {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *WithdrawDetail) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *WithdrawDetail) GetLastReqTime() int64 {
	if m != nil {
		return m.LastReqTime
	}
	return 0
}

func (m *WithdrawDetail) GetXferId() []byte {
	if m != nil {
		return m.XferId
	}
	return nil
}

type AddrSig struct {
	Addr []byte `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Sig  []byte `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *AddrSig) Reset()         { *m = AddrSig{} }
func (m *AddrSig) String() string { return proto.CompactTextString(m) }
func (*AddrSig) ProtoMessage()    {}
func (*AddrSig) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{15}
}
func (m *AddrSig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddrSig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddrSig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddrSig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddrSig.Merge(m, src)
}
func (m *AddrSig) XXX_Size() int {
	return m.Size()
}
func (m *AddrSig) XXX_DiscardUnknown() {
	xxx_messageInfo_AddrSig.DiscardUnknown(m)
}

var xxx_messageInfo_AddrSig proto.InternalMessageInfo

func (m *AddrSig) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *AddrSig) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

type Signer struct {
	Addr  []byte `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Power []byte `protobuf:"bytes,2,opt,name=power,proto3" json:"power,omitempty"`
}

func (m *Signer) Reset()      { *m = Signer{} }
func (*Signer) ProtoMessage() {}
func (*Signer) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{16}
}
func (m *Signer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signer.Merge(m, src)
}
func (m *Signer) XXX_Size() int {
	return m.Size()
}
func (m *Signer) XXX_DiscardUnknown() {
	xxx_messageInfo_Signer.DiscardUnknown(m)
}

var xxx_messageInfo_Signer proto.InternalMessageInfo

func (m *Signer) GetAddr() []byte {
	if m != nil {
		return m.Addr
	}
	return nil
}

func (m *Signer) GetPower() []byte {
	if m != nil {
		return m.Power
	}
	return nil
}

type ChainSigners struct {
	ChainId       uint64     `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	SortedSigners []*Signer  `protobuf:"bytes,2,rep,name=sorted_signers,json=sortedSigners,proto3" json:"sorted_signers,omitempty"`
	SortedSigs    []*AddrSig `protobuf:"bytes,3,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
}

func (m *ChainSigners) Reset()      { *m = ChainSigners{} }
func (*ChainSigners) ProtoMessage() {}
func (*ChainSigners) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{17}
}
func (m *ChainSigners) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainSigners) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainSigners.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainSigners) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainSigners.Merge(m, src)
}
func (m *ChainSigners) XXX_Size() int {
	return m.Size()
}
func (m *ChainSigners) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainSigners.DiscardUnknown(m)
}

var xxx_messageInfo_ChainSigners proto.InternalMessageInfo

func (m *ChainSigners) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *ChainSigners) GetSortedSigners() []*Signer {
	if m != nil {
		return m.SortedSigners
	}
	return nil
}

func (m *ChainSigners) GetSortedSigs() []*AddrSig {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

type LatestSigners struct {
	SortedSigners []*Signer `protobuf:"bytes,1,rep,name=sorted_signers,json=sortedSigners,proto3" json:"sorted_signers,omitempty"`
	SignersBytes  []byte    `protobuf:"bytes,2,opt,name=signers_bytes,json=signersBytes,proto3" json:"signers_bytes,omitempty"`
	TriggerTime   uint64    `protobuf:"varint,3,opt,name=trigger_time,json=triggerTime,proto3" json:"trigger_time,omitempty"`
	LastSignTime  uint64    `protobuf:"varint,4,opt,name=last_sign_time,json=lastSignTime,proto3" json:"last_sign_time,omitempty"`
}

func (m *LatestSigners) Reset()      { *m = LatestSigners{} }
func (*LatestSigners) ProtoMessage() {}
func (*LatestSigners) Descriptor() ([]byte, []int) {
	return fileDescriptor_ea88343271b63cf0, []int{18}
}
func (m *LatestSigners) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LatestSigners) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LatestSigners.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LatestSigners) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LatestSigners.Merge(m, src)
}
func (m *LatestSigners) XXX_Size() int {
	return m.Size()
}
func (m *LatestSigners) XXX_DiscardUnknown() {
	xxx_messageInfo_LatestSigners.DiscardUnknown(m)
}

var xxx_messageInfo_LatestSigners proto.InternalMessageInfo

func (m *LatestSigners) GetSortedSigners() []*Signer {
	if m != nil {
		return m.SortedSigners
	}
	return nil
}

func (m *LatestSigners) GetSignersBytes() []byte {
	if m != nil {
		return m.SignersBytes
	}
	return nil
}

func (m *LatestSigners) GetTriggerTime() uint64 {
	if m != nil {
		return m.TriggerTime
	}
	return 0
}

func (m *LatestSigners) GetLastSignTime() uint64 {
	if m != nil {
		return m.LastSignTime
	}
	return 0
}

func init() {
	proto.RegisterEnum("sgn.cbridge.v1.XferStatus", XferStatus_name, XferStatus_value)
	proto.RegisterType((*Params)(nil), "sgn.cbridge.v1.Params")
	proto.RegisterType((*CbrConfig)(nil), "sgn.cbridge.v1.CbrConfig")
	proto.RegisterType((*CbrPrice)(nil), "sgn.cbridge.v1.CbrPrice")
	proto.RegisterType((*RelayGasCostParam)(nil), "sgn.cbridge.v1.RelayGasCostParam")
	proto.RegisterType((*AssetPrice)(nil), "sgn.cbridge.v1.AssetPrice")
	proto.RegisterType((*GasPrice)(nil), "sgn.cbridge.v1.GasPrice")
	proto.RegisterType((*ChainAsset)(nil), "sgn.cbridge.v1.ChainAsset")
	proto.RegisterType((*ChainPair)(nil), "sgn.cbridge.v1.ChainPair")
	proto.RegisterType((*PerChainPairAssetOverride)(nil), "sgn.cbridge.v1.PerChainPairAssetOverride")
	proto.RegisterType((*CbrProposal)(nil), "sgn.cbridge.v1.CbrProposal")
	proto.RegisterType((*OnChainEvent)(nil), "sgn.cbridge.v1.OnChainEvent")
	proto.RegisterType((*RelayOnChain)(nil), "sgn.cbridge.v1.RelayOnChain")
	proto.RegisterType((*WithdrawOnchain)(nil), "sgn.cbridge.v1.WithdrawOnchain")
	proto.RegisterType((*XferRelay)(nil), "sgn.cbridge.v1.XferRelay")
	proto.RegisterType((*WithdrawDetail)(nil), "sgn.cbridge.v1.WithdrawDetail")
	proto.RegisterType((*AddrSig)(nil), "sgn.cbridge.v1.AddrSig")
	proto.RegisterType((*Signer)(nil), "sgn.cbridge.v1.Signer")
	proto.RegisterType((*ChainSigners)(nil), "sgn.cbridge.v1.ChainSigners")
	proto.RegisterType((*LatestSigners)(nil), "sgn.cbridge.v1.LatestSigners")
}

func init() { proto.RegisterFile("sgn/cbridge/v1/cbridge.proto", fileDescriptor_ea88343271b63cf0) }

var fileDescriptor_ea88343271b63cf0 = []byte{
	// 1793 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x4a, 0x14, 0x3f, 0x1e, 0x97, 0x32, 0x3d, 0x50, 0x1c, 0x4a, 0x89, 0x25, 0x85, 0x31,
	0x52, 0xb7, 0xa8, 0x45, 0x48, 0x45, 0x01, 0xc3, 0x41, 0x81, 0x52, 0xe4, 0xca, 0x21, 0x2c, 0x8b,
	0xca, 0x92, 0xaa, 0x9d, 0xf6, 0xb0, 0x18, 0xee, 0x0e, 0x57, 0x0b, 0xef, 0xee, 0xac, 0x67, 0x86,
	0x94, 0x94, 0xff, 0xa0, 0xa7, 0xf6, 0x98, 0x53, 0x91, 0xde, 0xda, 0x7b, 0x0b, 0xb4, 0xd7, 0xf6,
	0x92, 0x63, 0xd0, 0x53, 0xe0, 0x83, 0x5b, 0xd8, 0x3d, 0x14, 0x3d, 0xf6, 0xda, 0x4b, 0x31, 0x1f,
	0x4b, 0x59, 0x5f, 0x6e, 0x9b, 0x13, 0xe7, 0xbd, 0x79, 0x9f, 0xbf, 0xf7, 0xe6, 0xbd, 0x25, 0xbc,
	0xcf, 0xc3, 0xb4, 0xe5, 0x8f, 0x58, 0x14, 0x84, 0xa4, 0x35, 0xdd, 0xca, 0x8f, 0x9b, 0x19, 0xa3,
	0x82, 0xa2, 0x25, 0x1e, 0xa6, 0x9b, 0x39, 0x6b, 0xba, 0xb5, 0xba, 0xe2, 0x53, 0x9e, 0x50, 0xee,
	0xa9, 0xdb, 0x96, 0x26, 0xb4, 0xe8, 0xea, 0x72, 0x48, 0x43, 0xaa, 0xf9, 0xf2, 0x64, 0xb8, 0xeb,
	0x21, 0xa5, 0x61, 0x4c, 0x5a, 0x8a, 0x1a, 0x4d, 0xc6, 0x2d, 0x11, 0x25, 0x84, 0x0b, 0x9c, 0x64,
	0x46, 0x60, 0xed, 0xa2, 0x40, 0x30, 0x61, 0x58, 0x44, 0x34, 0x35, 0xf7, 0xab, 0x2a, 0x3e, 0x9a,
	0x24, 0x34, 0x55, 0xe1, 0xa9, 0x93, 0xbe, 0x6b, 0xfe, 0x7d, 0x1e, 0x8a, 0x07, 0x98, 0xe1, 0x84,
	0xa3, 0x5f, 0x59, 0x70, 0x8b, 0x47, 0x61, 0x4a, 0x98, 0x37, 0xc9, 0x02, 0x2c, 0x88, 0x97, 0xdb,
	0x69, 0x58, 0x1b, 0xd6, 0xdd, 0xea, 0xf6, 0xca, 0xa6, 0x76, 0xb4, 0x99, 0x3b, 0xda, 0xec, 0x1a,
	0x81, 0x9d, 0xc7, 0x5f, 0xbd, 0x5c, 0x9f, 0xfb, 0xe7, 0xcb, 0xf5, 0x8d, 0xab, 0x0d, 0x7c, 0x9f,
	0x26, 0x91, 0x20, 0x49, 0x26, 0x4e, 0xff, 0xf5, 0x72, 0xfd, 0xf6, 0x29, 0x4e, 0xe2, 0x07, 0xcd,
	0xab, 0x25, 0x9b, 0x5f, 0xfc, 0x75, 0xdd, 0x72, 0x97, 0xf5, 0xe5, 0xa1, 0xba, 0xcb, 0x9d, 0xa0,
	0x3f, 0x58, 0x70, 0x5b, 0x5e, 0x78, 0x38, 0xc4, 0x51, 0xea, 0xf9, 0x94, 0xc6, 0x5e, 0x40, 0x8f,
	0xd3, 0xb3, 0x38, 0xe7, 0xff, 0x5b, 0x9c, 0x3f, 0x33, 0x71, 0x7e, 0xe7, 0xad, 0x76, 0xce, 0x85,
	0x7b, 0xe7, 0x2c, 0xdc, 0x6b, 0x15, 0x74, 0xd4, 0x2b, 0x52, 0xa6, 0x2d, 0x45, 0x3a, 0x94, 0xc6,
	0x5d, 0x7a, 0x9c, 0xe6, 0x7e, 0x9b, 0xbf, 0x58, 0x80, 0x4a, 0x67, 0xc4, 0x3a, 0x34, 0x1d, 0x47,
	0x21, 0x5a, 0x83, 0x6a, 0x9c, 0x79, 0x63, 0x42, 0xbc, 0x8c, 0x30, 0x5f, 0xa1, 0x5b, 0x73, 0x2b,
	0x71, 0xb6, 0x4b, 0xc8, 0x01, 0x61, 0x3e, 0xda, 0x00, 0x3b, 0x8b, 0xfc, 0x67, 0x5e, 0x9c, 0x79,
	0x3c, 0xfa, 0x9c, 0x34, 0x0a, 0x4a, 0x00, 0x24, 0x6f, 0x2f, 0x1b, 0x44, 0x9f, 0x13, 0xf4, 0x10,
	0x96, 0x18, 0x89, 0xf1, 0xa9, 0x17, 0x62, 0xee, 0xf9, 0x94, 0x8b, 0xc6, 0xe2, 0xc6, 0xc2, 0xdd,
	0xea, 0xf6, 0x07, 0x9b, 0xe7, 0xbb, 0x6d, 0xd3, 0x95, 0x52, 0x0f, 0x31, 0xef, 0x50, 0x2e, 0x54,
	0x9d, 0x5d, 0x9b, 0xbd, 0xc1, 0x42, 0xdb, 0x50, 0xc4, 0x9c, 0x13, 0xc1, 0x1b, 0xf3, 0xca, 0xc0,
	0xea, 0x45, 0x03, 0x9d, 0x23, 0x1c, 0xa5, 0x6d, 0x29, 0xe2, 0x1a, 0x49, 0xf4, 0x00, 0xaa, 0xbe,
	0xe4, 0x7a, 0x19, 0x8e, 0x18, 0x6f, 0x2c, 0x28, 0xc5, 0x95, 0x2b, 0x15, 0x0f, 0x70, 0xc4, 0x5c,
	0xf0, 0xf3, 0x23, 0x47, 0x3f, 0x86, 0x9a, 0x3f, 0x62, 0x9e, 0x4f, 0x53, 0xc1, 0xb0, 0x2f, 0x78,
	0xa3, 0xa8, 0xb4, 0xdf, 0xd3, 0xda, 0xba, 0x33, 0xa5, 0xb2, 0xb9, 0xef, 0xa5, 0x63, 0xea, 0xda,
	0xbe, 0x42, 0x4e, 0x2b, 0x20, 0x07, 0xca, 0x74, 0x4a, 0x18, 0x8b, 0x02, 0xd2, 0x28, 0x29, 0xe5,
	0xef, 0x5e, 0x74, 0x7d, 0x40, 0xd8, 0xcc, 0xbb, 0x0a, 0xbd, 0x6f, 0x14, 0xdc, 0x99, 0x6a, 0xf3,
	0xd7, 0x16, 0x94, 0x3b, 0x23, 0x76, 0xc0, 0x22, 0x9f, 0xa0, 0x0f, 0xc0, 0x36, 0x7d, 0x48, 0x32,
	0xea, 0x1f, 0xa9, 0x8a, 0x14, 0xdc, 0xaa, 0xe6, 0x39, 0x92, 0x85, 0x3e, 0x86, 0xaa, 0x4a, 0xdf,
	0xcb, 0xa4, 0x86, 0x81, 0xfb, 0x12, 0x5a, 0xca, 0x9b, 0xb2, 0xe9, 0x02, 0x9e, 0x9d, 0xd1, 0x0f,
	0xa1, 0x22, 0x0b, 0xa5, 0x55, 0x75, 0xc6, 0x8d, 0x8b, 0xaa, 0x0f, 0x31, 0xd7, 0x8a, 0xe5, 0xd0,
	0x9c, 0x9a, 0x3f, 0xb7, 0xe0, 0xe6, 0xa5, 0x02, 0xa2, 0x15, 0x28, 0x6b, 0xf8, 0xa3, 0xc0, 0x04,
	0x5a, 0x52, 0x74, 0x2f, 0x40, 0xef, 0x41, 0x45, 0x36, 0x83, 0x37, 0xc2, 0x9c, 0xa8, 0xc7, 0x50,
	0x73, 0xcb, 0x92, 0xb1, 0x83, 0x39, 0x41, 0x1f, 0x42, 0x2d, 0x23, 0xcc, 0x9b, 0xe2, 0x38, 0x0a,
	0xb0, 0xa0, 0xac, 0xb1, 0xa0, 0x04, 0xec, 0x8c, 0xb0, 0x9f, 0xe4, 0x3c, 0xf4, 0x2e, 0x94, 0xa4,
	0x10, 0x8f, 0x42, 0xd3, 0x75, 0xc5, 0x8c, 0xb0, 0x41, 0x14, 0x36, 0x9f, 0x00, 0x9c, 0x25, 0x87,
	0x6e, 0x41, 0x91, 0x9f, 0x26, 0x23, 0x1a, 0xab, 0x08, 0x2a, 0xae, 0xa1, 0x54, 0x00, 0x26, 0x36,
	0xdd, 0x51, 0x05, 0xb7, 0x6c, 0x82, 0xe3, 0x68, 0x19, 0x16, 0x35, 0x02, 0xda, 0xb1, 0x26, 0x9a,
	0x1f, 0x43, 0x39, 0x4f, 0xfd, 0x6d, 0xa9, 0xcd, 0x94, 0xe7, 0x95, 0x43, 0xa3, 0xfc, 0x8d, 0x05,
	0x70, 0xd6, 0xa1, 0xd7, 0x86, 0xf5, 0xa6, 0xdd, 0xf9, 0xf3, 0x76, 0x11, 0x14, 0x70, 0x10, 0x68,
	0x30, 0x2a, 0xae, 0x3a, 0xa3, 0x06, 0x94, 0x02, 0xe2, 0x47, 0x09, 0x8e, 0x0d, 0x08, 0x39, 0x89,
	0xee, 0xc0, 0x52, 0x82, 0x4f, 0xd4, 0xd3, 0xc5, 0x09, 0x9d, 0xa4, 0xf2, 0xdd, 0x49, 0x3d, 0x3b,
	0xc1, 0x27, 0xbb, 0x84, 0xb4, 0x15, 0x4f, 0x22, 0x7d, 0x32, 0x26, 0xcc, 0x0b, 0x22, 0x8e, 0x47,
	0x31, 0x09, 0x1a, 0xc5, 0x0d, 0xeb, 0x6e, 0xd9, 0xb5, 0x25, 0xb3, 0x6b, 0x78, 0x72, 0x08, 0x48,
	0x53, 0x74, 0x22, 0x3c, 0x9c, 0x88, 0x46, 0x49, 0xd9, 0xa9, 0x24, 0xf8, 0xa4, 0x3f, 0x11, 0xed,
	0x44, 0x34, 0xff, 0x68, 0x41, 0x65, 0xd6, 0xc5, 0x32, 0x7d, 0xff, 0x28, 0x0a, 0xb6, 0x0c, 0x2c,
	0x9a, 0xc8, 0xb9, 0xdb, 0x26, 0x29, 0x4d, 0xc8, 0xf0, 0x8f, 0x49, 0x14, 0x1e, 0x89, 0x2d, 0x83,
	0x74, 0x4e, 0xca, 0x9b, 0x31, 0x21, 0x5b, 0x82, 0x6e, 0xe7, 0x89, 0x19, 0xd2, 0xdc, 0x6c, 0x0b,
	0xba, 0xa5, 0x32, 0xd2, 0x37, 0x92, 0x94, 0x1d, 0xe1, 0xd3, 0x94, 0x0b, 0x0f, 0xab, 0x34, 0x6a,
	0x6e, 0x51, 0x91, 0x6d, 0x09, 0x6a, 0x4a, 0x3d, 0x7f, 0xc2, 0xa6, 0x44, 0x45, 0x5f, 0x76, 0x4b,
	0x29, 0xed, 0x48, 0xb2, 0x39, 0x86, 0x95, 0x6b, 0xdf, 0xe0, 0xb5, 0x45, 0xda, 0x82, 0xa2, 0x7f,
	0x24, 0x47, 0xca, 0x6c, 0x8c, 0x5f, 0x3b, 0x51, 0x8c, 0x60, 0xf3, 0x85, 0x05, 0x55, 0xf5, 0x88,
	0x69, 0x46, 0x39, 0x8e, 0x25, 0x1e, 0x22, 0x12, 0x31, 0x31, 0x96, 0x35, 0x81, 0x36, 0xa0, 0x1a,
	0x10, 0xee, 0xb3, 0x28, 0x9b, 0x2d, 0x89, 0x8a, 0xfb, 0x26, 0x0b, 0xdd, 0x07, 0x30, 0x53, 0x69,
	0x1c, 0x85, 0x0a, 0xb4, 0xab, 0xdc, 0xe7, 0xf3, 0xdb, 0xad, 0xf8, 0xb3, 0x51, 0xfe, 0x89, 0x6c,
	0x95, 0x8c, 0xf2, 0x48, 0x28, 0x44, 0x2b, 0x3b, 0x9b, 0x72, 0xc3, 0xbc, 0x78, 0xb9, 0xfe, 0x51,
	0x18, 0x89, 0xa3, 0xc9, 0x48, 0xce, 0x34, 0xb3, 0xe4, 0xcd, 0xcf, 0x3d, 0x1e, 0x3c, 0x6b, 0x89,
	0xd3, 0x8c, 0xf0, 0xcd, 0x5e, 0x2a, 0xdc, 0x5c, 0xfd, 0xc1, 0x8d, 0x7f, 0x7c, 0xb9, 0x3e, 0xf7,
	0x97, 0xdf, 0xdd, 0x2b, 0xc9, 0x51, 0x47, 0x52, 0xd1, 0x1c, 0x82, 0xdd, 0x4f, 0x55, 0xce, 0xce,
	0x94, 0xa4, 0x42, 0x96, 0x48, 0x35, 0xed, 0x85, 0xb7, 0x11, 0x05, 0x12, 0x51, 0x32, 0x95, 0x26,
	0x4d, 0x6e, 0x86, 0x92, 0xbd, 0x4d, 0x62, 0xaa, 0x13, 0xb2, 0x5d, 0x75, 0x6e, 0xbe, 0xb2, 0xc0,
	0x56, 0x33, 0xc5, 0xd8, 0x56, 0xe5, 0x20, 0x69, 0x40, 0x98, 0xb2, 0x6a, 0xbb, 0x86, 0x42, 0xab,
	0x50, 0x66, 0xc4, 0x27, 0xd1, 0x94, 0xe8, 0x82, 0xd8, 0xee, 0x8c, 0x56, 0x38, 0xd3, 0x67, 0x24,
	0x35, 0x96, 0x35, 0x21, 0x2d, 0x99, 0x47, 0x51, 0xd0, 0x96, 0x34, 0x25, 0xd7, 0x19, 0x67, 0xbe,
	0x37, 0x7b, 0x81, 0x8b, 0x2a, 0x7a, 0xe0, 0xcc, 0xef, 0x98, 0x47, 0xb8, 0x01, 0x76, 0xc0, 0xc5,
	0x99, 0x44, 0x51, 0x4b, 0x04, 0x5c, 0xe4, 0x12, 0x1f, 0xc1, 0x0d, 0x69, 0x43, 0x30, 0x9c, 0x72,
	0xf9, 0xb4, 0xa2, 0x40, 0xf5, 0x9c, 0xed, 0xd6, 0x38, 0xf3, 0x87, 0x86, 0xdb, 0x0b, 0x1e, 0x14,
	0xbe, 0xf8, 0x72, 0x7d, 0xae, 0xf9, 0x5b, 0x0b, 0x6e, 0x3c, 0x89, 0xc4, 0x51, 0xc0, 0xf0, 0x71,
	0x3f, 0x55, 0x66, 0xdf, 0x0e, 0x1f, 0x27, 0xcf, 0xd3, 0x49, 0x62, 0x9e, 0x91, 0xa1, 0xce, 0x21,
	0xb0, 0x70, 0x1d, 0x02, 0x85, 0xab, 0x11, 0x58, 0x3c, 0x87, 0xc0, 0x32, 0x2c, 0x32, 0x32, 0x36,
	0x89, 0xd9, 0xae, 0x26, 0x4c, 0xac, 0xbf, 0xb7, 0xa0, 0xf2, 0x74, 0x4c, 0x98, 0x2a, 0x8a, 0x96,
	0x8c, 0xf1, 0xa9, 0x29, 0x86, 0x26, 0xd0, 0x7d, 0xa8, 0x72, 0xca, 0x04, 0x09, 0xe4, 0x60, 0xce,
	0x57, 0xf5, 0xbb, 0x97, 0x96, 0x4f, 0x10, 0xc8, 0x51, 0xed, 0x82, 0x96, 0x1d, 0x44, 0x21, 0x47,
	0x4d, 0xa8, 0xc5, 0x98, 0x0b, 0x8f, 0x91, 0xe7, 0x9e, 0xfc, 0x6e, 0x54, 0x89, 0x2c, 0xb8, 0x55,
	0xc9, 0x74, 0xc9, 0xf3, 0x61, 0x94, 0xa8, 0xa9, 0x2b, 0xbf, 0x43, 0xe4, 0x54, 0x33, 0xe9, 0xc8,
	0x1d, 0xe0, 0xef, 0x12, 0x75, 0x25, 0x77, 0x89, 0xba, 0xd2, 0x29, 0x95, 0x24, 0xbd, 0x4b, 0x48,
	0xf3, 0xcf, 0x16, 0x2c, 0xe5, 0x18, 0x77, 0x89, 0xc0, 0x51, 0x8c, 0x6e, 0x03, 0x1c, 0x07, 0x1e,
	0xd5, 0x80, 0x9b, 0x0c, 0x2a, 0xc7, 0x41, 0x5e, 0x81, 0x6f, 0x9f, 0xc5, 0xfb, 0x72, 0xaf, 0x25,
	0x59, 0x4c, 0x04, 0x09, 0x54, 0x06, 0x65, 0xf7, 0x8c, 0x71, 0x39, 0xc7, 0xc2, 0xe5, 0x1c, 0x6f,
	0x41, 0xf1, 0x44, 0x75, 0x48, 0x5e, 0x19, 0x4d, 0x35, 0x5b, 0x50, 0x32, 0x0e, 0x67, 0x9b, 0x40,
	0xc7, 0xad, 0x37, 0x41, 0x1d, 0x16, 0xe4, 0x2a, 0xd4, 0xfd, 0x2f, 0x8f, 0xcd, 0xfb, 0x50, 0x1c,
	0xa8, 0x8f, 0xd3, 0x2b, 0xe5, 0xe5, 0x96, 0xa2, 0xc7, 0xb3, 0x17, 0xa3, 0x09, 0x53, 0xe8, 0xdf,
	0x58, 0x60, 0xab, 0x76, 0xd6, 0xfa, 0xfc, 0x6d, 0xdb, 0xee, 0x47, 0xb0, 0x74, 0x06, 0x95, 0x14,
	0x36, 0x68, 0xdd, 0xba, 0x88, 0x96, 0xb6, 0xe5, 0xd6, 0x66, 0x60, 0x29, 0xcb, 0x17, 0x90, 0x5e,
	0xf8, 0x9f, 0x91, 0x36, 0xa1, 0xfe, 0xc9, 0x82, 0xda, 0x1e, 0x16, 0x84, 0x8b, 0xdc, 0xe2, 0xe5,
	0x80, 0xac, 0xff, 0x27, 0xa0, 0x0f, 0xa1, 0x66, 0xf4, 0xbc, 0xd1, 0xa9, 0x20, 0xdc, 0xe0, 0x63,
	0x1b, 0xe6, 0x8e, 0xe4, 0xc9, 0xaf, 0x30, 0xc1, 0xa2, 0x30, 0x24, 0xec, 0xac, 0x55, 0x0b, 0x6e,
	0xd5, 0xf0, 0x54, 0x19, 0xef, 0xc0, 0x92, 0x2a, 0xb5, 0xfa, 0x1a, 0x9f, 0xd5, 0xba, 0xe0, 0xda,
	0x92, 0x2b, 0x9d, 0x49, 0x29, 0x9d, 0xc4, 0xf7, 0xfe, 0x6d, 0x01, 0xc8, 0x87, 0x35, 0x10, 0x58,
	0x4c, 0x38, 0xaa, 0x42, 0xe9, 0x70, 0xff, 0xd1, 0x7e, 0xff, 0xc9, 0x7e, 0x7d, 0x0e, 0xdd, 0x80,
	0x6a, 0xff, 0x91, 0x37, 0xec, 0x7b, 0xae, 0xb3, 0xd7, 0xfe, 0xac, 0x6e, 0xc9, 0xdb, 0xc1, 0x61,
	0xa7, 0xe3, 0x0c, 0x06, 0xf5, 0x79, 0x74, 0x13, 0x6a, 0x3b, 0xed, 0xae, 0xb7, 0xd7, 0xfb, 0xf4,
	0xb0, 0xd7, 0xed, 0x0d, 0x3f, 0xab, 0x2f, 0xa0, 0x3a, 0xd8, 0x92, 0x35, 0xd8, 0xeb, 0x1d, 0x1c,
	0xb4, 0x1f, 0x3a, 0xf5, 0x02, 0xaa, 0x41, 0x45, 0x72, 0x86, 0xfd, 0x47, 0xce, 0x7e, 0x7d, 0x11,
	0x2d, 0x43, 0xdd, 0x75, 0x76, 0x0f, 0xf7, 0xbb, 0x9e, 0xeb, 0x7c, 0x7a, 0xe8, 0x0c, 0x86, 0x4e,
	0xb7, 0x5e, 0x94, 0x7e, 0x0c, 0xb7, 0xdb, 0xdf, 0x77, 0xea, 0x25, 0xf4, 0x0e, 0xdc, 0x94, 0x5a,
	0x4f, 0x77, 0x1d, 0xd7, 0xeb, 0xf6, 0x06, 0xed, 0x9d, 0x3d, 0xa7, 0x5b, 0x2f, 0x23, 0x04, 0x4b,
	0x92, 0xdd, 0x75, 0x06, 0x43, 0xaf, 0xf3, 0x49, 0xbb, 0xb7, 0x5f, 0xaf, 0xa0, 0x15, 0x78, 0xc7,
	0x79, 0xda, 0x71, 0x9c, 0xae, 0xf7, 0xb8, 0xfd, 0xd4, 0xeb, 0x1f, 0x0e, 0xbd, 0xf6, 0xe3, 0xfe,
	0xe1, 0xfe, 0xb0, 0x0e, 0x32, 0x1a, 0x6d, 0x41, 0x46, 0xef, 0x74, 0xeb, 0x55, 0xe9, 0x48, 0x1a,
	0x68, 0x77, 0xbb, 0xae, 0xcc, 0xc1, 0xde, 0xe9, 0x7d, 0xf5, 0x6a, 0xcd, 0xfa, 0xfa, 0xd5, 0x9a,
	0xf5, 0xb7, 0x57, 0x6b, 0xd6, 0x2f, 0x5f, 0xaf, 0xcd, 0x7d, 0xfd, 0x7a, 0x6d, 0xee, 0x9b, 0xd7,
	0x6b, 0x73, 0x3f, 0x6d, 0xbd, 0xb9, 0x99, 0x48, 0x4c, 0xd8, 0xbd, 0x94, 0x88, 0x63, 0xca, 0x9e,
	0xb5, 0x78, 0x98, 0xde, 0x9b, 0x6e, 0xb7, 0x4e, 0x66, 0x7f, 0x66, 0xd5, 0x9a, 0x1a, 0x15, 0xd5,
	0xff, 0xa8, 0x1f, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xe3, 0x33, 0xd8, 0x84, 0xe8, 0x0e, 0x00,
	0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.SignAgainCoolDownDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.SignAgainCoolDownDuration):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintCbridge(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x12
	n2, err2 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.SignerUpdateDuration, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.SignerUpdateDuration):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintCbridge(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CbrConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbrConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbrConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Override) > 0 {
		for iNdEx := len(m.Override) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Override[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.CbrContracts) > 0 {
		for iNdEx := len(m.CbrContracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CbrContracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RelayGasCost) > 0 {
		for iNdEx := len(m.RelayGasCost) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RelayGasCost[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PickLpSize != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.PickLpSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ChainPairs) > 0 {
		for iNdEx := len(m.ChainPairs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChainPairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Assets) > 0 {
		for iNdEx := len(m.Assets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Assets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.LpFeePerc != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.LpFeePerc))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CbrPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbrPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbrPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GasPrice) > 0 {
		for iNdEx := len(m.GasPrice) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GasPrice[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AssetPrice) > 0 {
		for iNdEx := len(m.AssetPrice) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AssetPrice[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.UpdateEpoch != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.UpdateEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RelayGasCostParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayGasCostParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayGasCostParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PerSig != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.PerSig))
		i--
		dAtA[i] = 0x20
	}
	if m.PerValidator != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.PerValidator))
		i--
		dAtA[i] = 0x18
	}
	if m.CostBase != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.CostBase))
		i--
		dAtA[i] = 0x10
	}
	if m.ChainId != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AssetPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssetPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssetPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChainIds) > 0 {
		dAtA4 := make([]byte, len(m.ChainIds)*10)
		var j3 int
		for _, num := range m.ChainIds {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintCbridge(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GasPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Price) > 0 {
		i -= len(m.Price)
		copy(dAtA[i:], m.Price)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Price)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChainAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxOutAmt) > 0 {
		i -= len(m.MaxOutAmt)
		copy(dAtA[i:], m.MaxOutAmt)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.MaxOutAmt)))
		i--
		dAtA[i] = 0x3a
	}
	if m.XferDisabled {
		i--
		if m.XferDisabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.MaxFeeAmount) > 0 {
		i -= len(m.MaxFeeAmount)
		copy(dAtA[i:], m.MaxFeeAmount)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.MaxFeeAmount)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Decimal != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Decimal))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ChainId != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoCurve {
		i--
		if m.NoCurve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ConstA != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.ConstA))
		i--
		dAtA[i] = 0x30
	}
	if m.Fee2To1 != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Fee2To1))
		i--
		dAtA[i] = 0x28
	}
	if m.Fee1To2 != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Fee1To2))
		i--
		dAtA[i] = 0x20
	}
	if m.Weight1 != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Weight1))
		i--
		dAtA[i] = 0x18
	}
	if m.Chid2 != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Chid2))
		i--
		dAtA[i] = 0x10
	}
	if m.Chid1 != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Chid1))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PerChainPairAssetOverride) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerChainPairAssetOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerChainPairAssetOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Chpair != nil {
		{
			size, err := m.Chpair.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CbrProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CbrProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CbrProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Deposit.Size()
		i -= size
		if _, err := m.Deposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.CbrConfig != nil {
		{
			size, err := m.CbrConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCbridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OnChainEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnChainEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OnChainEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Elog) > 0 {
		i -= len(m.Elog)
		copy(dAtA[i:], m.Elog)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Elog)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Evtype) > 0 {
		i -= len(m.Evtype)
		copy(dAtA[i:], m.Evtype)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Evtype)))
		i--
		dAtA[i] = 0x12
	}
	if m.Chainid != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Chainid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RelayOnChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RelayOnChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RelayOnChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SrcTransferId) > 0 {
		i -= len(m.SrcTransferId)
		copy(dAtA[i:], m.SrcTransferId)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.SrcTransferId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DstChainId != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.DstChainId))
		i--
		dAtA[i] = 0x30
	}
	if m.SrcChainId != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.SrcChainId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawOnchain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawOnchain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawOnchain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Refid) > 0 {
		i -= len(m.Refid)
		copy(dAtA[i:], m.Refid)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Refid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Seqnum != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Seqnum))
		i--
		dAtA[i] = 0x10
	}
	if m.Chainid != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.Chainid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *XferRelay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *XferRelay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *XferRelay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseFee) > 0 {
		i -= len(m.BaseFee)
		copy(dAtA[i:], m.BaseFee)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.BaseFee)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PercFee) > 0 {
		i -= len(m.PercFee)
		copy(dAtA[i:], m.PercFee)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.PercFee)))
		i--
		dAtA[i] = 0x22
	}
	if m.LastReqTime != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.LastReqTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SortedSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Relay) > 0 {
		i -= len(m.Relay)
		copy(dAtA[i:], m.Relay)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Relay)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.XferId) > 0 {
		i -= len(m.XferId)
		copy(dAtA[i:], m.XferId)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.XferId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastReqTime != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.LastReqTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Completed {
		i--
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SortedSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.WdOnchain) > 0 {
		i -= len(m.WdOnchain)
		copy(dAtA[i:], m.WdOnchain)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.WdOnchain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddrSig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddrSig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddrSig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Signer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Power) > 0 {
		i -= len(m.Power)
		copy(dAtA[i:], m.Power)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Power)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainSigners) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainSigners) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainSigners) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SortedSigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SortedSigners) > 0 {
		for iNdEx := len(m.SortedSigners) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SortedSigners[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ChainId != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LatestSigners) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LatestSigners) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LatestSigners) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSignTime != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.LastSignTime))
		i--
		dAtA[i] = 0x20
	}
	if m.TriggerTime != 0 {
		i = encodeVarintCbridge(dAtA, i, uint64(m.TriggerTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SignersBytes) > 0 {
		i -= len(m.SignersBytes)
		copy(dAtA[i:], m.SignersBytes)
		i = encodeVarintCbridge(dAtA, i, uint64(len(m.SignersBytes)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SortedSigners) > 0 {
		for iNdEx := len(m.SortedSigners) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SortedSigners[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCbridge(dAtA []byte, offset int, v uint64) int {
	offset -= sovCbridge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.SignerUpdateDuration)
	n += 1 + l + sovCbridge(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.SignAgainCoolDownDuration)
	n += 1 + l + sovCbridge(uint64(l))
	return n
}

func (m *CbrConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LpFeePerc != 0 {
		n += 1 + sovCbridge(uint64(m.LpFeePerc))
	}
	if len(m.Assets) > 0 {
		for _, e := range m.Assets {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if len(m.ChainPairs) > 0 {
		for _, e := range m.ChainPairs {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if m.PickLpSize != 0 {
		n += 1 + sovCbridge(uint64(m.PickLpSize))
	}
	if len(m.RelayGasCost) > 0 {
		for _, e := range m.RelayGasCost {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if len(m.CbrContracts) > 0 {
		for _, e := range m.CbrContracts {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if len(m.Override) > 0 {
		for _, e := range m.Override {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	return n
}

func (m *CbrPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateEpoch != 0 {
		n += 1 + sovCbridge(uint64(m.UpdateEpoch))
	}
	if len(m.AssetPrice) > 0 {
		for _, e := range m.AssetPrice {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if len(m.GasPrice) > 0 {
		for _, e := range m.GasPrice {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	return n
}

func (m *RelayGasCostParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovCbridge(uint64(m.ChainId))
	}
	if m.CostBase != 0 {
		n += 1 + sovCbridge(uint64(m.CostBase))
	}
	if m.PerValidator != 0 {
		n += 1 + sovCbridge(uint64(m.PerValidator))
	}
	if m.PerSig != 0 {
		n += 1 + sovCbridge(uint64(m.PerSig))
	}
	return n
}

func (m *AssetPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if len(m.ChainIds) > 0 {
		l = 0
		for _, e := range m.ChainIds {
			l += sovCbridge(uint64(e))
		}
		n += 1 + sovCbridge(uint64(l)) + l
	}
	if m.Price != 0 {
		n += 1 + sovCbridge(uint64(m.Price))
	}
	return n
}

func (m *GasPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovCbridge(uint64(m.ChainId))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *ChainAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovCbridge(uint64(m.ChainId))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if m.Decimal != 0 {
		n += 1 + sovCbridge(uint64(m.Decimal))
	}
	l = len(m.MaxFeeAmount)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if m.XferDisabled {
		n += 2
	}
	l = len(m.MaxOutAmt)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *ChainPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chid1 != 0 {
		n += 1 + sovCbridge(uint64(m.Chid1))
	}
	if m.Chid2 != 0 {
		n += 1 + sovCbridge(uint64(m.Chid2))
	}
	if m.Weight1 != 0 {
		n += 1 + sovCbridge(uint64(m.Weight1))
	}
	if m.Fee1To2 != 0 {
		n += 1 + sovCbridge(uint64(m.Fee1To2))
	}
	if m.Fee2To1 != 0 {
		n += 1 + sovCbridge(uint64(m.Fee2To1))
	}
	if m.ConstA != 0 {
		n += 1 + sovCbridge(uint64(m.ConstA))
	}
	if m.NoCurve {
		n += 2
	}
	return n
}

func (m *PerChainPairAssetOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if m.Chpair != nil {
		l = m.Chpair.Size()
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *CbrProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if m.CbrConfig != nil {
		l = m.CbrConfig.Size()
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = m.Deposit.Size()
	n += 1 + l + sovCbridge(uint64(l))
	return n
}

func (m *OnChainEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chainid != 0 {
		n += 1 + sovCbridge(uint64(m.Chainid))
	}
	l = len(m.Evtype)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Elog)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *RelayOnChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if m.SrcChainId != 0 {
		n += 1 + sovCbridge(uint64(m.SrcChainId))
	}
	if m.DstChainId != 0 {
		n += 1 + sovCbridge(uint64(m.DstChainId))
	}
	l = len(m.SrcTransferId)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *WithdrawOnchain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chainid != 0 {
		n += 1 + sovCbridge(uint64(m.Chainid))
	}
	if m.Seqnum != 0 {
		n += 1 + sovCbridge(uint64(m.Seqnum))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Refid)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *XferRelay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Relay)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, e := range m.SortedSigs {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if m.LastReqTime != 0 {
		n += 1 + sovCbridge(uint64(m.LastReqTime))
	}
	l = len(m.PercFee)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.BaseFee)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *WithdrawDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WdOnchain)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, e := range m.SortedSigs {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if m.Completed {
		n += 2
	}
	if m.LastReqTime != 0 {
		n += 1 + sovCbridge(uint64(m.LastReqTime))
	}
	l = len(m.XferId)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *AddrSig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *Signer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	l = len(m.Power)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	return n
}

func (m *ChainSigners) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovCbridge(uint64(m.ChainId))
	}
	if len(m.SortedSigners) > 0 {
		for _, e := range m.SortedSigners {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	if len(m.SortedSigs) > 0 {
		for _, e := range m.SortedSigs {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	return n
}

func (m *LatestSigners) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SortedSigners) > 0 {
		for _, e := range m.SortedSigners {
			l = e.Size()
			n += 1 + l + sovCbridge(uint64(l))
		}
	}
	l = len(m.SignersBytes)
	if l > 0 {
		n += 1 + l + sovCbridge(uint64(l))
	}
	if m.TriggerTime != 0 {
		n += 1 + sovCbridge(uint64(m.TriggerTime))
	}
	if m.LastSignTime != 0 {
		n += 1 + sovCbridge(uint64(m.LastSignTime))
	}
	return n
}

func sovCbridge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCbridge(x uint64) (n int) {
	return sovCbridge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerUpdateDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.SignerUpdateDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignAgainCoolDownDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.SignAgainCoolDownDuration, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbrConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbrConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbrConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpFeePerc", wireType)
			}
			m.LpFeePerc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LpFeePerc |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, &ChainAsset{})
			if err := m.Assets[len(m.Assets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainPairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainPairs = append(m.ChainPairs, &ChainPair{})
			if err := m.ChainPairs[len(m.ChainPairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickLpSize", wireType)
			}
			m.PickLpSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PickLpSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayGasCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayGasCost = append(m.RelayGasCost, &RelayGasCostParam{})
			if err := m.RelayGasCost[len(m.RelayGasCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbrContracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CbrContracts = append(m.CbrContracts, &types.ContractInfo{})
			if err := m.CbrContracts[len(m.CbrContracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Override", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Override = append(m.Override, &PerChainPairAssetOverride{})
			if err := m.Override[len(m.Override)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbrPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbrPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbrPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateEpoch", wireType)
			}
			m.UpdateEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetPrice = append(m.AssetPrice, &AssetPrice{})
			if err := m.AssetPrice[len(m.AssetPrice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = append(m.GasPrice, &GasPrice{})
			if err := m.GasPrice[len(m.GasPrice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayGasCostParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayGasCostParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayGasCostParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CostBase", wireType)
			}
			m.CostBase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CostBase |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerValidator", wireType)
			}
			m.PerValidator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerValidator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerSig", wireType)
			}
			m.PerSig = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerSig |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssetPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssetPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssetPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCbridge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChainIds = append(m.ChainIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCbridge
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCbridge
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCbridge
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChainIds) == 0 {
					m.ChainIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCbridge
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChainIds = append(m.ChainIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimal", wireType)
			}
			m.Decimal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimal |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFeeAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxFeeAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XferDisabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XferDisabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxOutAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxOutAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chid1", wireType)
			}
			m.Chid1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chid1 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chid2", wireType)
			}
			m.Chid2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chid2 |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight1", wireType)
			}
			m.Weight1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee1To2", wireType)
			}
			m.Fee1To2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee1To2 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee2To1", wireType)
			}
			m.Fee2To1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee2To1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstA", wireType)
			}
			m.ConstA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstA |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCurve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCurve = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerChainPairAssetOverride) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerChainPairAssetOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerChainPairAssetOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chpair", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chpair == nil {
				m.Chpair = &ChainPair{}
			}
			if err := m.Chpair.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CbrProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CbrProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CbrProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CbrConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CbrConfig == nil {
				m.CbrConfig = &CbrConfig{}
			}
			if err := m.CbrConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnChainEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnChainEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnChainEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chainid", wireType)
			}
			m.Chainid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chainid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evtype", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evtype = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elog", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elog = append(m.Elog[:0], dAtA[iNdEx:postIndex]...)
			if m.Elog == nil {
				m.Elog = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RelayOnChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelayOnChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelayOnChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = append(m.Receiver[:0], dAtA[iNdEx:postIndex]...)
			if m.Receiver == nil {
				m.Receiver = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token[:0], dAtA[iNdEx:postIndex]...)
			if m.Token == nil {
				m.Token = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount[:0], dAtA[iNdEx:postIndex]...)
			if m.Amount == nil {
				m.Amount = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcChainId", wireType)
			}
			m.SrcChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstChainId", wireType)
			}
			m.DstChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTransferId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcTransferId = append(m.SrcTransferId[:0], dAtA[iNdEx:postIndex]...)
			if m.SrcTransferId == nil {
				m.SrcTransferId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawOnchain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawOnchain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawOnchain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chainid", wireType)
			}
			m.Chainid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chainid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqnum", wireType)
			}
			m.Seqnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seqnum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = append(m.Receiver[:0], dAtA[iNdEx:postIndex]...)
			if m.Receiver == nil {
				m.Receiver = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token[:0], dAtA[iNdEx:postIndex]...)
			if m.Token == nil {
				m.Token = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount[:0], dAtA[iNdEx:postIndex]...)
			if m.Amount == nil {
				m.Amount = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refid = append(m.Refid[:0], dAtA[iNdEx:postIndex]...)
			if m.Refid == nil {
				m.Refid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *XferRelay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: XferRelay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: XferRelay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relay", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relay = append(m.Relay[:0], dAtA[iNdEx:postIndex]...)
			if m.Relay == nil {
				m.Relay = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, &AddrSig{})
			if err := m.SortedSigs[len(m.SortedSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReqTime", wireType)
			}
			m.LastReqTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReqTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercFee", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercFee = append(m.PercFee[:0], dAtA[iNdEx:postIndex]...)
			if m.PercFee == nil {
				m.PercFee = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFee", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseFee = append(m.BaseFee[:0], dAtA[iNdEx:postIndex]...)
			if m.BaseFee == nil {
				m.BaseFee = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdOnchain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WdOnchain = append(m.WdOnchain[:0], dAtA[iNdEx:postIndex]...)
			if m.WdOnchain == nil {
				m.WdOnchain = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, &AddrSig{})
			if err := m.SortedSigs[len(m.SortedSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReqTime", wireType)
			}
			m.LastReqTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReqTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XferId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.XferId = append(m.XferId[:0], dAtA[iNdEx:postIndex]...)
			if m.XferId == nil {
				m.XferId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddrSig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddrSig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddrSig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = append(m.Addr[:0], dAtA[iNdEx:postIndex]...)
			if m.Addr == nil {
				m.Addr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Power = append(m.Power[:0], dAtA[iNdEx:postIndex]...)
			if m.Power == nil {
				m.Power = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainSigners) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainSigners: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainSigners: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigners", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigners = append(m.SortedSigners, &Signer{})
			if err := m.SortedSigners[len(m.SortedSigners)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, &AddrSig{})
			if err := m.SortedSigs[len(m.SortedSigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LatestSigners) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LatestSigners: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LatestSigners: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigners", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigners = append(m.SortedSigners, &Signer{})
			if err := m.SortedSigners[len(m.SortedSigners)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignersBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignersBytes = append(m.SignersBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.SignersBytes == nil {
				m.SignersBytes = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerTime", wireType)
			}
			m.TriggerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSignTime", wireType)
			}
			m.LastSignTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSignTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCbridge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCbridge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCbridge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCbridge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCbridge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCbridge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCbridge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCbridge = fmt.Errorf("proto: unexpected end of group")
)
