// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/farming/v1/farming.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the set of params for the farming module.
type Params struct {
	// claim_cooldown defines the minimal time between two reward claim requests
	ClaimCooldown time.Duration `protobuf:"bytes,1,opt,name=claim_cooldown,json=claimCooldown,proto3,stdduration" json:"claim_cooldown,omitempty" yaml:"claim_cooldown"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetClaimCooldown() time.Duration {
	if m != nil {
		return m.ClaimCooldown
	}
	return 0
}

// ERC20Token describes an ERC20 token on a specific EVM-compatible chain
type ERC20Token struct {
	// chain_id defines the EVM chain ID
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty" yaml:"chain_id"`
	// symbol defines the ERC20 token symbol
	Symbol string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
	// address defines the token contract address
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
	// decimals defines the token decimals
	Decimals uint32 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty" yaml:"decimals"`
}

func (m *ERC20Token) Reset()         { *m = ERC20Token{} }
func (m *ERC20Token) String() string { return proto.CompactTextString(m) }
func (*ERC20Token) ProtoMessage()    {}
func (*ERC20Token) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{1}
}
func (m *ERC20Token) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERC20Token) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERC20Token.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERC20Token) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERC20Token.Merge(m, src)
}
func (m *ERC20Token) XXX_Size() int {
	return m.Size()
}
func (m *ERC20Token) XXX_DiscardUnknown() {
	xxx_messageInfo_ERC20Token.DiscardUnknown(m)
}

var xxx_messageInfo_ERC20Token proto.InternalMessageInfo

func (m *ERC20Token) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *ERC20Token) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *ERC20Token) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ERC20Token) GetDecimals() uint32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

// FarmingPool represents a pool that rewards liquidity providers with tokens
type FarmingPool struct {
	// name defines the name of the farming pool
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// stake_token defines the accepted token as stake
	StakeToken ERC20Token `protobuf:"bytes,2,opt,name=stake_token,json=stakeToken,proto3" json:"stake_token" yaml:"stake_token"`
	// reward_tokens defines the provided reward tokens
	RewardTokens []ERC20Token `protobuf:"bytes,3,rep,name=reward_tokens,json=rewardTokens,proto3" json:"reward_tokens" yaml:"reward_tokens"`
	// total_staked_amount defines the total staked amount
	TotalStakedAmount types.DecCoin `protobuf:"bytes,4,opt,name=total_staked_amount,json=totalStakedAmount,proto3" json:"total_staked_amount" yaml:"total_staked_amount"`
	// reward_token_infos defines the details for each reward token
	RewardTokenInfos []RewardTokenInfo `protobuf:"bytes,5,rep,name=reward_token_infos,json=rewardTokenInfos,proto3" json:"reward_token_infos" yaml:"reward_token_infos"`
	// total_accumulated_rewards defines the total accumulated rewards
	TotalAccumulatedRewards github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,6,rep,name=total_accumulated_rewards,json=totalAccumulatedRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"total_accumulated_rewards" yaml:"total_accumulated_rewards"`
}

func (m *FarmingPool) Reset()         { *m = FarmingPool{} }
func (m *FarmingPool) String() string { return proto.CompactTextString(m) }
func (*FarmingPool) ProtoMessage()    {}
func (*FarmingPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{2}
}
func (m *FarmingPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FarmingPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FarmingPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FarmingPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FarmingPool.Merge(m, src)
}
func (m *FarmingPool) XXX_Size() int {
	return m.Size()
}
func (m *FarmingPool) XXX_DiscardUnknown() {
	xxx_messageInfo_FarmingPool.DiscardUnknown(m)
}

var xxx_messageInfo_FarmingPool proto.InternalMessageInfo

func (m *FarmingPool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FarmingPool) GetStakeToken() ERC20Token {
	if m != nil {
		return m.StakeToken
	}
	return ERC20Token{}
}

func (m *FarmingPool) GetRewardTokens() []ERC20Token {
	if m != nil {
		return m.RewardTokens
	}
	return nil
}

func (m *FarmingPool) GetTotalStakedAmount() types.DecCoin {
	if m != nil {
		return m.TotalStakedAmount
	}
	return types.DecCoin{}
}

func (m *FarmingPool) GetRewardTokenInfos() []RewardTokenInfo {
	if m != nil {
		return m.RewardTokenInfos
	}
	return nil
}

func (m *FarmingPool) GetTotalAccumulatedRewards() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.TotalAccumulatedRewards
	}
	return nil
}

// NumPools is a wrapper of uint to display by CLI query
type NumPools struct {
	NumPools uint64 `protobuf:"varint,1,opt,name=num_pools,json=numPools,proto3" json:"num_pools,omitempty"`
}

func (m *NumPools) Reset()         { *m = NumPools{} }
func (m *NumPools) String() string { return proto.CompactTextString(m) }
func (*NumPools) ProtoMessage()    {}
func (*NumPools) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{3}
}
func (m *NumPools) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumPools) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumPools.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumPools) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumPools.Merge(m, src)
}
func (m *NumPools) XXX_Size() int {
	return m.Size()
}
func (m *NumPools) XXX_DiscardUnknown() {
	xxx_messageInfo_NumPools.DiscardUnknown(m)
}

var xxx_messageInfo_NumPools proto.InternalMessageInfo

func (m *NumPools) GetNumPools() uint64 {
	if m != nil {
		return m.NumPools
	}
	return 0
}

// RewardTokenInfo describes the status of a reward token in a pool
type RewardTokenInfo struct {
	RemainingAmount        types.DecCoin                          `protobuf:"bytes,1,opt,name=remaining_amount,json=remainingAmount,proto3" json:"remaining_amount" yaml:"remaining_amount"`
	RewardStartBlockHeight int64                                  `protobuf:"varint,2,opt,name=reward_start_block_height,json=rewardStartBlockHeight,proto3" json:"reward_start_block_height,omitempty" yaml:"reward_start_block_height"`
	RewardAmountPerBlock   github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=reward_amount_per_block,json=rewardAmountPerBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"reward_amount_per_block" yaml:"reward_amount_per_block"`
}

func (m *RewardTokenInfo) Reset()         { *m = RewardTokenInfo{} }
func (m *RewardTokenInfo) String() string { return proto.CompactTextString(m) }
func (*RewardTokenInfo) ProtoMessage()    {}
func (*RewardTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{4}
}
func (m *RewardTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardTokenInfo.Merge(m, src)
}
func (m *RewardTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *RewardTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RewardTokenInfo proto.InternalMessageInfo

func (m *RewardTokenInfo) GetRemainingAmount() types.DecCoin {
	if m != nil {
		return m.RemainingAmount
	}
	return types.DecCoin{}
}

func (m *RewardTokenInfo) GetRewardStartBlockHeight() int64 {
	if m != nil {
		return m.RewardStartBlockHeight
	}
	return 0
}

// StakeInfo describes the stake of a liquidity provider in a pool
type StakeInfo struct {
	StakerAddress    string        `protobuf:"bytes,1,opt,name=staker_address,json=stakerAddress,proto3" json:"staker_address,omitempty" yaml:"staker_address"`
	PoolName         string        `protobuf:"bytes,2,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	Amount           types.DecCoin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
	StartBlockHeight int64         `protobuf:"varint,4,opt,name=start_block_height,json=startBlockHeight,proto3" json:"start_block_height,omitempty" yaml:"start_block_height"`
	ReferencePeriod  uint64        `protobuf:"varint,5,opt,name=reference_period,json=referencePeriod,proto3" json:"reference_period,omitempty" yaml:"reference_period"`
}

func (m *StakeInfo) Reset()         { *m = StakeInfo{} }
func (m *StakeInfo) String() string { return proto.CompactTextString(m) }
func (*StakeInfo) ProtoMessage()    {}
func (*StakeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{5}
}
func (m *StakeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakeInfo.Merge(m, src)
}
func (m *StakeInfo) XXX_Size() int {
	return m.Size()
}
func (m *StakeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StakeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StakeInfo proto.InternalMessageInfo

func (m *StakeInfo) GetStakerAddress() string {
	if m != nil {
		return m.StakerAddress
	}
	return ""
}

func (m *StakeInfo) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *StakeInfo) GetAmount() types.DecCoin {
	if m != nil {
		return m.Amount
	}
	return types.DecCoin{}
}

func (m *StakeInfo) GetStartBlockHeight() int64 {
	if m != nil {
		return m.StartBlockHeight
	}
	return 0
}

func (m *StakeInfo) GetReferencePeriod() uint64 {
	if m != nil {
		return m.ReferencePeriod
	}
	return 0
}

// PoolHistoricalRewards records the reward ratio of one liquidity provider account in a pool
type PoolHistoricalRewards struct {
	CumulativeRewardRatio github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=cumulative_reward_ratio,json=cumulativeRewardRatio,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"cumulative_reward_ratio" yaml:"cumulative_reward_ratio"`
	ReferenceCount        uint32                                      `protobuf:"varint,2,opt,name=reference_count,json=referenceCount,proto3" json:"reference_count,omitempty" yaml:"reference_count"`
}

func (m *PoolHistoricalRewards) Reset()         { *m = PoolHistoricalRewards{} }
func (m *PoolHistoricalRewards) String() string { return proto.CompactTextString(m) }
func (*PoolHistoricalRewards) ProtoMessage()    {}
func (*PoolHistoricalRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{6}
}
func (m *PoolHistoricalRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolHistoricalRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolHistoricalRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolHistoricalRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolHistoricalRewards.Merge(m, src)
}
func (m *PoolHistoricalRewards) XXX_Size() int {
	return m.Size()
}
func (m *PoolHistoricalRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolHistoricalRewards.DiscardUnknown(m)
}

var xxx_messageInfo_PoolHistoricalRewards proto.InternalMessageInfo

func (m *PoolHistoricalRewards) GetCumulativeRewardRatio() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.CumulativeRewardRatio
	}
	return nil
}

func (m *PoolHistoricalRewards) GetReferenceCount() uint32 {
	if m != nil {
		return m.ReferenceCount
	}
	return 0
}

// PoolCurrentRewards records the rewards in the current period
type PoolCurrentRewards struct {
	StartBlockHeight int64                                       `protobuf:"varint,1,opt,name=start_block_height,json=startBlockHeight,proto3" json:"start_block_height,omitempty" yaml:"start_block_height"`
	Period           uint64                                      `protobuf:"varint,2,opt,name=period,proto3" json:"period,omitempty" yaml:"period"`
	Rewards          github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,3,rep,name=rewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"rewards" yaml:"rewards"`
}

func (m *PoolCurrentRewards) Reset()         { *m = PoolCurrentRewards{} }
func (m *PoolCurrentRewards) String() string { return proto.CompactTextString(m) }
func (*PoolCurrentRewards) ProtoMessage()    {}
func (*PoolCurrentRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{7}
}
func (m *PoolCurrentRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolCurrentRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolCurrentRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolCurrentRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolCurrentRewards.Merge(m, src)
}
func (m *PoolCurrentRewards) XXX_Size() int {
	return m.Size()
}
func (m *PoolCurrentRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolCurrentRewards.DiscardUnknown(m)
}

var xxx_messageInfo_PoolCurrentRewards proto.InternalMessageInfo

func (m *PoolCurrentRewards) GetStartBlockHeight() int64 {
	if m != nil {
		return m.StartBlockHeight
	}
	return 0
}

func (m *PoolCurrentRewards) GetPeriod() uint64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *PoolCurrentRewards) GetRewards() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.Rewards
	}
	return nil
}

// Earnings is the structure for an earnings query for one liquidity provider account in a pool
type Earnings struct {
	TargetBlockHeight int64                                       `protobuf:"varint,1,opt,name=target_block_height,json=targetBlockHeight,proto3" json:"target_block_height,omitempty" yaml:"target_block_height"`
	StakedAmount      types.DecCoin                               `protobuf:"bytes,2,opt,name=staked_amount,json=stakedAmount,proto3" json:"staked_amount" yaml:"staked_amount"`
	RewardAmounts     github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,3,rep,name=reward_amounts,json=rewardAmounts,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"reward_amounts" yaml:"reward_amounts"`
}

func (m *Earnings) Reset()         { *m = Earnings{} }
func (m *Earnings) String() string { return proto.CompactTextString(m) }
func (*Earnings) ProtoMessage()    {}
func (*Earnings) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{8}
}
func (m *Earnings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Earnings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Earnings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Earnings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Earnings.Merge(m, src)
}
func (m *Earnings) XXX_Size() int {
	return m.Size()
}
func (m *Earnings) XXX_DiscardUnknown() {
	xxx_messageInfo_Earnings.DiscardUnknown(m)
}

var xxx_messageInfo_Earnings proto.InternalMessageInfo

func (m *Earnings) GetTargetBlockHeight() int64 {
	if m != nil {
		return m.TargetBlockHeight
	}
	return 0
}

func (m *Earnings) GetStakedAmount() types.DecCoin {
	if m != nil {
		return m.StakedAmount
	}
	return types.DecCoin{}
}

func (m *Earnings) GetRewardAmounts() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.RewardAmounts
	}
	return nil
}

// AccountInfo records the current state of a farming account.
type AccountInfo struct {
	// staked_pools defines the farming pools that the account has stakes in.
	StakedPools []FarmingPool `protobuf:"bytes,1,rep,name=staked_pools,json=stakedPools,proto3" json:"staked_pools"`
	// earnings_list defines the earnings info from all the staked pools.
	EarningsList []Earnings `protobuf:"bytes,2,rep,name=earnings_list,json=earningsList,proto3" json:"earnings_list"`
	// cumulative_rewards defines the cumulative rewards.
	CumulativeRewards github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,3,rep,name=cumulative_rewards,json=cumulativeRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"cumulative_rewards" yaml:"cumulative_rewards"`
}

func (m *AccountInfo) Reset()         { *m = AccountInfo{} }
func (m *AccountInfo) String() string { return proto.CompactTextString(m) }
func (*AccountInfo) ProtoMessage()    {}
func (*AccountInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{9}
}
func (m *AccountInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountInfo.Merge(m, src)
}
func (m *AccountInfo) XXX_Size() int {
	return m.Size()
}
func (m *AccountInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AccountInfo proto.InternalMessageInfo

func (m *AccountInfo) GetStakedPools() []FarmingPool {
	if m != nil {
		return m.StakedPools
	}
	return nil
}

func (m *AccountInfo) GetEarningsList() []Earnings {
	if m != nil {
		return m.EarningsList
	}
	return nil
}

func (m *AccountInfo) GetCumulativeRewards() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.CumulativeRewards
	}
	return nil
}

// Signature is the structure representing an Ethereum ECDSA signature.
type Signature struct {
	// signer defines the Ethereum address of the signer.
	Signer string `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty" yaml:"signer"`
	// sig_bytes defines the signature bytes.
	SigBytes []byte `protobuf:"bytes,2,opt,name=sig_bytes,json=sigBytes,proto3" json:"sig_bytes,omitempty" yaml:"sig_bytes"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{10}
}
func (m *Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return m.Size()
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *Signature) GetSigBytes() []byte {
	if m != nil {
		return m.SigBytes
	}
	return nil
}

// RewardClaimDetails describes the reward to be claimed on the EVM chain.
type RewardClaimDetails struct {
	// chain_id defines the EVM chain ID for the claim.
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// reward_amount defines the cumulative reward tokens claimed.
	CumulativeRewardAmounts github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,2,rep,name=cumulative_reward_amounts,json=cumulativeRewardAmounts,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"cumulative_reward_amounts" yaml:"cumulative_reward_amounts"`
	// reward_proto_bytes defines the serialized reward protobuf to be submitted on the EVM chain.
	RewardProtoBytes []byte `protobuf:"bytes,3,opt,name=reward_proto_bytes,json=rewardProtoBytes,proto3" json:"reward_proto_bytes,omitempty" yaml:"reward_proto_bytes"`
	// signatures defines the signatures to be verified on the EVM chain.
	Signatures []Signature `protobuf:"bytes,4,rep,name=signatures,proto3" json:"signatures" yaml:"signatures"`
}

func (m *RewardClaimDetails) Reset()         { *m = RewardClaimDetails{} }
func (m *RewardClaimDetails) String() string { return proto.CompactTextString(m) }
func (*RewardClaimDetails) ProtoMessage()    {}
func (*RewardClaimDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{11}
}
func (m *RewardClaimDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardClaimDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardClaimDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardClaimDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardClaimDetails.Merge(m, src)
}
func (m *RewardClaimDetails) XXX_Size() int {
	return m.Size()
}
func (m *RewardClaimDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardClaimDetails.DiscardUnknown(m)
}

var xxx_messageInfo_RewardClaimDetails proto.InternalMessageInfo

func (m *RewardClaimDetails) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *RewardClaimDetails) GetCumulativeRewardAmounts() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.CumulativeRewardAmounts
	}
	return nil
}

func (m *RewardClaimDetails) GetRewardProtoBytes() []byte {
	if m != nil {
		return m.RewardProtoBytes
	}
	return nil
}

func (m *RewardClaimDetails) GetSignatures() []Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// RewardClaimInfo describes the reward claim metadata and details for a recipient.
type RewardClaimInfo struct {
	// recipient defines the Ethereum address of the reward recipient.
	Recipient string `protobuf:"bytes,1,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// last_claim_time defines the last time a reward claim was signed by the validators.
	LastClaimTime time.Time `protobuf:"bytes,2,opt,name=last_claim_time,json=lastClaimTime,proto3,stdtime" json:"last_claim_time" yaml:"last_claim_time"`
	// reward_claim_details_list defines the list of reward claim details
	RewardClaimDetailsList []RewardClaimDetails `protobuf:"bytes,3,rep,name=reward_claim_details_list,json=rewardClaimDetailsList,proto3" json:"reward_claim_details_list" yaml:"reward_claim_details_list"`
}

func (m *RewardClaimInfo) Reset()         { *m = RewardClaimInfo{} }
func (m *RewardClaimInfo) String() string { return proto.CompactTextString(m) }
func (*RewardClaimInfo) ProtoMessage()    {}
func (*RewardClaimInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{12}
}
func (m *RewardClaimInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardClaimInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardClaimInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardClaimInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardClaimInfo.Merge(m, src)
}
func (m *RewardClaimInfo) XXX_Size() int {
	return m.Size()
}
func (m *RewardClaimInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardClaimInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RewardClaimInfo proto.InternalMessageInfo

func (m *RewardClaimInfo) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *RewardClaimInfo) GetLastClaimTime() time.Time {
	if m != nil {
		return m.LastClaimTime
	}
	return time.Time{}
}

func (m *RewardClaimInfo) GetRewardClaimDetailsList() []RewardClaimDetails {
	if m != nil {
		return m.RewardClaimDetailsList
	}
	return nil
}

// RewardAdjustmentInput describes the input to add / adjust a reward token in a pool
type RewardAdjustmentInput struct {
	AddAmount               types.DecCoin                          `protobuf:"bytes,1,opt,name=add_amount,json=addAmount,proto3" json:"add_amount" yaml:"add_amount"`
	RewardStartBlockDelay   int64                                  `protobuf:"varint,2,opt,name=reward_start_block_delay,json=rewardStartBlockDelay,proto3" json:"reward_start_block_delay,omitempty" yaml:"reward_start_block_delay"`
	NewRewardAmountPerBlock github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=new_reward_amount_per_block,json=newRewardAmountPerBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"new_reward_amount_per_block" yaml:"new_reward_amount_per_block"`
}

func (m *RewardAdjustmentInput) Reset()         { *m = RewardAdjustmentInput{} }
func (m *RewardAdjustmentInput) String() string { return proto.CompactTextString(m) }
func (*RewardAdjustmentInput) ProtoMessage()    {}
func (*RewardAdjustmentInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{13}
}
func (m *RewardAdjustmentInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardAdjustmentInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardAdjustmentInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardAdjustmentInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardAdjustmentInput.Merge(m, src)
}
func (m *RewardAdjustmentInput) XXX_Size() int {
	return m.Size()
}
func (m *RewardAdjustmentInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardAdjustmentInput.DiscardUnknown(m)
}

var xxx_messageInfo_RewardAdjustmentInput proto.InternalMessageInfo

func (m *RewardAdjustmentInput) GetAddAmount() types.DecCoin {
	if m != nil {
		return m.AddAmount
	}
	return types.DecCoin{}
}

func (m *RewardAdjustmentInput) GetRewardStartBlockDelay() int64 {
	if m != nil {
		return m.RewardStartBlockDelay
	}
	return 0
}

// AddPoolProposal details a proposal to add a farming pool. If passed, it automatically registers
// the stake and reward tokens involved.
type AddPoolProposal struct {
	Title               string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description         string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName            string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	StakeToken          ERC20Token              `protobuf:"bytes,4,opt,name=stake_token,json=stakeToken,proto3" json:"stake_token" yaml:"stake_token"`
	RewardTokens        []ERC20Token            `protobuf:"bytes,5,rep,name=reward_tokens,json=rewardTokens,proto3" json:"reward_tokens" yaml:"reward_tokens"`
	InitialRewardInputs []RewardAdjustmentInput `protobuf:"bytes,6,rep,name=initial_reward_inputs,json=initialRewardInputs,proto3" json:"initial_reward_inputs" yaml:"initial_reward_inputs"`
}

func (m *AddPoolProposal) Reset()      { *m = AddPoolProposal{} }
func (*AddPoolProposal) ProtoMessage() {}
func (*AddPoolProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{14}
}
func (m *AddPoolProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPoolProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPoolProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPoolProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPoolProposal.Merge(m, src)
}
func (m *AddPoolProposal) XXX_Size() int {
	return m.Size()
}
func (m *AddPoolProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPoolProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AddPoolProposal proto.InternalMessageInfo

// AddPoolProposalWithDeposit defines an AddPoolProposal with a deposit, for CLI usage.
type AddPoolProposalWithDeposit struct {
	Title               string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description         string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName            string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	StakeToken          ERC20Token              `protobuf:"bytes,4,opt,name=stake_token,json=stakeToken,proto3" json:"stake_token,omitempty" yaml:"stake_token"`
	RewardTokens        []ERC20Token            `protobuf:"bytes,5,rep,name=reward_tokens,json=rewardTokens,proto3" json:"reward_tokens,omitempty" yaml:"reward_tokens"`
	InitialRewardInputs []RewardAdjustmentInput `protobuf:"bytes,6,rep,name=initial_reward_inputs,json=initialRewardInputs,proto3" json:"initial_reward_inputs,omitempty" yaml:"initial_reward_inputs"`
	Deposit             string                  `protobuf:"bytes,7,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *AddPoolProposalWithDeposit) Reset()         { *m = AddPoolProposalWithDeposit{} }
func (m *AddPoolProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*AddPoolProposalWithDeposit) ProtoMessage()    {}
func (*AddPoolProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{15}
}
func (m *AddPoolProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPoolProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPoolProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPoolProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPoolProposalWithDeposit.Merge(m, src)
}
func (m *AddPoolProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *AddPoolProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPoolProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_AddPoolProposalWithDeposit proto.InternalMessageInfo

// AdjustRewardProposal details a proposal to adjust reward tokens in a pool.
type AdjustRewardProposal struct {
	Title                  string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description            string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName               string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	RewardAdjustmentInputs []RewardAdjustmentInput `protobuf:"bytes,4,rep,name=reward_adjustment_inputs,json=rewardAdjustmentInputs,proto3" json:"reward_adjustment_inputs" yaml:"reward_adjustment_inputs"`
}

func (m *AdjustRewardProposal) Reset()      { *m = AdjustRewardProposal{} }
func (*AdjustRewardProposal) ProtoMessage() {}
func (*AdjustRewardProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{16}
}
func (m *AdjustRewardProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdjustRewardProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdjustRewardProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdjustRewardProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustRewardProposal.Merge(m, src)
}
func (m *AdjustRewardProposal) XXX_Size() int {
	return m.Size()
}
func (m *AdjustRewardProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustRewardProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustRewardProposal proto.InternalMessageInfo

// AdjustRewardProposalWithDeposit defines an AdjustRewardProposal with a deposit, for CLI usage.
type AdjustRewardProposalWithDeposit struct {
	Title                  string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description            string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName               string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	RewardAdjustmentInputs []RewardAdjustmentInput `protobuf:"bytes,4,rep,name=reward_adjustment_inputs,json=rewardAdjustmentInputs,proto3" json:"reward_adjustment_inputs" yaml:"reward_adjustment_inputs"`
	Deposit                string                  `protobuf:"bytes,5,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *AdjustRewardProposalWithDeposit) Reset()         { *m = AdjustRewardProposalWithDeposit{} }
func (m *AdjustRewardProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*AdjustRewardProposalWithDeposit) ProtoMessage()    {}
func (*AdjustRewardProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{17}
}
func (m *AdjustRewardProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdjustRewardProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdjustRewardProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdjustRewardProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustRewardProposalWithDeposit.Merge(m, src)
}
func (m *AdjustRewardProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *AdjustRewardProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustRewardProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustRewardProposalWithDeposit proto.InternalMessageInfo

// RemovePoolProposal details a proposal to remove a finished farming pool.
type RemovePoolProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName    string `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
}

func (m *RemovePoolProposal) Reset()      { *m = RemovePoolProposal{} }
func (*RemovePoolProposal) ProtoMessage() {}
func (*RemovePoolProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{18}
}
func (m *RemovePoolProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemovePoolProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePoolProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemovePoolProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePoolProposal.Merge(m, src)
}
func (m *RemovePoolProposal) XXX_Size() int {
	return m.Size()
}
func (m *RemovePoolProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePoolProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePoolProposal proto.InternalMessageInfo

// RemovePoolProposalWithDeposit defines a RemovePoolProposal with a deposit, for CLI usage.
type RemovePoolProposalWithDeposit struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName    string `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	Deposit     string `protobuf:"bytes,4,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *RemovePoolProposalWithDeposit) Reset()         { *m = RemovePoolProposalWithDeposit{} }
func (m *RemovePoolProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*RemovePoolProposalWithDeposit) ProtoMessage()    {}
func (*RemovePoolProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{19}
}
func (m *RemovePoolProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemovePoolProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePoolProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemovePoolProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePoolProposalWithDeposit.Merge(m, src)
}
func (m *RemovePoolProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *RemovePoolProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePoolProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePoolProposalWithDeposit proto.InternalMessageInfo

// AddTokensProposal details a proposal to add new ERC20 tokens.
type AddTokensProposal struct {
	Title       string       `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	Tokens      []ERC20Token `protobuf:"bytes,3,rep,name=tokens,proto3" json:"tokens" yaml:"tokens"`
}

func (m *AddTokensProposal) Reset()      { *m = AddTokensProposal{} }
func (*AddTokensProposal) ProtoMessage() {}
func (*AddTokensProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{20}
}
func (m *AddTokensProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTokensProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTokensProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTokensProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTokensProposal.Merge(m, src)
}
func (m *AddTokensProposal) XXX_Size() int {
	return m.Size()
}
func (m *AddTokensProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTokensProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AddTokensProposal proto.InternalMessageInfo

// AddTokensProposalWithDeposit defines a AddTokensProposal with a deposit, for CLI usage.
type AddTokensProposalWithDeposit struct {
	Title       string       `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	Tokens      []ERC20Token `protobuf:"bytes,3,rep,name=tokens,proto3" json:"tokens" yaml:"tokens"`
	Deposit     string       `protobuf:"bytes,4,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *AddTokensProposalWithDeposit) Reset()         { *m = AddTokensProposalWithDeposit{} }
func (m *AddTokensProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*AddTokensProposalWithDeposit) ProtoMessage()    {}
func (*AddTokensProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{21}
}
func (m *AddTokensProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTokensProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTokensProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTokensProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTokensProposalWithDeposit.Merge(m, src)
}
func (m *AddTokensProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *AddTokensProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTokensProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_AddTokensProposalWithDeposit proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Params)(nil), "sgn.farming.v1.Params")
	proto.RegisterType((*ERC20Token)(nil), "sgn.farming.v1.ERC20Token")
	proto.RegisterType((*FarmingPool)(nil), "sgn.farming.v1.FarmingPool")
	proto.RegisterType((*NumPools)(nil), "sgn.farming.v1.NumPools")
	proto.RegisterType((*RewardTokenInfo)(nil), "sgn.farming.v1.RewardTokenInfo")
	proto.RegisterType((*StakeInfo)(nil), "sgn.farming.v1.StakeInfo")
	proto.RegisterType((*PoolHistoricalRewards)(nil), "sgn.farming.v1.PoolHistoricalRewards")
	proto.RegisterType((*PoolCurrentRewards)(nil), "sgn.farming.v1.PoolCurrentRewards")
	proto.RegisterType((*Earnings)(nil), "sgn.farming.v1.Earnings")
	proto.RegisterType((*AccountInfo)(nil), "sgn.farming.v1.AccountInfo")
	proto.RegisterType((*Signature)(nil), "sgn.farming.v1.Signature")
	proto.RegisterType((*RewardClaimDetails)(nil), "sgn.farming.v1.RewardClaimDetails")
	proto.RegisterType((*RewardClaimInfo)(nil), "sgn.farming.v1.RewardClaimInfo")
	proto.RegisterType((*RewardAdjustmentInput)(nil), "sgn.farming.v1.RewardAdjustmentInput")
	proto.RegisterType((*AddPoolProposal)(nil), "sgn.farming.v1.AddPoolProposal")
	proto.RegisterType((*AddPoolProposalWithDeposit)(nil), "sgn.farming.v1.AddPoolProposalWithDeposit")
	proto.RegisterType((*AdjustRewardProposal)(nil), "sgn.farming.v1.AdjustRewardProposal")
	proto.RegisterType((*AdjustRewardProposalWithDeposit)(nil), "sgn.farming.v1.AdjustRewardProposalWithDeposit")
	proto.RegisterType((*RemovePoolProposal)(nil), "sgn.farming.v1.RemovePoolProposal")
	proto.RegisterType((*RemovePoolProposalWithDeposit)(nil), "sgn.farming.v1.RemovePoolProposalWithDeposit")
	proto.RegisterType((*AddTokensProposal)(nil), "sgn.farming.v1.AddTokensProposal")
	proto.RegisterType((*AddTokensProposalWithDeposit)(nil), "sgn.farming.v1.AddTokensProposalWithDeposit")
}

func init() { proto.RegisterFile("sgn/farming/v1/farming.proto", fileDescriptor_159299d9ca2b2f07) }

var fileDescriptor_159299d9ca2b2f07 = []byte{
	// 1956 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x77, 0xcf, 0x8c, 0xbf, 0xca, 0x1e, 0x7f, 0x94, 0x3d, 0xf1, 0xd8, 0x71, 0xa6, 0x43, 0xb1,
	0xec, 0x66, 0xb5, 0xc9, 0x0c, 0xf6, 0x1e, 0x40, 0x96, 0x90, 0xf0, 0xd8, 0x59, 0x12, 0xb1, 0x44,
	0x56, 0x27, 0x10, 0x09, 0x81, 0x5a, 0xe5, 0xee, 0xf2, 0xb8, 0x70, 0x7f, 0x8c, 0xba, 0x6a, 0xec,
	0xf5, 0x01, 0xed, 0x01, 0x09, 0x56, 0x70, 0x60, 0x97, 0x53, 0x2e, 0x48, 0x81, 0x13, 0x82, 0x13,
	0x27, 0xf8, 0x03, 0x10, 0xda, 0x13, 0x2c, 0x37, 0xc4, 0x61, 0x16, 0x39, 0x12, 0x42, 0x2b, 0x38,
	0x30, 0x37, 0x6e, 0xa8, 0x3e, 0xba, 0xa7, 0xbb, 0x67, 0x9c, 0x9d, 0x89, 0x42, 0x94, 0x3d, 0xa5,
	0xfd, 0xea, 0xd5, 0xab, 0x57, 0xef, 0xf7, 0x3e, 0x7e, 0x35, 0x01, 0x9b, 0xac, 0x15, 0x34, 0x8e,
	0x70, 0xe4, 0xd3, 0xa0, 0xd5, 0x38, 0xdd, 0x8a, 0x3f, 0xeb, 0xed, 0x28, 0xe4, 0x21, 0x5c, 0x60,
	0xad, 0xa0, 0x1e, 0x8b, 0x4e, 0xb7, 0x36, 0x56, 0x5b, 0x61, 0x2b, 0x94, 0x4b, 0x0d, 0xf1, 0xa5,
	0xb4, 0x36, 0x6a, 0xad, 0x30, 0x6c, 0x79, 0xa4, 0x21, 0xff, 0x3a, 0xec, 0x1c, 0x35, 0xdc, 0x4e,
	0x84, 0x39, 0x0d, 0x03, 0xbd, 0x6e, 0xe6, 0xd7, 0x39, 0xf5, 0x09, 0xe3, 0xd8, 0x6f, 0xc7, 0x06,
	0x9c, 0x90, 0xf9, 0x21, 0x6b, 0x1c, 0x62, 0x46, 0x1a, 0xa7, 0x5b, 0x87, 0x84, 0xe3, 0xad, 0x86,
	0x13, 0x52, 0x6d, 0x00, 0xfd, 0xd4, 0x00, 0x53, 0x07, 0x38, 0xc2, 0x3e, 0x83, 0xef, 0x82, 0x05,
	0xc7, 0xc3, 0xd4, 0xb7, 0x9d, 0x30, 0xf4, 0xdc, 0xf0, 0x2c, 0xa8, 0x1a, 0xd7, 0x8d, 0x1b, 0x73,
	0xdb, 0xeb, 0x75, 0x75, 0x48, 0x3d, 0x3e, 0xa4, 0xbe, 0xaf, 0x9d, 0x68, 0x7e, 0xe5, 0xc3, 0xae,
	0x39, 0xf1, 0x49, 0xd7, 0xac, 0x66, 0x37, 0xde, 0x0c, 0x7d, 0xca, 0x89, 0xdf, 0xe6, 0xe7, 0xbd,
	0xae, 0x59, 0x39, 0xc7, 0xbe, 0xb7, 0x83, 0xb2, 0x1a, 0xe8, 0xd1, 0xc7, 0xa6, 0x61, 0x95, 0xa5,
	0x70, 0x4f, 0xcb, 0x76, 0x4a, 0x8f, 0x1e, 0x9b, 0x13, 0xe8, 0x8f, 0x06, 0x00, 0xb7, 0xad, 0xbd,
	0xed, 0x2f, 0x3e, 0x08, 0x4f, 0x48, 0x00, 0xeb, 0x60, 0xc6, 0x39, 0xc6, 0x34, 0xb0, 0xa9, 0x2b,
	0xfd, 0x29, 0x35, 0x57, 0x7a, 0x5d, 0x73, 0x51, 0x1b, 0xd5, 0x2b, 0xc8, 0x9a, 0x96, 0x9f, 0x77,
	0x5d, 0xf8, 0x3a, 0x98, 0x62, 0xe7, 0xfe, 0x61, 0xe8, 0x55, 0x0b, 0xd7, 0x8d, 0x1b, 0xb3, 0xcd,
	0xe5, 0x5e, 0xd7, 0x2c, 0x2b, 0x6d, 0x25, 0x47, 0x96, 0x56, 0x80, 0x37, 0xc1, 0x34, 0x76, 0xdd,
	0x88, 0x30, 0x56, 0x2d, 0x4a, 0x5d, 0xd8, 0xeb, 0x9a, 0x0b, 0x4a, 0x57, 0x2f, 0x20, 0x2b, 0x56,
	0x81, 0x0d, 0x30, 0xe3, 0x12, 0x87, 0xfa, 0xd8, 0x63, 0xd5, 0xd2, 0x75, 0xe3, 0x46, 0x39, 0xed,
	0x48, 0xbc, 0x82, 0xac, 0x44, 0x09, 0xfd, 0xa7, 0x04, 0xe6, 0xde, 0x52, 0x00, 0x1f, 0x84, 0xa1,
	0x07, 0x21, 0x28, 0x05, 0xd8, 0x27, 0xf2, 0x16, 0xb3, 0x96, 0xfc, 0x86, 0x0f, 0xc1, 0x1c, 0xe3,
	0xf8, 0x84, 0xd8, 0x5c, 0x5c, 0x56, 0xba, 0x3c, 0xb7, 0xbd, 0x51, 0xcf, 0xe6, 0x46, 0xbd, 0x1f,
	0x8e, 0xe6, 0x86, 0x88, 0x78, 0xaf, 0x6b, 0x42, 0x7d, 0xa5, 0xfe, 0x66, 0x64, 0x01, 0xf9, 0x97,
	0x0a, 0xdb, 0x77, 0x41, 0x39, 0x22, 0x67, 0x38, 0x72, 0xd5, 0xa2, 0xb8, 0x61, 0xf1, 0x53, 0x4c,
	0x6f, 0x6a, 0xd3, 0xab, 0xca, 0x74, 0x66, 0x3b, 0xb2, 0xe6, 0xd5, 0xdf, 0x52, 0x95, 0xc1, 0x36,
	0x58, 0xe1, 0x21, 0xc7, 0x9e, 0x2d, 0x8f, 0x74, 0x6d, 0xec, 0x87, 0x9d, 0x80, 0xcb, 0xb8, 0xcc,
	0x6d, 0x6f, 0xd6, 0x55, 0xd2, 0xd5, 0x45, 0xd2, 0xd5, 0x75, 0xd2, 0xd5, 0xf7, 0x89, 0xb3, 0x17,
	0xd2, 0xa0, 0x89, 0xf4, 0x31, 0x1b, 0xea, 0x98, 0x21, 0x66, 0x90, 0xb5, 0x2c, 0xa5, 0xf7, 0xa5,
	0x70, 0x57, 0xca, 0x60, 0x1b, 0xc0, 0xb4, 0x47, 0x36, 0x0d, 0x8e, 0x42, 0x56, 0x9d, 0x94, 0xb7,
	0x32, 0xf3, 0xb7, 0xb2, 0xfa, 0xbe, 0xde, 0x0d, 0x8e, 0xc2, 0xe6, 0xe7, 0xf4, 0x99, 0xeb, 0x83,
	0x57, 0x53, 0x86, 0x90, 0xb5, 0x14, 0x65, 0xf7, 0x30, 0xf8, 0x5b, 0x03, 0xac, 0x2b, 0xef, 0xb0,
	0xe3, 0x74, 0xfc, 0x8e, 0x87, 0x39, 0x71, 0x6d, 0xa5, 0xc6, 0xaa, 0x53, 0xf2, 0xe4, 0xa7, 0x5f,
	0xf5, 0xa1, 0x3e, 0xf6, 0x7a, 0xfa, 0xaa, 0x43, 0x8c, 0xa1, 0x5f, 0x7f, 0x6c, 0xbe, 0xd1, 0xa2,
	0xfc, 0xb8, 0x73, 0x58, 0x77, 0x42, 0xbf, 0xa1, 0x6b, 0x56, 0xfd, 0x73, 0x8b, 0xb9, 0x27, 0x0d,
	0x7e, 0xde, 0x26, 0x2c, 0xb6, 0xcb, 0xac, 0x35, 0x69, 0x6a, 0xb7, 0x6f, 0xc9, 0xd2, 0x86, 0x5e,
	0x03, 0x33, 0xf7, 0x3a, 0xbe, 0x48, 0x37, 0x06, 0xaf, 0x82, 0xd9, 0xa0, 0xe3, 0xdb, 0x6d, 0xf1,
	0x87, 0x2a, 0x1d, 0x6b, 0x26, 0xd0, 0x8b, 0xe8, 0x1f, 0x05, 0xb0, 0x98, 0x8b, 0x12, 0x3c, 0x06,
	0x4b, 0x11, 0xf1, 0x31, 0x0d, 0x68, 0xd0, 0x8a, 0x11, 0x35, 0x46, 0x40, 0xd4, 0xd4, 0xd7, 0x5c,
	0x8b, 0xa3, 0x9b, 0xb5, 0x81, 0xac, 0xc5, 0x44, 0xa4, 0xc1, 0xb4, 0xc1, 0xba, 0xc6, 0x80, 0x71,
	0x1c, 0x71, 0xfb, 0xd0, 0x0b, 0x9d, 0x13, 0xfb, 0x98, 0xd0, 0xd6, 0x31, 0x97, 0x45, 0x50, 0x6c,
	0xbe, 0xd2, 0x8f, 0xdb, 0xa5, 0xaa, 0xc8, 0xba, 0xa2, 0xd6, 0xee, 0x8b, 0xa5, 0xa6, 0x58, 0xb9,
	0x23, 0x17, 0xe0, 0x8f, 0x0c, 0xb0, 0xa6, 0xb7, 0x29, 0x27, 0xec, 0x36, 0x89, 0xd4, 0x5e, 0x5d,
	0xeb, 0x07, 0xc2, 0xe9, 0xbf, 0x75, 0xcd, 0x57, 0x47, 0x8b, 0x7b, 0xaf, 0x6b, 0xd6, 0x32, 0xde,
	0xe4, 0xcd, 0x22, 0x6b, 0x55, 0xad, 0xa8, 0x2b, 0x1e, 0x90, 0x48, 0xfa, 0x83, 0xfe, 0x52, 0x00,
	0xb3, 0x32, 0x91, 0x65, 0x88, 0xbf, 0x0a, 0x16, 0x64, 0xaa, 0x47, 0x76, 0xdc, 0x79, 0x64, 0x37,
	0x68, 0xae, 0xf7, 0x1b, 0x65, 0x76, 0x1d, 0x59, 0x65, 0x25, 0xd8, 0xd5, 0x6d, 0x68, 0x0b, 0xcc,
	0x0a, 0x44, 0x6d, 0xd9, 0x4a, 0x54, 0x8b, 0x5b, 0xed, 0x75, 0xcd, 0x25, 0xb5, 0x39, 0x59, 0x42,
	0xd6, 0x8c, 0xf8, 0xbe, 0x27, 0x9a, 0xcc, 0x0e, 0x98, 0xd2, 0x68, 0x16, 0x47, 0x40, 0xb3, 0x24,
	0x02, 0x63, 0xe9, 0x1d, 0xf0, 0xeb, 0x00, 0x0e, 0x81, 0xa8, 0x24, 0x21, 0xba, 0xd6, 0xaf, 0xa8,
	0x61, 0xd8, 0x2c, 0xb1, 0x3c, 0x2a, 0x6f, 0x89, 0x04, 0x3b, 0x22, 0x11, 0x09, 0x1c, 0x22, 0x22,
	0x47, 0x43, 0xb7, 0x3a, 0x29, 0x7b, 0xfa, 0xd5, 0x74, 0xfa, 0x64, 0x35, 0x64, 0xfa, 0x68, 0xd1,
	0x81, 0x92, 0xfc, 0xb8, 0x00, 0x2a, 0x22, 0x8d, 0xef, 0x50, 0xc6, 0xc3, 0x88, 0x3a, 0xd8, 0xd3,
	0xf9, 0x0f, 0x7f, 0x63, 0x80, 0x35, 0x5d, 0x14, 0xf4, 0x94, 0xe8, 0xfa, 0xb2, 0xe5, 0xb4, 0xaa,
	0x1a, 0x23, 0x54, 0xec, 0x37, 0x75, 0x2a, 0x6b, 0xac, 0x2f, 0x31, 0x35, 0x76, 0xbd, 0x56, 0xfa,
	0x86, 0x94, 0xa7, 0x96, 0x30, 0x03, 0xf7, 0x40, 0xff, 0x6a, 0xb6, 0x23, 0x11, 0x2a, 0xc8, 0xc9,
	0xb2, 0xd1, 0xeb, 0x9a, 0x57, 0xf2, 0xe1, 0x70, 0x54, 0x31, 0x2d, 0x24, 0x92, 0x3d, 0x29, 0xf8,
	0x49, 0x01, 0x40, 0x11, 0x8c, 0xbd, 0x4e, 0x14, 0x91, 0x80, 0xc7, 0x91, 0x18, 0x0e, 0x9c, 0xf1,
	0x6c, 0xc0, 0xbd, 0x0e, 0xa6, 0x34, 0x5c, 0x05, 0x09, 0x57, 0x6a, 0xa8, 0xc6, 0x20, 0x69, 0x05,
	0xf8, 0x7d, 0x30, 0x1d, 0xb7, 0xc8, 0xe2, 0x08, 0x01, 0xbf, 0xad, 0x03, 0xbe, 0x90, 0x2e, 0xae,
	0xf1, 0x1b, 0x62, 0x7c, 0x26, 0xfa, 0x73, 0x01, 0xcc, 0xdc, 0xc6, 0x91, 0xe8, 0x35, 0x0c, 0xde,
	0x03, 0x2b, 0x1c, 0x47, 0x2d, 0x32, 0x34, 0x08, 0xb5, 0xd4, 0x0c, 0x1a, 0x54, 0x12, 0x33, 0x48,
	0x4a, 0xd3, 0x61, 0xb0, 0x41, 0x39, 0x3b, 0xef, 0x0a, 0x23, 0xd4, 0x53, 0x6e, 0xac, 0xe6, 0x26,
	0xdd, 0x3c, 0x4b, 0x0f, 0xb9, 0x0f, 0x0c, 0xb0, 0x90, 0xe9, 0x2f, 0xa3, 0x05, 0xf1, 0x6d, 0x7d,
	0x44, 0x65, 0x48, 0x87, 0x1a, 0x3f, 0x96, 0xe5, 0x74, 0x1f, 0x63, 0xe8, 0xf7, 0x05, 0x30, 0xb7,
	0xeb, 0xc8, 0xe4, 0x93, 0x2d, 0x6c, 0x1f, 0x68, 0x9f, 0x93, 0xc9, 0x22, 0x1c, 0xbc, 0x9a, 0x1f,
	0xc1, 0x29, 0xe6, 0xa3, 0x5b, 0x8a, 0x62, 0x3a, 0xae, 0x1a, 0x4e, 0x7b, 0xa0, 0x4c, 0x34, 0x4c,
	0xb6, 0x47, 0x99, 0x08, 0xa5, 0x30, 0x53, 0x1d, 0xe0, 0x27, 0x5a, 0x49, 0xdb, 0x98, 0x8f, 0x37,
	0xbd, 0x4d, 0x19, 0x87, 0x3f, 0x37, 0x00, 0x1c, 0x28, 0xd1, 0xd1, 0x42, 0x76, 0x90, 0x65, 0x04,
	0x83, 0x56, 0xc6, 0x0e, 0xdb, 0x72, 0xbe, 0xc6, 0x19, 0xa2, 0x60, 0xf6, 0x3e, 0x6d, 0x05, 0x98,
	0x77, 0x22, 0x22, 0x89, 0x29, 0x6d, 0x05, 0x24, 0xd2, 0x2d, 0x3f, 0x4d, 0x4c, 0xa5, 0x5c, 0x10,
	0x53, 0xf9, 0x21, 0x7a, 0x3c, 0xa3, 0x2d, 0xfb, 0xf0, 0x9c, 0x13, 0x26, 0x73, 0x6c, 0x3e, 0xdd,
	0xe3, 0x93, 0x25, 0x64, 0xcd, 0x30, 0xda, 0x6a, 0xca, 0xcf, 0x1f, 0x16, 0x01, 0x54, 0xc7, 0xee,
	0x09, 0x4e, 0xbd, 0x4f, 0x38, 0xa6, 0x1e, 0x83, 0xeb, 0x79, 0xf6, 0xdc, 0x27, 0xca, 0x82, 0xde,
	0x0c, 0xf6, 0xb7, 0x38, 0xed, 0x0a, 0xe3, 0xd3, 0x9b, 0x4b, 0x8d, 0x8d, 0x4f, 0x6f, 0xf2, 0xa1,
	0xd4, 0xb9, 0x28, 0x9a, 0x9a, 0x36, 0x2d, 0xdf, 0x22, 0x3a, 0x42, 0x45, 0x19, 0xa1, 0x6b, 0x03,
	0xfc, 0x2e, 0xa5, 0x93, 0xf0, 0xbb, 0x03, 0x21, 0x93, 0x21, 0x83, 0x0f, 0x00, 0x60, 0x31, 0x3a,
	0x82, 0xd2, 0x17, 0xe5, 0x5b, 0x27, 0x97, 0x7f, 0x09, 0x7e, 0xcd, 0x75, 0x7d, 0xdb, 0xe5, 0x3e,
	0x66, 0x6a, 0xab, 0x20, 0xde, 0xfd, 0x3f, 0x7e, 0x91, 0x10, 0x2b, 0x09, 0x84, 0x2c, 0x99, 0x4d,
	0x30, 0x1b, 0x11, 0x87, 0xb6, 0x29, 0xd1, 0x8c, 0x6a, 0xd6, 0xea, 0x0b, 0xe0, 0x11, 0x58, 0xf4,
	0x30, 0xe3, 0xb6, 0x7a, 0x21, 0x89, 0x07, 0x5c, 0xf2, 0x0e, 0xc8, 0x3f, 0xbc, 0x1e, 0xc4, 0xaf,
	0xbb, 0x84, 0x45, 0xeb, 0x29, 0x91, 0x33, 0x80, 0xde, 0x97, 0xcf, 0x2b, 0x21, 0x95, 0x5e, 0x88,
	0x7d, 0x82, 0x13, 0xc5, 0xac, 0x4b, 0x69, 0xba, 0x2a, 0x49, 0x54, 0xfd, 0xa9, 0xa2, 0x41, 0xc3,
	0x99, 0x74, 0x3a, 0xa7, 0x9a, 0x37, 0xb2, 0xb0, 0x5f, 0x6a, 0x32, 0x61, 0x67, 0xe9, 0xdd, 0xa2,
	0x6e, 0xd1, 0x45, 0x01, 0x54, 0x34, 0xb0, 0xee, 0xf7, 0x3a, 0x8c, 0xfb, 0x44, 0xf4, 0x96, 0x76,
	0x87, 0xc3, 0x6f, 0x01, 0x80, 0x5d, 0x77, 0x1c, 0xf2, 0x99, 0x83, 0xa5, 0xbf, 0x1b, 0x59, 0xb3,
	0xd8, 0x8d, 0x1b, 0xeb, 0x77, 0x40, 0x75, 0x08, 0x8b, 0x74, 0x89, 0x87, 0xcf, 0x35, 0xdf, 0xfc,
	0x7c, 0xaf, 0x6b, 0x9a, 0x97, 0xf2, 0x4d, 0xa9, 0x89, 0xac, 0x4a, 0x9e, 0x6e, 0xee, 0x0b, 0x39,
	0xfc, 0x99, 0x01, 0xae, 0x06, 0xe4, 0xcc, 0x7e, 0x3a, 0xe3, 0x7c, 0x30, 0x36, 0xe3, 0x44, 0xca,
	0x9f, 0xa7, 0x98, 0x46, 0xd6, 0x5a, 0x40, 0xce, 0xac, 0x61, 0xc4, 0xf3, 0xdf, 0x45, 0xb0, 0xb8,
	0xeb, 0xca, 0x76, 0x7b, 0x10, 0x85, 0xed, 0x90, 0x61, 0x0f, 0xbe, 0x0a, 0x26, 0x39, 0xe5, 0x9e,
	0x7e, 0x83, 0x36, 0x97, 0x7a, 0x5d, 0x73, 0x5e, 0x8f, 0x40, 0x21, 0x46, 0x96, 0x5a, 0x86, 0x5f,
	0x06, 0x73, 0x2e, 0x61, 0x4e, 0x44, 0xdb, 0xe2, 0x99, 0xaf, 0x69, 0xe6, 0x95, 0xfe, 0xb3, 0x33,
	0xb5, 0x88, 0xac, 0xb4, 0x6a, 0x96, 0x9e, 0x16, 0x47, 0xa2, 0xa7, 0xb9, 0x37, 0x70, 0xe9, 0xff,
	0xf7, 0x06, 0x9e, 0x7c, 0xae, 0x6f, 0xe0, 0x77, 0x41, 0x85, 0x06, 0x94, 0x53, 0xec, 0xc5, 0xe8,
	0x50, 0x91, 0xc3, 0xf1, 0xd3, 0xf0, 0x0b, 0xc3, 0x4b, 0x29, 0x97, 0xf1, 0xcd, 0x57, 0xf4, 0x89,
	0x9b, 0xea, 0xc4, 0xa1, 0x16, 0x91, 0xb5, 0xa2, 0xe5, 0xca, 0x86, 0xdc, 0xc9, 0x76, 0xe6, 0xdf,
	0x7b, 0x6c, 0x4e, 0x3c, 0x7a, 0x6c, 0x4e, 0xfc, 0xf3, 0xb1, 0x39, 0x81, 0x3e, 0x98, 0x04, 0x1b,
	0x39, 0xbc, 0x1f, 0x52, 0x7e, 0xbc, 0x4f, 0xda, 0x21, 0xa3, 0xfc, 0x05, 0x40, 0x7f, 0x67, 0x10,
	0xfa, 0x37, 0x3e, 0xe9, 0x9a, 0x2b, 0x89, 0x30, 0xf3, 0xb3, 0xd0, 0xd3, 0x32, 0xa2, 0x3d, 0x6e,
	0x46, 0xbc, 0xa9, 0x7f, 0x87, 0xaa, 0xa4, 0xb6, 0x65, 0x4e, 0xfb, 0xb4, 0x54, 0x79, 0x67, 0xfc,
	0x54, 0xf9, 0x92, 0x3e, 0x73, 0x2d, 0xb3, 0x31, 0x73, 0xea, 0x28, 0x59, 0xf4, 0x4b, 0xe3, 0xb9,
	0xa4, 0xd1, 0xd7, 0xb4, 0x37, 0xe6, 0x50, 0x5b, 0x19, 0xaf, 0xc6, 0xcf, 0x34, 0x78, 0x13, 0x4c,
	0xbb, 0x2a, 0x8f, 0xaa, 0xd3, 0xf9, 0x5f, 0xca, 0xf4, 0x02, 0xb2, 0x62, 0x95, 0x9d, 0x19, 0x9d,
	0x97, 0x06, 0xfa, 0x43, 0x01, 0xac, 0x2a, 0x4f, 0xad, 0x78, 0xfa, 0xbe, 0xc4, 0x8d, 0xe8, 0x3d,
	0x23, 0x99, 0x12, 0x38, 0x09, 0x6f, 0x8c, 0x46, 0x69, 0x1c, 0x34, 0x5e, 0xd3, 0x45, 0x9d, 0x1d,
	0x28, 0x03, 0x46, 0x93, 0x09, 0x99, 0xdb, 0x9f, 0x2f, 0xed, 0xff, 0x16, 0x80, 0x39, 0x2c, 0x8c,
	0x2f, 0xb6, 0xbe, 0x3f, 0xd3, 0x11, 0x4d, 0xa7, 0xf0, 0xe4, 0x38, 0x29, 0xfc, 0x3b, 0x43, 0x10,
	0x6b, 0x3f, 0x3c, 0x25, 0x2f, 0xfd, 0x24, 0xcd, 0x65, 0xcd, 0xbf, 0x0c, 0x70, 0x6d, 0xd0, 0xf3,
	0x97, 0x3e, 0x67, 0x52, 0x40, 0x95, 0xc6, 0x01, 0xea, 0x4f, 0x06, 0x58, 0xde, 0x75, 0x75, 0x5b,
	0x7d, 0x81, 0x38, 0xdd, 0x05, 0x53, 0x23, 0xff, 0xc4, 0x5e, 0xd1, 0x59, 0x5c, 0x8e, 0x7f, 0x10,
	0x56, 0x13, 0x41, 0x1b, 0xc8, 0xe1, 0xf7, 0x83, 0x02, 0xd8, 0x1c, 0xb8, 0xd0, 0x8b, 0x85, 0xef,
	0xf9, 0xdd, 0xed, 0x59, 0x61, 0x6d, 0x7e, 0xe3, 0x57, 0x17, 0x35, 0xe3, 0xc3, 0x8b, 0x9a, 0xf1,
	0xd1, 0x45, 0xcd, 0xf8, 0xfb, 0x45, 0xcd, 0x78, 0xff, 0x49, 0x6d, 0xe2, 0xa3, 0x27, 0xb5, 0x89,
	0xbf, 0x3e, 0xa9, 0x4d, 0x7c, 0xbb, 0x91, 0xe6, 0xd2, 0xc4, 0x23, 0xd1, 0xad, 0x80, 0xf0, 0xb3,
	0x30, 0x3a, 0x69, 0xb0, 0x56, 0x70, 0xeb, 0x74, 0xbb, 0xf1, 0x4e, 0xf2, 0x3f, 0x70, 0x92, 0x58,
	0x1f, 0x4e, 0xc9, 0xb7, 0xd4, 0x9b, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xa7, 0xf9, 0x08, 0x0c,
	0x9d, 0x1b, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClaimCooldown != that1.ClaimCooldown {
		return false
	}
	return true
}
func (this *ERC20Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ERC20Token)
	if !ok {
		that2, ok := that.(ERC20Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	if this.Symbol != that1.Symbol {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Decimals != that1.Decimals {
		return false
	}
	return true
}
func (this *FarmingPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FarmingPool)
	if !ok {
		that2, ok := that.(FarmingPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.StakeToken.Equal(&that1.StakeToken) {
		return false
	}
	if len(this.RewardTokens) != len(that1.RewardTokens) {
		return false
	}
	for i := range this.RewardTokens {
		if !this.RewardTokens[i].Equal(&that1.RewardTokens[i]) {
			return false
		}
	}
	if !this.TotalStakedAmount.Equal(&that1.TotalStakedAmount) {
		return false
	}
	if len(this.RewardTokenInfos) != len(that1.RewardTokenInfos) {
		return false
	}
	for i := range this.RewardTokenInfos {
		if !this.RewardTokenInfos[i].Equal(&that1.RewardTokenInfos[i]) {
			return false
		}
	}
	if len(this.TotalAccumulatedRewards) != len(that1.TotalAccumulatedRewards) {
		return false
	}
	for i := range this.TotalAccumulatedRewards {
		if !this.TotalAccumulatedRewards[i].Equal(&that1.TotalAccumulatedRewards[i]) {
			return false
		}
	}
	return true
}
func (this *NumPools) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NumPools)
	if !ok {
		that2, ok := that.(NumPools)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumPools != that1.NumPools {
		return false
	}
	return true
}
func (this *RewardTokenInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardTokenInfo)
	if !ok {
		that2, ok := that.(RewardTokenInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RemainingAmount.Equal(&that1.RemainingAmount) {
		return false
	}
	if this.RewardStartBlockHeight != that1.RewardStartBlockHeight {
		return false
	}
	if !this.RewardAmountPerBlock.Equal(that1.RewardAmountPerBlock) {
		return false
	}
	return true
}
func (this *StakeInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StakeInfo)
	if !ok {
		that2, ok := that.(StakeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StakerAddress != that1.StakerAddress {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if !this.Amount.Equal(&that1.Amount) {
		return false
	}
	if this.StartBlockHeight != that1.StartBlockHeight {
		return false
	}
	if this.ReferencePeriod != that1.ReferencePeriod {
		return false
	}
	return true
}
func (this *PoolHistoricalRewards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PoolHistoricalRewards)
	if !ok {
		that2, ok := that.(PoolHistoricalRewards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CumulativeRewardRatio) != len(that1.CumulativeRewardRatio) {
		return false
	}
	for i := range this.CumulativeRewardRatio {
		if !this.CumulativeRewardRatio[i].Equal(&that1.CumulativeRewardRatio[i]) {
			return false
		}
	}
	if this.ReferenceCount != that1.ReferenceCount {
		return false
	}
	return true
}
func (this *PoolCurrentRewards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PoolCurrentRewards)
	if !ok {
		that2, ok := that.(PoolCurrentRewards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartBlockHeight != that1.StartBlockHeight {
		return false
	}
	if this.Period != that1.Period {
		return false
	}
	if len(this.Rewards) != len(that1.Rewards) {
		return false
	}
	for i := range this.Rewards {
		if !this.Rewards[i].Equal(&that1.Rewards[i]) {
			return false
		}
	}
	return true
}
func (this *Earnings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Earnings)
	if !ok {
		that2, ok := that.(Earnings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TargetBlockHeight != that1.TargetBlockHeight {
		return false
	}
	if !this.StakedAmount.Equal(&that1.StakedAmount) {
		return false
	}
	if len(this.RewardAmounts) != len(that1.RewardAmounts) {
		return false
	}
	for i := range this.RewardAmounts {
		if !this.RewardAmounts[i].Equal(&that1.RewardAmounts[i]) {
			return false
		}
	}
	return true
}
func (this *AccountInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountInfo)
	if !ok {
		that2, ok := that.(AccountInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StakedPools) != len(that1.StakedPools) {
		return false
	}
	for i := range this.StakedPools {
		if !this.StakedPools[i].Equal(&that1.StakedPools[i]) {
			return false
		}
	}
	if len(this.EarningsList) != len(that1.EarningsList) {
		return false
	}
	for i := range this.EarningsList {
		if !this.EarningsList[i].Equal(&that1.EarningsList[i]) {
			return false
		}
	}
	if len(this.CumulativeRewards) != len(that1.CumulativeRewards) {
		return false
	}
	for i := range this.CumulativeRewards {
		if !this.CumulativeRewards[i].Equal(&that1.CumulativeRewards[i]) {
			return false
		}
	}
	return true
}
func (this *Signature) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Signature)
	if !ok {
		that2, ok := that.(Signature)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Signer != that1.Signer {
		return false
	}
	if !bytes.Equal(this.SigBytes, that1.SigBytes) {
		return false
	}
	return true
}
func (this *RewardClaimDetails) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardClaimDetails)
	if !ok {
		that2, ok := that.(RewardClaimDetails)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	if len(this.CumulativeRewardAmounts) != len(that1.CumulativeRewardAmounts) {
		return false
	}
	for i := range this.CumulativeRewardAmounts {
		if !this.CumulativeRewardAmounts[i].Equal(&that1.CumulativeRewardAmounts[i]) {
			return false
		}
	}
	if !bytes.Equal(this.RewardProtoBytes, that1.RewardProtoBytes) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !this.Signatures[i].Equal(&that1.Signatures[i]) {
			return false
		}
	}
	return true
}
func (this *RewardClaimInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardClaimInfo)
	if !ok {
		that2, ok := that.(RewardClaimInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Recipient != that1.Recipient {
		return false
	}
	if !this.LastClaimTime.Equal(that1.LastClaimTime) {
		return false
	}
	if len(this.RewardClaimDetailsList) != len(that1.RewardClaimDetailsList) {
		return false
	}
	for i := range this.RewardClaimDetailsList {
		if !this.RewardClaimDetailsList[i].Equal(&that1.RewardClaimDetailsList[i]) {
			return false
		}
	}
	return true
}
func (this *RewardAdjustmentInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardAdjustmentInput)
	if !ok {
		that2, ok := that.(RewardAdjustmentInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddAmount.Equal(&that1.AddAmount) {
		return false
	}
	if this.RewardStartBlockDelay != that1.RewardStartBlockDelay {
		return false
	}
	if !this.NewRewardAmountPerBlock.Equal(that1.NewRewardAmountPerBlock) {
		return false
	}
	return true
}
func (this *AddPoolProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddPoolProposalWithDeposit)
	if !ok {
		that2, ok := that.(AddPoolProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if !this.StakeToken.Equal(&that1.StakeToken) {
		return false
	}
	if len(this.RewardTokens) != len(that1.RewardTokens) {
		return false
	}
	for i := range this.RewardTokens {
		if !this.RewardTokens[i].Equal(&that1.RewardTokens[i]) {
			return false
		}
	}
	if len(this.InitialRewardInputs) != len(that1.InitialRewardInputs) {
		return false
	}
	for i := range this.InitialRewardInputs {
		if !this.InitialRewardInputs[i].Equal(&that1.InitialRewardInputs[i]) {
			return false
		}
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (this *AdjustRewardProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdjustRewardProposalWithDeposit)
	if !ok {
		that2, ok := that.(AdjustRewardProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if len(this.RewardAdjustmentInputs) != len(that1.RewardAdjustmentInputs) {
		return false
	}
	for i := range this.RewardAdjustmentInputs {
		if !this.RewardAdjustmentInputs[i].Equal(&that1.RewardAdjustmentInputs[i]) {
			return false
		}
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (this *RemovePoolProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemovePoolProposalWithDeposit)
	if !ok {
		that2, ok := that.(RemovePoolProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (this *AddTokensProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddTokensProposalWithDeposit)
	if !ok {
		that2, ok := that.(AddTokensProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Tokens) != len(that1.Tokens) {
		return false
	}
	for i := range this.Tokens {
		if !this.Tokens[i].Equal(&that1.Tokens[i]) {
			return false
		}
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.ClaimCooldown, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.ClaimCooldown):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintFarming(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ERC20Token) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERC20Token) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERC20Token) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Decimals != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FarmingPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FarmingPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FarmingPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalAccumulatedRewards) > 0 {
		for iNdEx := len(m.TotalAccumulatedRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalAccumulatedRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RewardTokenInfos) > 0 {
		for iNdEx := len(m.RewardTokenInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardTokenInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.TotalStakedAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.RewardTokens) > 0 {
		for iNdEx := len(m.RewardTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.StakeToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NumPools) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumPools) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumPools) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumPools != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.NumPools))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RewardAmountPerBlock.Size()
		i -= size
		if _, err := m.RewardAmountPerBlock.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RewardStartBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.RewardStartBlockHeight))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RemainingAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StakeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReferencePeriod != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.ReferencePeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.StartBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.StartBlockHeight))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerAddress) > 0 {
		i -= len(m.StakerAddress)
		copy(dAtA[i:], m.StakerAddress)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.StakerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolHistoricalRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolHistoricalRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolHistoricalRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReferenceCount != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.ReferenceCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CumulativeRewardRatio) > 0 {
		for iNdEx := len(m.CumulativeRewardRatio) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CumulativeRewardRatio[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PoolCurrentRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolCurrentRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolCurrentRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Period != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.Period))
		i--
		dAtA[i] = 0x10
	}
	if m.StartBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.StartBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Earnings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Earnings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Earnings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardAmounts) > 0 {
		for iNdEx := len(m.RewardAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.StakedAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TargetBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.TargetBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CumulativeRewards) > 0 {
		for iNdEx := len(m.CumulativeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CumulativeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EarningsList) > 0 {
		for iNdEx := len(m.EarningsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EarningsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.StakedPools) > 0 {
		for iNdEx := len(m.StakedPools) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StakedPools[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SigBytes) > 0 {
		i -= len(m.SigBytes)
		copy(dAtA[i:], m.SigBytes)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.SigBytes)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardClaimDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardClaimDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardClaimDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RewardProtoBytes) > 0 {
		i -= len(m.RewardProtoBytes)
		copy(dAtA[i:], m.RewardProtoBytes)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.RewardProtoBytes)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CumulativeRewardAmounts) > 0 {
		for iNdEx := len(m.CumulativeRewardAmounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CumulativeRewardAmounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ChainId != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardClaimInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardClaimInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardClaimInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardClaimDetailsList) > 0 {
		for iNdEx := len(m.RewardClaimDetailsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardClaimDetailsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastClaimTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastClaimTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintFarming(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x12
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardAdjustmentInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardAdjustmentInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardAdjustmentInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewRewardAmountPerBlock.Size()
		i -= size
		if _, err := m.NewRewardAmountPerBlock.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RewardStartBlockDelay != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.RewardStartBlockDelay))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.AddAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddPoolProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPoolProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPoolProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InitialRewardInputs) > 0 {
		for iNdEx := len(m.InitialRewardInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitialRewardInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RewardTokens) > 0 {
		for iNdEx := len(m.RewardTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.StakeToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddPoolProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPoolProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPoolProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InitialRewardInputs) > 0 {
		for iNdEx := len(m.InitialRewardInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitialRewardInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RewardTokens) > 0 {
		for iNdEx := len(m.RewardTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.StakeToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdjustRewardProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdjustRewardProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdjustRewardProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardAdjustmentInputs) > 0 {
		for iNdEx := len(m.RewardAdjustmentInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardAdjustmentInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdjustRewardProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdjustRewardProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdjustRewardProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RewardAdjustmentInputs) > 0 {
		for iNdEx := len(m.RewardAdjustmentInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardAdjustmentInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemovePoolProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePoolProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePoolProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemovePoolProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePoolProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePoolProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddTokensProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTokensProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTokensProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddTokensProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTokensProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTokensProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFarming(dAtA []byte, offset int, v uint64) int {
	offset -= sovFarming(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.ClaimCooldown)
	n += 1 + l + sovFarming(uint64(l))
	return n
}

func (m *ERC20Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovFarming(uint64(m.ChainId))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovFarming(uint64(m.Decimals))
	}
	return n
}

func (m *FarmingPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.StakeToken.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardTokens) > 0 {
		for _, e := range m.RewardTokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = m.TotalStakedAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardTokenInfos) > 0 {
		for _, e := range m.RewardTokenInfos {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.TotalAccumulatedRewards) > 0 {
		for _, e := range m.TotalAccumulatedRewards {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *NumPools) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumPools != 0 {
		n += 1 + sovFarming(uint64(m.NumPools))
	}
	return n
}

func (m *RewardTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RemainingAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if m.RewardStartBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.RewardStartBlockHeight))
	}
	l = m.RewardAmountPerBlock.Size()
	n += 1 + l + sovFarming(uint64(l))
	return n
}

func (m *StakeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerAddress)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if m.StartBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.StartBlockHeight))
	}
	if m.ReferencePeriod != 0 {
		n += 1 + sovFarming(uint64(m.ReferencePeriod))
	}
	return n
}

func (m *PoolHistoricalRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CumulativeRewardRatio) > 0 {
		for _, e := range m.CumulativeRewardRatio {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if m.ReferenceCount != 0 {
		n += 1 + sovFarming(uint64(m.ReferenceCount))
	}
	return n
}

func (m *PoolCurrentRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.StartBlockHeight))
	}
	if m.Period != 0 {
		n += 1 + sovFarming(uint64(m.Period))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *Earnings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.TargetBlockHeight))
	}
	l = m.StakedAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardAmounts) > 0 {
		for _, e := range m.RewardAmounts {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *AccountInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StakedPools) > 0 {
		for _, e := range m.StakedPools {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.EarningsList) > 0 {
		for _, e := range m.EarningsList {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.CumulativeRewards) > 0 {
		for _, e := range m.CumulativeRewards {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.SigBytes)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *RewardClaimDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovFarming(uint64(m.ChainId))
	}
	if len(m.CumulativeRewardAmounts) > 0 {
		for _, e := range m.CumulativeRewardAmounts {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = len(m.RewardProtoBytes)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *RewardClaimInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastClaimTime)
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardClaimDetailsList) > 0 {
		for _, e := range m.RewardClaimDetailsList {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *RewardAdjustmentInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AddAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if m.RewardStartBlockDelay != 0 {
		n += 1 + sovFarming(uint64(m.RewardStartBlockDelay))
	}
	l = m.NewRewardAmountPerBlock.Size()
	n += 1 + l + sovFarming(uint64(l))
	return n
}

func (m *AddPoolProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.StakeToken.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardTokens) > 0 {
		for _, e := range m.RewardTokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.InitialRewardInputs) > 0 {
		for _, e := range m.InitialRewardInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *AddPoolProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.StakeToken.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardTokens) > 0 {
		for _, e := range m.RewardTokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.InitialRewardInputs) > 0 {
		for _, e := range m.InitialRewardInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *AdjustRewardProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.RewardAdjustmentInputs) > 0 {
		for _, e := range m.RewardAdjustmentInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *AdjustRewardProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.RewardAdjustmentInputs) > 0 {
		for _, e := range m.RewardAdjustmentInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *RemovePoolProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *RemovePoolProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *AddTokensProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *AddTokensProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func sovFarming(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFarming(x uint64) (n int) {
	return sovFarming(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimCooldown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.ClaimCooldown, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERC20Token) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERC20Token: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERC20Token: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FarmingPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FarmingPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FarmingPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTokens = append(m.RewardTokens, ERC20Token{})
			if err := m.RewardTokens[len(m.RewardTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStakedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalStakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTokenInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTokenInfos = append(m.RewardTokenInfos, RewardTokenInfo{})
			if err := m.RewardTokenInfos[len(m.RewardTokenInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAccumulatedRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAccumulatedRewards = append(m.TotalAccumulatedRewards, types.DecCoin{})
			if err := m.TotalAccumulatedRewards[len(m.TotalAccumulatedRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumPools) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumPools: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumPools: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPools", wireType)
			}
			m.NumPools = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPools |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardStartBlockHeight", wireType)
			}
			m.RewardStartBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardStartBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmountPerBlock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardAmountPerBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlockHeight", wireType)
			}
			m.StartBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencePeriod", wireType)
			}
			m.ReferencePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolHistoricalRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolHistoricalRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolHistoricalRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeRewardRatio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeRewardRatio = append(m.CumulativeRewardRatio, types.DecCoin{})
			if err := m.CumulativeRewardRatio[len(m.CumulativeRewardRatio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceCount", wireType)
			}
			m.ReferenceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolCurrentRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolCurrentRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolCurrentRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlockHeight", wireType)
			}
			m.StartBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, types.DecCoin{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Earnings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Earnings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Earnings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBlockHeight", wireType)
			}
			m.TargetBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAmounts = append(m.RewardAmounts, types.DecCoin{})
			if err := m.RewardAmounts[len(m.RewardAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedPools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakedPools = append(m.StakedPools, FarmingPool{})
			if err := m.StakedPools[len(m.StakedPools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarningsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarningsList = append(m.EarningsList, Earnings{})
			if err := m.EarningsList[len(m.EarningsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeRewards = append(m.CumulativeRewards, types.DecCoin{})
			if err := m.CumulativeRewards[len(m.CumulativeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigBytes = append(m.SigBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.SigBytes == nil {
				m.SigBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardClaimDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardClaimDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardClaimDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeRewardAmounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeRewardAmounts = append(m.CumulativeRewardAmounts, types.DecCoin{})
			if err := m.CumulativeRewardAmounts[len(m.CumulativeRewardAmounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardProtoBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardProtoBytes = append(m.RewardProtoBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RewardProtoBytes == nil {
				m.RewardProtoBytes = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardClaimInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardClaimInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardClaimInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastClaimTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastClaimTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardClaimDetailsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardClaimDetailsList = append(m.RewardClaimDetailsList, RewardClaimDetails{})
			if err := m.RewardClaimDetailsList[len(m.RewardClaimDetailsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardAdjustmentInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardAdjustmentInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardAdjustmentInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardStartBlockDelay", wireType)
			}
			m.RewardStartBlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardStartBlockDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRewardAmountPerBlock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewRewardAmountPerBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPoolProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPoolProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPoolProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTokens = append(m.RewardTokens, ERC20Token{})
			if err := m.RewardTokens[len(m.RewardTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialRewardInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialRewardInputs = append(m.InitialRewardInputs, RewardAdjustmentInput{})
			if err := m.InitialRewardInputs[len(m.InitialRewardInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPoolProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPoolProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPoolProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTokens = append(m.RewardTokens, ERC20Token{})
			if err := m.RewardTokens[len(m.RewardTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialRewardInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialRewardInputs = append(m.InitialRewardInputs, RewardAdjustmentInput{})
			if err := m.InitialRewardInputs[len(m.InitialRewardInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdjustRewardProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdjustRewardProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdjustRewardProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAdjustmentInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAdjustmentInputs = append(m.RewardAdjustmentInputs, RewardAdjustmentInput{})
			if err := m.RewardAdjustmentInputs[len(m.RewardAdjustmentInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdjustRewardProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdjustRewardProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdjustRewardProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAdjustmentInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAdjustmentInputs = append(m.RewardAdjustmentInputs, RewardAdjustmentInput{})
			if err := m.RewardAdjustmentInputs[len(m.RewardAdjustmentInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemovePoolProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePoolProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePoolProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemovePoolProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePoolProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePoolProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTokensProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTokensProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTokensProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, ERC20Token{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTokensProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTokensProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTokensProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, ERC20Token{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFarming(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFarming
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFarming
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFarming
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFarming        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFarming          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFarming = fmt.Errorf("proto: unexpected end of group")
)
