// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/farming/v1/farming.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ERC20Token describes an ERC20 token on a specific EVM-compatible chain
type ERC20Token struct {
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty" yaml:"chain_id"`
	Symbol  string `protobuf:"bytes,2,opt,name=symbol,proto3" json:"symbol,omitempty" yaml:"symbol"`
	Address string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty" yaml:"address"`
}

func (m *ERC20Token) Reset()         { *m = ERC20Token{} }
func (m *ERC20Token) String() string { return proto.CompactTextString(m) }
func (*ERC20Token) ProtoMessage()    {}
func (*ERC20Token) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{0}
}
func (m *ERC20Token) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERC20Token) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERC20Token.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERC20Token) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERC20Token.Merge(m, src)
}
func (m *ERC20Token) XXX_Size() int {
	return m.Size()
}
func (m *ERC20Token) XXX_DiscardUnknown() {
	xxx_messageInfo_ERC20Token.DiscardUnknown(m)
}

var xxx_messageInfo_ERC20Token proto.InternalMessageInfo

func (m *ERC20Token) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *ERC20Token) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *ERC20Token) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// FarmingPool represents a pool that rewards liquidity providers with tokens
type FarmingPool struct {
	Name                    string                                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	StakeToken              ERC20Token                                  `protobuf:"bytes,2,opt,name=stake_token,json=stakeToken,proto3" json:"stake_token" yaml:"stake_token"`
	TotalStakedAmount       types.DecCoin                               `protobuf:"bytes,3,opt,name=total_staked_amount,json=totalStakedAmount,proto3" json:"total_staked_amount" yaml:"total_staked_amount"`
	RewardTokenInfos        []RewardTokenInfo                           `protobuf:"bytes,4,rep,name=reward_token_infos,json=rewardTokenInfos,proto3" json:"reward_token_infos" yaml:"reward_token_infos"`
	TotalAccumulatedRewards github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,5,rep,name=total_accumulated_rewards,json=totalAccumulatedRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"total_accumulated_rewards" yaml:"total_accumulated_rewards"`
}

func (m *FarmingPool) Reset()         { *m = FarmingPool{} }
func (m *FarmingPool) String() string { return proto.CompactTextString(m) }
func (*FarmingPool) ProtoMessage()    {}
func (*FarmingPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{1}
}
func (m *FarmingPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FarmingPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FarmingPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FarmingPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FarmingPool.Merge(m, src)
}
func (m *FarmingPool) XXX_Size() int {
	return m.Size()
}
func (m *FarmingPool) XXX_DiscardUnknown() {
	xxx_messageInfo_FarmingPool.DiscardUnknown(m)
}

var xxx_messageInfo_FarmingPool proto.InternalMessageInfo

func (m *FarmingPool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FarmingPool) GetStakeToken() ERC20Token {
	if m != nil {
		return m.StakeToken
	}
	return ERC20Token{}
}

func (m *FarmingPool) GetTotalStakedAmount() types.DecCoin {
	if m != nil {
		return m.TotalStakedAmount
	}
	return types.DecCoin{}
}

func (m *FarmingPool) GetRewardTokenInfos() []RewardTokenInfo {
	if m != nil {
		return m.RewardTokenInfos
	}
	return nil
}

func (m *FarmingPool) GetTotalAccumulatedRewards() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.TotalAccumulatedRewards
	}
	return nil
}

// NumPools is a wrapper of uint to display by CLI query
type NumPools struct {
	NumPools uint64 `protobuf:"varint,1,opt,name=num_pools,json=numPools,proto3" json:"num_pools,omitempty"`
}

func (m *NumPools) Reset()         { *m = NumPools{} }
func (m *NumPools) String() string { return proto.CompactTextString(m) }
func (*NumPools) ProtoMessage()    {}
func (*NumPools) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{2}
}
func (m *NumPools) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumPools) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumPools.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumPools) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumPools.Merge(m, src)
}
func (m *NumPools) XXX_Size() int {
	return m.Size()
}
func (m *NumPools) XXX_DiscardUnknown() {
	xxx_messageInfo_NumPools.DiscardUnknown(m)
}

var xxx_messageInfo_NumPools proto.InternalMessageInfo

func (m *NumPools) GetNumPools() uint64 {
	if m != nil {
		return m.NumPools
	}
	return 0
}

// RewardTokenInfo describes the status of a reward token in a pool
type RewardTokenInfo struct {
	RemainingAmount        types.DecCoin                          `protobuf:"bytes,1,opt,name=remaining_amount,json=remainingAmount,proto3" json:"remaining_amount" yaml:"remaining_amount"`
	RewardStartBlockHeight int64                                  `protobuf:"varint,2,opt,name=reward_start_block_height,json=rewardStartBlockHeight,proto3" json:"reward_start_block_height,omitempty" yaml:"reward_start_block_height"`
	RewardAmountPerBlock   github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=reward_amount_per_block,json=rewardAmountPerBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"reward_amount_per_block" yaml:"reward_amount_per_block"`
}

func (m *RewardTokenInfo) Reset()         { *m = RewardTokenInfo{} }
func (m *RewardTokenInfo) String() string { return proto.CompactTextString(m) }
func (*RewardTokenInfo) ProtoMessage()    {}
func (*RewardTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{3}
}
func (m *RewardTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardTokenInfo.Merge(m, src)
}
func (m *RewardTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *RewardTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RewardTokenInfo proto.InternalMessageInfo

func (m *RewardTokenInfo) GetRemainingAmount() types.DecCoin {
	if m != nil {
		return m.RemainingAmount
	}
	return types.DecCoin{}
}

func (m *RewardTokenInfo) GetRewardStartBlockHeight() int64 {
	if m != nil {
		return m.RewardStartBlockHeight
	}
	return 0
}

// StakeInfo describes the stake of a liquidity provider in a pool
type StakeInfo struct {
	StakerAddress    string        `protobuf:"bytes,1,opt,name=staker_address,json=stakerAddress,proto3" json:"staker_address,omitempty" yaml:"staker_address"`
	PoolName         string        `protobuf:"bytes,2,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	Amount           types.DecCoin `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount"`
	StartBlockHeight int64         `protobuf:"varint,4,opt,name=start_block_height,json=startBlockHeight,proto3" json:"start_block_height,omitempty" yaml:"start_block_height"`
	ReferencePeriod  uint64        `protobuf:"varint,5,opt,name=reference_period,json=referencePeriod,proto3" json:"reference_period,omitempty" yaml:"reference_period"`
}

func (m *StakeInfo) Reset()         { *m = StakeInfo{} }
func (m *StakeInfo) String() string { return proto.CompactTextString(m) }
func (*StakeInfo) ProtoMessage()    {}
func (*StakeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{4}
}
func (m *StakeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakeInfo.Merge(m, src)
}
func (m *StakeInfo) XXX_Size() int {
	return m.Size()
}
func (m *StakeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StakeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StakeInfo proto.InternalMessageInfo

func (m *StakeInfo) GetStakerAddress() string {
	if m != nil {
		return m.StakerAddress
	}
	return ""
}

func (m *StakeInfo) GetPoolName() string {
	if m != nil {
		return m.PoolName
	}
	return ""
}

func (m *StakeInfo) GetAmount() types.DecCoin {
	if m != nil {
		return m.Amount
	}
	return types.DecCoin{}
}

func (m *StakeInfo) GetStartBlockHeight() int64 {
	if m != nil {
		return m.StartBlockHeight
	}
	return 0
}

func (m *StakeInfo) GetReferencePeriod() uint64 {
	if m != nil {
		return m.ReferencePeriod
	}
	return 0
}

// PoolHistoricalRewards records the reward ratio of one liquidity provider account in a pool
type PoolHistoricalRewards struct {
	CumulativeRewardRatio github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,1,rep,name=cumulative_reward_ratio,json=cumulativeRewardRatio,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"cumulative_reward_ratio" yaml:"cumulative_reward_ratio"`
	ReferenceCount        uint32                                      `protobuf:"varint,2,opt,name=reference_count,json=referenceCount,proto3" json:"reference_count,omitempty" yaml:"reference_count"`
}

func (m *PoolHistoricalRewards) Reset()         { *m = PoolHistoricalRewards{} }
func (m *PoolHistoricalRewards) String() string { return proto.CompactTextString(m) }
func (*PoolHistoricalRewards) ProtoMessage()    {}
func (*PoolHistoricalRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{5}
}
func (m *PoolHistoricalRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolHistoricalRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolHistoricalRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolHistoricalRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolHistoricalRewards.Merge(m, src)
}
func (m *PoolHistoricalRewards) XXX_Size() int {
	return m.Size()
}
func (m *PoolHistoricalRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolHistoricalRewards.DiscardUnknown(m)
}

var xxx_messageInfo_PoolHistoricalRewards proto.InternalMessageInfo

func (m *PoolHistoricalRewards) GetCumulativeRewardRatio() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.CumulativeRewardRatio
	}
	return nil
}

func (m *PoolHistoricalRewards) GetReferenceCount() uint32 {
	if m != nil {
		return m.ReferenceCount
	}
	return 0
}

// PoolCurrentRewards records the rewards in the current period
type PoolCurrentRewards struct {
	StartBlockHeight int64                                       `protobuf:"varint,1,opt,name=start_block_height,json=startBlockHeight,proto3" json:"start_block_height,omitempty" yaml:"start_block_height"`
	Period           uint64                                      `protobuf:"varint,2,opt,name=period,proto3" json:"period,omitempty" yaml:"period"`
	Rewards          github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,3,rep,name=rewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"rewards" yaml:"rewards"`
}

func (m *PoolCurrentRewards) Reset()         { *m = PoolCurrentRewards{} }
func (m *PoolCurrentRewards) String() string { return proto.CompactTextString(m) }
func (*PoolCurrentRewards) ProtoMessage()    {}
func (*PoolCurrentRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{6}
}
func (m *PoolCurrentRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PoolCurrentRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PoolCurrentRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PoolCurrentRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PoolCurrentRewards.Merge(m, src)
}
func (m *PoolCurrentRewards) XXX_Size() int {
	return m.Size()
}
func (m *PoolCurrentRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_PoolCurrentRewards.DiscardUnknown(m)
}

var xxx_messageInfo_PoolCurrentRewards proto.InternalMessageInfo

func (m *PoolCurrentRewards) GetStartBlockHeight() int64 {
	if m != nil {
		return m.StartBlockHeight
	}
	return 0
}

func (m *PoolCurrentRewards) GetPeriod() uint64 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *PoolCurrentRewards) GetRewards() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.Rewards
	}
	return nil
}

// Earnings is the structure for an earnings query for one liquidity provider account in a pool
type Earnings struct {
	TargetBlockHeight int64                                       `protobuf:"varint,1,opt,name=target_block_height,json=targetBlockHeight,proto3" json:"target_block_height,omitempty" yaml:"target_block_height"`
	StakedAmount      types.DecCoin                               `protobuf:"bytes,2,opt,name=staked_amount,json=stakedAmount,proto3" json:"staked_amount" yaml:"staked_amount"`
	RewardAmount      github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,3,rep,name=reward_amount,json=rewardAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"reward_amount" yaml:"reward_amount"`
}

func (m *Earnings) Reset()         { *m = Earnings{} }
func (m *Earnings) String() string { return proto.CompactTextString(m) }
func (*Earnings) ProtoMessage()    {}
func (*Earnings) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{7}
}
func (m *Earnings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Earnings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Earnings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Earnings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Earnings.Merge(m, src)
}
func (m *Earnings) XXX_Size() int {
	return m.Size()
}
func (m *Earnings) XXX_DiscardUnknown() {
	xxx_messageInfo_Earnings.DiscardUnknown(m)
}

var xxx_messageInfo_Earnings proto.InternalMessageInfo

func (m *Earnings) GetTargetBlockHeight() int64 {
	if m != nil {
		return m.TargetBlockHeight
	}
	return 0
}

func (m *Earnings) GetStakedAmount() types.DecCoin {
	if m != nil {
		return m.StakedAmount
	}
	return types.DecCoin{}
}

func (m *Earnings) GetRewardAmount() github_com_cosmos_cosmos_sdk_types.DecCoins {
	if m != nil {
		return m.RewardAmount
	}
	return nil
}

// RewardAdjustmentInput describes the input to add / adjust a reward token in a pool
type RewardAdjustmentInput struct {
	AddAmount               types.DecCoin                          `protobuf:"bytes,1,opt,name=add_amount,json=addAmount,proto3" json:"add_amount" yaml:"add_amount"`
	RewardStartBlockDelay   int64                                  `protobuf:"varint,2,opt,name=reward_start_block_delay,json=rewardStartBlockDelay,proto3" json:"reward_start_block_delay,omitempty" yaml:"reward_start_block_delay"`
	NewRewardAmountPerBlock github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=new_reward_amount_per_block,json=newRewardAmountPerBlock,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"new_reward_amount_per_block" yaml:"new_reward_amount_per_block"`
}

func (m *RewardAdjustmentInput) Reset()         { *m = RewardAdjustmentInput{} }
func (m *RewardAdjustmentInput) String() string { return proto.CompactTextString(m) }
func (*RewardAdjustmentInput) ProtoMessage()    {}
func (*RewardAdjustmentInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{8}
}
func (m *RewardAdjustmentInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardAdjustmentInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardAdjustmentInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardAdjustmentInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardAdjustmentInput.Merge(m, src)
}
func (m *RewardAdjustmentInput) XXX_Size() int {
	return m.Size()
}
func (m *RewardAdjustmentInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardAdjustmentInput.DiscardUnknown(m)
}

var xxx_messageInfo_RewardAdjustmentInput proto.InternalMessageInfo

func (m *RewardAdjustmentInput) GetAddAmount() types.DecCoin {
	if m != nil {
		return m.AddAmount
	}
	return types.DecCoin{}
}

func (m *RewardAdjustmentInput) GetRewardStartBlockDelay() int64 {
	if m != nil {
		return m.RewardStartBlockDelay
	}
	return 0
}

// AddPoolProposal details a proposal to add a farming pool. If passed, it automatically registers
// the stake and reward tokens involved.
type AddPoolProposal struct {
	Title               string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description         string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName            string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	StakeToken          ERC20Token              `protobuf:"bytes,4,opt,name=stake_token,json=stakeToken,proto3" json:"stake_token" yaml:"stake_token"`
	RewardTokens        []ERC20Token            `protobuf:"bytes,5,rep,name=reward_tokens,json=rewardTokens,proto3" json:"reward_tokens" yaml:"reward_tokens"`
	InitialRewardInputs []RewardAdjustmentInput `protobuf:"bytes,6,rep,name=initial_reward_inputs,json=initialRewardInputs,proto3" json:"initial_reward_inputs" yaml:"initial_reward_inputs"`
}

func (m *AddPoolProposal) Reset()      { *m = AddPoolProposal{} }
func (*AddPoolProposal) ProtoMessage() {}
func (*AddPoolProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{9}
}
func (m *AddPoolProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPoolProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPoolProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPoolProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPoolProposal.Merge(m, src)
}
func (m *AddPoolProposal) XXX_Size() int {
	return m.Size()
}
func (m *AddPoolProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPoolProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AddPoolProposal proto.InternalMessageInfo

// AddPoolProposalWithDeposit defines an AddPoolProposal with a deposit, for CLI usage.
type AddPoolProposalWithDeposit struct {
	Title               string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description         string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName            string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	StakeToken          ERC20Token              `protobuf:"bytes,4,opt,name=stake_token,json=stakeToken,proto3" json:"stake_token" yaml:"stake_token"`
	RewardTokens        []ERC20Token            `protobuf:"bytes,5,rep,name=reward_tokens,json=rewardTokens,proto3" json:"reward_tokens" yaml:"reward_tokens"`
	InitialRewardInputs []RewardAdjustmentInput `protobuf:"bytes,6,rep,name=initial_reward_inputs,json=initialRewardInputs,proto3" json:"initial_reward_inputs" yaml:"initial_reward_inputs"`
	Deposit             string                  `protobuf:"bytes,7,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *AddPoolProposalWithDeposit) Reset()         { *m = AddPoolProposalWithDeposit{} }
func (m *AddPoolProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*AddPoolProposalWithDeposit) ProtoMessage()    {}
func (*AddPoolProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{10}
}
func (m *AddPoolProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPoolProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPoolProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPoolProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPoolProposalWithDeposit.Merge(m, src)
}
func (m *AddPoolProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *AddPoolProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPoolProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_AddPoolProposalWithDeposit proto.InternalMessageInfo

// AdjustRewardProposal details a proposal to adjust reward tokens in a pool.
type AdjustRewardProposal struct {
	Title                  string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description            string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName               string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	RewardAdjustmentInputs []RewardAdjustmentInput `protobuf:"bytes,4,rep,name=reward_adjustment_inputs,json=rewardAdjustmentInputs,proto3" json:"reward_adjustment_inputs" yaml:"reward_adjustment_inputs"`
}

func (m *AdjustRewardProposal) Reset()      { *m = AdjustRewardProposal{} }
func (*AdjustRewardProposal) ProtoMessage() {}
func (*AdjustRewardProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{11}
}
func (m *AdjustRewardProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdjustRewardProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdjustRewardProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdjustRewardProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustRewardProposal.Merge(m, src)
}
func (m *AdjustRewardProposal) XXX_Size() int {
	return m.Size()
}
func (m *AdjustRewardProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustRewardProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustRewardProposal proto.InternalMessageInfo

// AdjustRewardProposalWithDeposit defines an AdjustRewardProposal with a deposit, for CLI usage.
type AdjustRewardProposalWithDeposit struct {
	Title                  string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description            string                  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName               string                  `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	RewardAdjustmentInputs []RewardAdjustmentInput `protobuf:"bytes,4,rep,name=reward_adjustment_inputs,json=rewardAdjustmentInputs,proto3" json:"reward_adjustment_inputs" yaml:"reward_adjustment_inputs"`
	Deposit                string                  `protobuf:"bytes,5,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *AdjustRewardProposalWithDeposit) Reset()         { *m = AdjustRewardProposalWithDeposit{} }
func (m *AdjustRewardProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*AdjustRewardProposalWithDeposit) ProtoMessage()    {}
func (*AdjustRewardProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{12}
}
func (m *AdjustRewardProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdjustRewardProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdjustRewardProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdjustRewardProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdjustRewardProposalWithDeposit.Merge(m, src)
}
func (m *AdjustRewardProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *AdjustRewardProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_AdjustRewardProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_AdjustRewardProposalWithDeposit proto.InternalMessageInfo

// RemovePoolProposal details a proposal to remove a finished farming pool.
type RemovePoolProposal struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName    string `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
}

func (m *RemovePoolProposal) Reset()      { *m = RemovePoolProposal{} }
func (*RemovePoolProposal) ProtoMessage() {}
func (*RemovePoolProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{13}
}
func (m *RemovePoolProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemovePoolProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePoolProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemovePoolProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePoolProposal.Merge(m, src)
}
func (m *RemovePoolProposal) XXX_Size() int {
	return m.Size()
}
func (m *RemovePoolProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePoolProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePoolProposal proto.InternalMessageInfo

// RemovePoolProposalWithDeposit defines a RemovePoolProposal with a deposit, for CLI usage.
type RemovePoolProposalWithDeposit struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	PoolName    string `protobuf:"bytes,3,opt,name=pool_name,json=poolName,proto3" json:"pool_name,omitempty" yaml:"pool_name"`
	Deposit     string `protobuf:"bytes,4,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *RemovePoolProposalWithDeposit) Reset()         { *m = RemovePoolProposalWithDeposit{} }
func (m *RemovePoolProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*RemovePoolProposalWithDeposit) ProtoMessage()    {}
func (*RemovePoolProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{14}
}
func (m *RemovePoolProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemovePoolProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePoolProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemovePoolProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePoolProposalWithDeposit.Merge(m, src)
}
func (m *RemovePoolProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *RemovePoolProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePoolProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePoolProposalWithDeposit proto.InternalMessageInfo

// AddTokensProposal details a proposal to add new ERC20 tokens.
type AddTokensProposal struct {
	Title       string       `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	Tokens      []ERC20Token `protobuf:"bytes,3,rep,name=tokens,proto3" json:"tokens" yaml:"tokens"`
}

func (m *AddTokensProposal) Reset()      { *m = AddTokensProposal{} }
func (*AddTokensProposal) ProtoMessage() {}
func (*AddTokensProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{15}
}
func (m *AddTokensProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTokensProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTokensProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTokensProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTokensProposal.Merge(m, src)
}
func (m *AddTokensProposal) XXX_Size() int {
	return m.Size()
}
func (m *AddTokensProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTokensProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AddTokensProposal proto.InternalMessageInfo

// AddTokensProposalWithDeposit defines a AddTokensProposal with a deposit, for CLI usage.
type AddTokensProposalWithDeposit struct {
	Title       string       `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	Description string       `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	Tokens      []ERC20Token `protobuf:"bytes,3,rep,name=tokens,proto3" json:"tokens" yaml:"tokens"`
	Deposit     string       `protobuf:"bytes,4,opt,name=deposit,proto3" json:"deposit,omitempty" yaml:"deposit"`
}

func (m *AddTokensProposalWithDeposit) Reset()         { *m = AddTokensProposalWithDeposit{} }
func (m *AddTokensProposalWithDeposit) String() string { return proto.CompactTextString(m) }
func (*AddTokensProposalWithDeposit) ProtoMessage()    {}
func (*AddTokensProposalWithDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_159299d9ca2b2f07, []int{16}
}
func (m *AddTokensProposalWithDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTokensProposalWithDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTokensProposalWithDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTokensProposalWithDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTokensProposalWithDeposit.Merge(m, src)
}
func (m *AddTokensProposalWithDeposit) XXX_Size() int {
	return m.Size()
}
func (m *AddTokensProposalWithDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTokensProposalWithDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_AddTokensProposalWithDeposit proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ERC20Token)(nil), "sgn.farming.v1.ERC20Token")
	proto.RegisterType((*FarmingPool)(nil), "sgn.farming.v1.FarmingPool")
	proto.RegisterType((*NumPools)(nil), "sgn.farming.v1.NumPools")
	proto.RegisterType((*RewardTokenInfo)(nil), "sgn.farming.v1.RewardTokenInfo")
	proto.RegisterType((*StakeInfo)(nil), "sgn.farming.v1.StakeInfo")
	proto.RegisterType((*PoolHistoricalRewards)(nil), "sgn.farming.v1.PoolHistoricalRewards")
	proto.RegisterType((*PoolCurrentRewards)(nil), "sgn.farming.v1.PoolCurrentRewards")
	proto.RegisterType((*Earnings)(nil), "sgn.farming.v1.Earnings")
	proto.RegisterType((*RewardAdjustmentInput)(nil), "sgn.farming.v1.RewardAdjustmentInput")
	proto.RegisterType((*AddPoolProposal)(nil), "sgn.farming.v1.AddPoolProposal")
	proto.RegisterType((*AddPoolProposalWithDeposit)(nil), "sgn.farming.v1.AddPoolProposalWithDeposit")
	proto.RegisterType((*AdjustRewardProposal)(nil), "sgn.farming.v1.AdjustRewardProposal")
	proto.RegisterType((*AdjustRewardProposalWithDeposit)(nil), "sgn.farming.v1.AdjustRewardProposalWithDeposit")
	proto.RegisterType((*RemovePoolProposal)(nil), "sgn.farming.v1.RemovePoolProposal")
	proto.RegisterType((*RemovePoolProposalWithDeposit)(nil), "sgn.farming.v1.RemovePoolProposalWithDeposit")
	proto.RegisterType((*AddTokensProposal)(nil), "sgn.farming.v1.AddTokensProposal")
	proto.RegisterType((*AddTokensProposalWithDeposit)(nil), "sgn.farming.v1.AddTokensProposalWithDeposit")
}

func init() { proto.RegisterFile("sgn/farming/v1/farming.proto", fileDescriptor_159299d9ca2b2f07) }

var fileDescriptor_159299d9ca2b2f07 = []byte{
	// 1451 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6f, 0x1b, 0x45,
	0x1b, 0xf7, 0xda, 0xce, 0xd7, 0x93, 0xef, 0x49, 0xdc, 0x38, 0x6e, 0xea, 0xcd, 0x3b, 0x6f, 0xdf,
	0x7e, 0xe8, 0xa5, 0x36, 0x09, 0x17, 0x94, 0x13, 0x71, 0xda, 0xaa, 0x51, 0x45, 0x15, 0x4d, 0x0b,
	0x95, 0x10, 0x68, 0xb5, 0xf1, 0x4e, 0x9c, 0x25, 0xf6, 0x8e, 0xb5, 0x33, 0x4e, 0xc8, 0x01, 0x71,
	0xe0, 0x40, 0x05, 0x12, 0x42, 0x95, 0x90, 0x38, 0x56, 0x9c, 0x10, 0x9c, 0x38, 0xf1, 0x0f, 0x70,
	0xe8, 0x01, 0xa1, 0x72, 0x43, 0x1c, 0x0c, 0x4a, 0x25, 0xc4, 0x01, 0x2e, 0xbe, 0x71, 0x43, 0x3b,
	0x33, 0x6b, 0xaf, 0x37, 0x6e, 0xb0, 0xab, 0xaa, 0x8a, 0x10, 0x27, 0xef, 0x3e, 0xcf, 0x33, 0xcf,
	0x3c, 0xf3, 0xfb, 0x3d, 0x1f, 0xe3, 0x85, 0x25, 0x5e, 0xf1, 0x8a, 0x3b, 0xb6, 0x5f, 0x73, 0xbd,
	0x4a, 0x71, 0x7f, 0x25, 0x7c, 0x2c, 0xd4, 0x7d, 0x26, 0x18, 0x9a, 0xe2, 0x15, 0xaf, 0x10, 0x8a,
	0xf6, 0x57, 0x72, 0xf3, 0x15, 0x56, 0x61, 0x52, 0x55, 0x0c, 0x9e, 0x94, 0x55, 0x2e, 0x5f, 0x66,
	0xbc, 0xc6, 0x78, 0x71, 0xdb, 0xe6, 0xb4, 0xb8, 0xbf, 0xb2, 0x4d, 0x85, 0xbd, 0x52, 0x2c, 0x33,
	0xd7, 0x53, 0x7a, 0xfc, 0xa9, 0x01, 0x70, 0x8d, 0x6c, 0xac, 0xbe, 0x78, 0x87, 0xed, 0x51, 0x0f,
	0x15, 0x60, 0xb4, 0xbc, 0x6b, 0xbb, 0x9e, 0xe5, 0x3a, 0x59, 0x63, 0xd9, 0xb8, 0x94, 0x2e, 0xcd,
	0xb5, 0x9a, 0xe6, 0xf4, 0xa1, 0x5d, 0xab, 0xae, 0xe1, 0x50, 0x83, 0xc9, 0x88, 0x7c, 0xdc, 0x74,
	0xd0, 0x65, 0x18, 0xe6, 0x87, 0xb5, 0x6d, 0x56, 0xcd, 0x26, 0x97, 0x8d, 0x4b, 0x63, 0xa5, 0xd9,
	0x56, 0xd3, 0x9c, 0x54, 0xd6, 0x4a, 0x8e, 0x89, 0x36, 0x40, 0x2f, 0xc0, 0x88, 0xed, 0x38, 0x3e,
	0xe5, 0x3c, 0x9b, 0x92, 0xb6, 0xa8, 0xd5, 0x34, 0xa7, 0x94, 0xad, 0x56, 0x60, 0x12, 0x9a, 0xe0,
	0xfb, 0x69, 0x18, 0xbf, 0xae, 0x0e, 0xb7, 0xc5, 0x58, 0x15, 0x21, 0x48, 0x7b, 0x76, 0x8d, 0xca,
	0xa0, 0xc6, 0x88, 0x7c, 0x46, 0x77, 0x61, 0x9c, 0x0b, 0x7b, 0x8f, 0x5a, 0x22, 0x88, 0x5d, 0x46,
	0x30, 0xbe, 0x9a, 0x2b, 0x74, 0xe3, 0x52, 0xe8, 0x9c, 0xae, 0x94, 0x7b, 0xd8, 0x34, 0x13, 0xad,
	0xa6, 0x89, 0x74, 0x84, 0x9d, 0xc5, 0x98, 0x80, 0x7c, 0x53, 0x28, 0xd4, 0x61, 0x4e, 0x30, 0x61,
	0x57, 0x2d, 0x29, 0x73, 0x2c, 0xbb, 0xc6, 0x1a, 0x9e, 0x90, 0x61, 0x8f, 0xaf, 0x2e, 0x15, 0x14,
	0xa4, 0x85, 0x00, 0xd2, 0x82, 0x86, 0xb4, 0x70, 0x95, 0x96, 0x37, 0x98, 0xeb, 0x95, 0xb0, 0xde,
	0x22, 0xa7, 0xb6, 0xe8, 0xe1, 0x06, 0x93, 0x59, 0x29, 0xbd, 0x2d, 0x85, 0xeb, 0x52, 0x86, 0xea,
	0x80, 0x7c, 0x7a, 0x60, 0xfb, 0x8e, 0x0a, 0xc7, 0x72, 0xbd, 0x1d, 0xc6, 0xb3, 0xe9, 0xe5, 0xd4,
	0xa5, 0xf1, 0x55, 0x33, 0x7e, 0x22, 0x22, 0x2d, 0x65, 0xa8, 0x9b, 0xde, 0x0e, 0x2b, 0xfd, 0x47,
	0xef, 0xb9, 0xa8, 0xf6, 0x3c, 0xee, 0x08, 0x93, 0x19, 0xbf, 0x7b, 0x0d, 0x47, 0x5f, 0x1b, 0xb0,
	0xa8, 0xa2, 0xb3, 0xcb, 0xe5, 0x46, 0xad, 0x51, 0xb5, 0x05, 0x75, 0x2c, 0x65, 0xc6, 0xb3, 0x43,
	0x72, 0xe7, 0x93, 0x8f, 0x7a, 0x57, 0x6f, 0xbb, 0x1c, 0x3d, 0x6a, 0x0f, 0x67, 0xf8, 0xcb, 0x9f,
	0xcd, 0xff, 0x57, 0x5c, 0xb1, 0xdb, 0xd8, 0x2e, 0x94, 0x59, 0xad, 0xa8, 0x33, 0x52, 0xfd, 0x5c,
	0xe1, 0xce, 0x5e, 0x51, 0x1c, 0xd6, 0x29, 0x0f, 0xfd, 0x72, 0xb2, 0x20, 0x5d, 0xad, 0x77, 0x3c,
	0x11, 0xed, 0xe8, 0x22, 0x8c, 0xde, 0x6a, 0xd4, 0x82, 0x7c, 0xe0, 0xe8, 0x2c, 0x8c, 0x79, 0x8d,
	0x9a, 0x55, 0x0f, 0x5e, 0x54, 0xaa, 0x92, 0x51, 0x4f, 0x2b, 0xf1, 0xaf, 0x49, 0x98, 0x8e, 0xa1,
	0x84, 0x76, 0x61, 0xc6, 0xa7, 0x35, 0xdb, 0xf5, 0x5c, 0xaf, 0x12, 0x32, 0x6a, 0xf4, 0xc1, 0xa8,
	0xa9, 0x8f, 0xb9, 0x10, 0xa2, 0xdb, 0xed, 0x03, 0x93, 0xe9, 0xb6, 0x48, 0x93, 0x69, 0xc1, 0xa2,
	0xe6, 0x80, 0x0b, 0xdb, 0x17, 0xd6, 0x76, 0x95, 0x95, 0xf7, 0xac, 0x5d, 0xea, 0x56, 0x76, 0x85,
	0xcc, 0xd2, 0x54, 0xe9, 0x7c, 0x07, 0xb7, 0x27, 0x9a, 0x62, 0x72, 0x46, 0xe9, 0x6e, 0x07, 0xaa,
	0x52, 0xa0, 0xb9, 0x21, 0x15, 0xe8, 0x03, 0x03, 0x16, 0xf4, 0x32, 0x15, 0x84, 0x55, 0xa7, 0xbe,
	0x5a, 0xab, 0x6b, 0x6b, 0x2b, 0x08, 0xfa, 0xa7, 0xa6, 0x79, 0xa1, 0x3f, 0xdc, 0x5b, 0x4d, 0x33,
	0xdf, 0x15, 0x4d, 0xdc, 0x2d, 0x26, 0xf3, 0x4a, 0xa3, 0x8e, 0xb8, 0x45, 0x7d, 0x19, 0x0f, 0xfe,
	0x21, 0x09, 0x63, 0x32, 0x91, 0x25, 0xc4, 0xaf, 0xc0, 0x94, 0x4c, 0x75, 0xdf, 0x0a, 0x2b, 0x5d,
	0x96, 0x6b, 0x69, 0xb1, 0xd5, 0x34, 0x33, 0x91, 0x9a, 0x6b, 0xeb, 0x31, 0x99, 0x54, 0x82, 0x75,
	0xf5, 0x8e, 0x56, 0x60, 0x2c, 0x60, 0xd4, 0x92, 0xb5, 0xae, 0x5a, 0xca, 0x7c, 0xab, 0x69, 0xce,
	0xa8, 0xc5, 0x6d, 0x15, 0x26, 0xa3, 0xc1, 0xf3, 0xad, 0xa0, 0x0b, 0xac, 0xc1, 0xf0, 0x00, 0xf5,
	0x99, 0x0e, 0x80, 0x21, 0x7a, 0x05, 0xba, 0x09, 0xa8, 0x07, 0x45, 0x69, 0x49, 0xd1, 0xb9, 0x4e,
	0x45, 0xf5, 0xe2, 0x66, 0x86, 0xc7, 0x59, 0xb9, 0x1e, 0x24, 0xd8, 0x0e, 0xf5, 0xa9, 0x57, 0xa6,
	0x01, 0x72, 0x2e, 0x73, 0xb2, 0x43, 0xb2, 0x87, 0x9e, 0x8d, 0xa6, 0x4f, 0xb7, 0x85, 0x4c, 0x1f,
	0x2d, 0xda, 0x52, 0x92, 0x0f, 0x93, 0x90, 0x09, 0xd2, 0xf8, 0x86, 0xcb, 0x05, 0xf3, 0xdd, 0xb2,
	0x5d, 0xd5, 0xf9, 0x8f, 0xbe, 0x32, 0x60, 0x41, 0x17, 0x85, 0xbb, 0x4f, 0x75, 0x7d, 0x59, 0xbe,
	0x2d, 0x5c, 0x96, 0x35, 0xfa, 0xa8, 0xd8, 0xd7, 0x74, 0x2a, 0x6b, 0xae, 0x9f, 0xe0, 0x6a, 0xe0,
	0x7a, 0xcd, 0x74, 0x1c, 0xa9, 0x48, 0x49, 0xe0, 0x06, 0x6d, 0x40, 0xe7, 0x68, 0x56, 0x59, 0x32,
	0x14, 0x30, 0x3a, 0x59, 0xca, 0xb5, 0x9a, 0xe6, 0x99, 0x38, 0x1c, 0x65, 0x55, 0x4c, 0x53, 0x6d,
	0xc9, 0x86, 0x14, 0x7c, 0x94, 0x04, 0x14, 0x80, 0xb1, 0xd1, 0xf0, 0x7d, 0xea, 0x89, 0x10, 0x89,
	0xde, 0xc4, 0x19, 0x4f, 0x47, 0xdc, 0x65, 0x18, 0xd6, 0x74, 0x25, 0x25, 0x5d, 0x91, 0x21, 0x16,
	0x92, 0xa4, 0x0d, 0xd0, 0xbb, 0x30, 0x12, 0xb6, 0xc8, 0x54, 0x1f, 0x80, 0x5f, 0xd3, 0x80, 0x4f,
	0x45, 0x8b, 0x6b, 0xf0, 0x86, 0x18, 0xee, 0x89, 0xbf, 0x4b, 0xc2, 0xe8, 0x35, 0xdb, 0x0f, 0x7a,
	0x0d, 0x47, 0xb7, 0x60, 0x4e, 0xd8, 0x7e, 0x85, 0xf6, 0x04, 0x21, 0x1f, 0x99, 0x41, 0xc7, 0x8d,
	0x82, 0x19, 0x24, 0xa5, 0x51, 0x18, 0x2c, 0x98, 0xec, 0x9e, 0x77, 0xc9, 0x3e, 0xea, 0x69, 0x49,
	0x9f, 0x70, 0x3e, 0x52, 0xde, 0x9d, 0x49, 0x37, 0xc1, 0xa3, 0x43, 0xee, 0x63, 0x03, 0x26, 0xbb,
	0xfa, 0x4b, 0x5f, 0x18, 0xde, 0xec, 0xde, 0xa1, 0xcb, 0xc1, 0xc0, 0x48, 0x4e, 0x44, 0xbb, 0x18,
	0x3e, 0x4a, 0x42, 0x46, 0x65, 0xd4, 0xba, 0xf3, 0x76, 0x83, 0x8b, 0x1a, 0xf5, 0xc4, 0xa6, 0x57,
	0x6f, 0x08, 0xf4, 0x3a, 0x80, 0xed, 0x38, 0x83, 0x8c, 0x89, 0x45, 0x1d, 0xe6, 0x6c, 0xfb, 0x46,
	0xd3, 0x46, 0x61, 0xcc, 0x76, 0x42, 0x08, 0xde, 0x84, 0x6c, 0x8f, 0x7e, 0xef, 0xd0, 0xaa, 0x7d,
	0xa8, 0x27, 0xc3, 0x7f, 0x5b, 0x4d, 0xd3, 0x7c, 0xe2, 0x64, 0x90, 0x96, 0x98, 0x64, 0xe2, 0x83,
	0xe1, 0x6a, 0x20, 0x47, 0xf7, 0x0d, 0x38, 0xeb, 0xd1, 0x03, 0xeb, 0xe4, 0xd9, 0x70, 0x67, 0xe0,
	0xd9, 0x80, 0x55, 0x3c, 0x27, 0xb8, 0xc6, 0x64, 0xc1, 0xa3, 0x07, 0xa4, 0xd7, 0x88, 0xf8, 0x23,
	0x05, 0xd3, 0xeb, 0x8e, 0x13, 0x14, 0xf1, 0x96, 0xcf, 0xea, 0x8c, 0xdb, 0x55, 0x74, 0x01, 0x86,
	0x84, 0x2b, 0xaa, 0xfa, 0x3a, 0x57, 0x9a, 0x69, 0x35, 0xcd, 0x09, 0x9d, 0xac, 0x81, 0x18, 0x13,
	0xa5, 0x46, 0x2f, 0xc3, 0xb8, 0x43, 0x79, 0xd9, 0x77, 0xeb, 0xc2, 0x65, 0x9e, 0x1e, 0x08, 0x67,
	0x3a, 0x37, 0xb8, 0x88, 0x12, 0x93, 0xa8, 0x69, 0xf7, 0x20, 0x49, 0xf5, 0x35, 0x48, 0x62, 0xd7,
	0xc9, 0xf4, 0x33, 0xbb, 0x4e, 0xbe, 0xd5, 0x4e, 0x7b, 0xa9, 0x0c, 0x6f, 0x57, 0x27, 0xb9, 0x5e,
	0xea, 0x99, 0xf4, 0x6a, 0x39, 0x0e, 0xb3, 0x58, 0x9a, 0x72, 0xf4, 0x1e, 0x64, 0x5c, 0xcf, 0x15,
	0xae, 0x5d, 0x0d, 0xd9, 0x71, 0x83, 0x1c, 0xe6, 0xd9, 0x61, 0xb9, 0xcd, 0xff, 0x7a, 0x5f, 0x1f,
	0x63, 0x19, 0x5f, 0x3a, 0xaf, 0x77, 0x5c, 0x52, 0x3b, 0xf6, 0xf4, 0x88, 0xc9, 0x9c, 0x96, 0x2b,
	0x1f, 0x72, 0x25, 0x5f, 0x9b, 0xb8, 0xf7, 0xc0, 0x4c, 0x7c, 0xf6, 0xc0, 0x4c, 0xfc, 0xf6, 0xc0,
	0x4c, 0xe0, 0xcf, 0xd3, 0x90, 0x8b, 0xf1, 0x7d, 0xd7, 0x15, 0xbb, 0x57, 0x69, 0x9d, 0x71, 0x57,
	0xfc, 0x4b, 0xfd, 0x3f, 0x89, 0xfa, 0xe0, 0x4f, 0x9d, 0xa3, 0x88, 0xcd, 0x8e, 0xc4, 0xff, 0xd4,
	0x69, 0x05, 0x26, 0xa1, 0xc9, 0xda, 0xa8, 0x4e, 0x14, 0x03, 0x7f, 0x9b, 0x84, 0x79, 0x15, 0x86,
	0x72, 0x77, 0xba, 0x3b, 0xc3, 0x3d, 0xa3, 0xdd, 0xb6, 0xed, 0x36, 0x76, 0x21, 0xd4, 0xe9, 0x41,
	0xa0, 0xbe, 0xa8, 0xa1, 0xee, 0xee, 0xf0, 0xc7, 0x9c, 0xb6, 0xaf, 0xfe, 0xb1, 0xf5, 0xf1, 0x5a,
	0xfb, 0x33, 0x09, 0x66, 0x2f, 0x18, 0x4f, 0x7d, 0xc1, 0x9d, 0x1e, 0x44, 0xa3, 0x29, 0x3c, 0x34,
	0x48, 0x0a, 0x7f, 0x63, 0x00, 0x22, 0xb4, 0xc6, 0xf6, 0xe9, 0xa9, 0x1f, 0x6d, 0xb1, 0xac, 0xf9,
	0xdd, 0x80, 0x73, 0xc7, 0x23, 0x3f, 0xf5, 0x39, 0x13, 0x21, 0x2a, 0x3d, 0x08, 0x51, 0xdf, 0x1b,
	0x30, 0xbb, 0xee, 0xe8, 0x96, 0xf9, 0x1c, 0x79, 0xda, 0x84, 0x61, 0xdd, 0xf4, 0x53, 0x7f, 0xdb,
	0xf4, 0x33, 0x3a, 0x8b, 0x27, 0xc3, 0x6f, 0x29, 0xaa, 0xdb, 0x6b, 0x07, 0x31, 0xfe, 0xde, 0x4f,
	0xc2, 0xd2, 0xb1, 0x03, 0x3d, 0x5f, 0xfa, 0x9e, 0xdd, 0xd9, 0x9e, 0x96, 0xd6, 0xd2, 0xab, 0x5f,
	0x1c, 0xe5, 0x8d, 0x87, 0x47, 0x79, 0xe3, 0xd1, 0x51, 0xde, 0xf8, 0xe5, 0x28, 0x6f, 0x7c, 0xf2,
	0x38, 0x9f, 0x78, 0xf4, 0x38, 0x9f, 0xf8, 0xf1, 0x71, 0x3e, 0xf1, 0x46, 0x31, 0x7a, 0xb9, 0xa5,
	0x55, 0xea, 0x5f, 0xf1, 0xa8, 0x38, 0x60, 0xfe, 0x5e, 0x91, 0x57, 0xbc, 0x2b, 0xfb, 0xab, 0xc5,
	0x77, 0xda, 0x5f, 0x56, 0xe5, 0x4d, 0x77, 0x7b, 0x58, 0x7e, 0x0f, 0x7d, 0xe9, 0xaf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x6f, 0x97, 0x9f, 0x11, 0x75, 0x15, 0x00, 0x00,
}

func (this *ERC20Token) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ERC20Token)
	if !ok {
		that2, ok := that.(ERC20Token)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	if this.Symbol != that1.Symbol {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *FarmingPool) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FarmingPool)
	if !ok {
		that2, ok := that.(FarmingPool)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !this.StakeToken.Equal(&that1.StakeToken) {
		return false
	}
	if !this.TotalStakedAmount.Equal(&that1.TotalStakedAmount) {
		return false
	}
	if len(this.RewardTokenInfos) != len(that1.RewardTokenInfos) {
		return false
	}
	for i := range this.RewardTokenInfos {
		if !this.RewardTokenInfos[i].Equal(&that1.RewardTokenInfos[i]) {
			return false
		}
	}
	if len(this.TotalAccumulatedRewards) != len(that1.TotalAccumulatedRewards) {
		return false
	}
	for i := range this.TotalAccumulatedRewards {
		if !this.TotalAccumulatedRewards[i].Equal(&that1.TotalAccumulatedRewards[i]) {
			return false
		}
	}
	return true
}
func (this *NumPools) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NumPools)
	if !ok {
		that2, ok := that.(NumPools)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NumPools != that1.NumPools {
		return false
	}
	return true
}
func (this *RewardTokenInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardTokenInfo)
	if !ok {
		that2, ok := that.(RewardTokenInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RemainingAmount.Equal(&that1.RemainingAmount) {
		return false
	}
	if this.RewardStartBlockHeight != that1.RewardStartBlockHeight {
		return false
	}
	if !this.RewardAmountPerBlock.Equal(that1.RewardAmountPerBlock) {
		return false
	}
	return true
}
func (this *StakeInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StakeInfo)
	if !ok {
		that2, ok := that.(StakeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StakerAddress != that1.StakerAddress {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if !this.Amount.Equal(&that1.Amount) {
		return false
	}
	if this.StartBlockHeight != that1.StartBlockHeight {
		return false
	}
	if this.ReferencePeriod != that1.ReferencePeriod {
		return false
	}
	return true
}
func (this *PoolHistoricalRewards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PoolHistoricalRewards)
	if !ok {
		that2, ok := that.(PoolHistoricalRewards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.CumulativeRewardRatio) != len(that1.CumulativeRewardRatio) {
		return false
	}
	for i := range this.CumulativeRewardRatio {
		if !this.CumulativeRewardRatio[i].Equal(&that1.CumulativeRewardRatio[i]) {
			return false
		}
	}
	if this.ReferenceCount != that1.ReferenceCount {
		return false
	}
	return true
}
func (this *PoolCurrentRewards) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PoolCurrentRewards)
	if !ok {
		that2, ok := that.(PoolCurrentRewards)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StartBlockHeight != that1.StartBlockHeight {
		return false
	}
	if this.Period != that1.Period {
		return false
	}
	if len(this.Rewards) != len(that1.Rewards) {
		return false
	}
	for i := range this.Rewards {
		if !this.Rewards[i].Equal(&that1.Rewards[i]) {
			return false
		}
	}
	return true
}
func (this *Earnings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Earnings)
	if !ok {
		that2, ok := that.(Earnings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TargetBlockHeight != that1.TargetBlockHeight {
		return false
	}
	if !this.StakedAmount.Equal(&that1.StakedAmount) {
		return false
	}
	if len(this.RewardAmount) != len(that1.RewardAmount) {
		return false
	}
	for i := range this.RewardAmount {
		if !this.RewardAmount[i].Equal(&that1.RewardAmount[i]) {
			return false
		}
	}
	return true
}
func (this *RewardAdjustmentInput) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardAdjustmentInput)
	if !ok {
		that2, ok := that.(RewardAdjustmentInput)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AddAmount.Equal(&that1.AddAmount) {
		return false
	}
	if this.RewardStartBlockDelay != that1.RewardStartBlockDelay {
		return false
	}
	if !this.NewRewardAmountPerBlock.Equal(that1.NewRewardAmountPerBlock) {
		return false
	}
	return true
}
func (this *AddPoolProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddPoolProposalWithDeposit)
	if !ok {
		that2, ok := that.(AddPoolProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if !this.StakeToken.Equal(&that1.StakeToken) {
		return false
	}
	if len(this.RewardTokens) != len(that1.RewardTokens) {
		return false
	}
	for i := range this.RewardTokens {
		if !this.RewardTokens[i].Equal(&that1.RewardTokens[i]) {
			return false
		}
	}
	if len(this.InitialRewardInputs) != len(that1.InitialRewardInputs) {
		return false
	}
	for i := range this.InitialRewardInputs {
		if !this.InitialRewardInputs[i].Equal(&that1.InitialRewardInputs[i]) {
			return false
		}
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (this *AdjustRewardProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AdjustRewardProposalWithDeposit)
	if !ok {
		that2, ok := that.(AdjustRewardProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if len(this.RewardAdjustmentInputs) != len(that1.RewardAdjustmentInputs) {
		return false
	}
	for i := range this.RewardAdjustmentInputs {
		if !this.RewardAdjustmentInputs[i].Equal(&that1.RewardAdjustmentInputs[i]) {
			return false
		}
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (this *RemovePoolProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemovePoolProposalWithDeposit)
	if !ok {
		that2, ok := that.(RemovePoolProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.PoolName != that1.PoolName {
		return false
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (this *AddTokensProposalWithDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AddTokensProposalWithDeposit)
	if !ok {
		that2, ok := that.(AddTokensProposalWithDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Tokens) != len(that1.Tokens) {
		return false
	}
	for i := range this.Tokens {
		if !this.Tokens[i].Equal(&that1.Tokens[i]) {
			return false
		}
	}
	if this.Deposit != that1.Deposit {
		return false
	}
	return true
}
func (m *ERC20Token) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERC20Token) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERC20Token) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FarmingPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FarmingPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FarmingPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalAccumulatedRewards) > 0 {
		for iNdEx := len(m.TotalAccumulatedRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalAccumulatedRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RewardTokenInfos) > 0 {
		for iNdEx := len(m.RewardTokenInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardTokenInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.TotalStakedAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.StakeToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NumPools) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumPools) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NumPools) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumPools != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.NumPools))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.RewardAmountPerBlock.Size()
		i -= size
		if _, err := m.RewardAmountPerBlock.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RewardStartBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.RewardStartBlockHeight))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.RemainingAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StakeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReferencePeriod != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.ReferencePeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.StartBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.StartBlockHeight))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerAddress) > 0 {
		i -= len(m.StakerAddress)
		copy(dAtA[i:], m.StakerAddress)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.StakerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PoolHistoricalRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolHistoricalRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolHistoricalRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReferenceCount != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.ReferenceCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.CumulativeRewardRatio) > 0 {
		for iNdEx := len(m.CumulativeRewardRatio) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CumulativeRewardRatio[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PoolCurrentRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolCurrentRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PoolCurrentRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Period != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.Period))
		i--
		dAtA[i] = 0x10
	}
	if m.StartBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.StartBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Earnings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Earnings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Earnings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardAmount) > 0 {
		for iNdEx := len(m.RewardAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.StakedAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TargetBlockHeight != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.TargetBlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RewardAdjustmentInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardAdjustmentInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardAdjustmentInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NewRewardAmountPerBlock.Size()
		i -= size
		if _, err := m.NewRewardAmountPerBlock.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.RewardStartBlockDelay != 0 {
		i = encodeVarintFarming(dAtA, i, uint64(m.RewardStartBlockDelay))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.AddAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddPoolProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPoolProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPoolProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InitialRewardInputs) > 0 {
		for iNdEx := len(m.InitialRewardInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitialRewardInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RewardTokens) > 0 {
		for iNdEx := len(m.RewardTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.StakeToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddPoolProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPoolProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPoolProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.InitialRewardInputs) > 0 {
		for iNdEx := len(m.InitialRewardInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InitialRewardInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RewardTokens) > 0 {
		for iNdEx := len(m.RewardTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.StakeToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFarming(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdjustRewardProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdjustRewardProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdjustRewardProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardAdjustmentInputs) > 0 {
		for iNdEx := len(m.RewardAdjustmentInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardAdjustmentInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdjustRewardProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdjustRewardProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdjustRewardProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RewardAdjustmentInputs) > 0 {
		for iNdEx := len(m.RewardAdjustmentInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardAdjustmentInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemovePoolProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePoolProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePoolProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemovePoolProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePoolProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePoolProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PoolName) > 0 {
		i -= len(m.PoolName)
		copy(dAtA[i:], m.PoolName)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.PoolName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddTokensProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTokensProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTokensProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddTokensProposalWithDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTokensProposalWithDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTokensProposalWithDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		i -= len(m.Deposit)
		copy(dAtA[i:], m.Deposit)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Deposit)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Tokens) > 0 {
		for iNdEx := len(m.Tokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFarming(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFarming(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFarming(dAtA []byte, offset int, v uint64) int {
	offset -= sovFarming(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ERC20Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovFarming(uint64(m.ChainId))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *FarmingPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.StakeToken.Size()
	n += 1 + l + sovFarming(uint64(l))
	l = m.TotalStakedAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardTokenInfos) > 0 {
		for _, e := range m.RewardTokenInfos {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.TotalAccumulatedRewards) > 0 {
		for _, e := range m.TotalAccumulatedRewards {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *NumPools) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumPools != 0 {
		n += 1 + sovFarming(uint64(m.NumPools))
	}
	return n
}

func (m *RewardTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.RemainingAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if m.RewardStartBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.RewardStartBlockHeight))
	}
	l = m.RewardAmountPerBlock.Size()
	n += 1 + l + sovFarming(uint64(l))
	return n
}

func (m *StakeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerAddress)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if m.StartBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.StartBlockHeight))
	}
	if m.ReferencePeriod != 0 {
		n += 1 + sovFarming(uint64(m.ReferencePeriod))
	}
	return n
}

func (m *PoolHistoricalRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CumulativeRewardRatio) > 0 {
		for _, e := range m.CumulativeRewardRatio {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if m.ReferenceCount != 0 {
		n += 1 + sovFarming(uint64(m.ReferenceCount))
	}
	return n
}

func (m *PoolCurrentRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.StartBlockHeight))
	}
	if m.Period != 0 {
		n += 1 + sovFarming(uint64(m.Period))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *Earnings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetBlockHeight != 0 {
		n += 1 + sovFarming(uint64(m.TargetBlockHeight))
	}
	l = m.StakedAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardAmount) > 0 {
		for _, e := range m.RewardAmount {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *RewardAdjustmentInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.AddAmount.Size()
	n += 1 + l + sovFarming(uint64(l))
	if m.RewardStartBlockDelay != 0 {
		n += 1 + sovFarming(uint64(m.RewardStartBlockDelay))
	}
	l = m.NewRewardAmountPerBlock.Size()
	n += 1 + l + sovFarming(uint64(l))
	return n
}

func (m *AddPoolProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.StakeToken.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardTokens) > 0 {
		for _, e := range m.RewardTokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.InitialRewardInputs) > 0 {
		for _, e := range m.InitialRewardInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *AddPoolProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = m.StakeToken.Size()
	n += 1 + l + sovFarming(uint64(l))
	if len(m.RewardTokens) > 0 {
		for _, e := range m.RewardTokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	if len(m.InitialRewardInputs) > 0 {
		for _, e := range m.InitialRewardInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *AdjustRewardProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.RewardAdjustmentInputs) > 0 {
		for _, e := range m.RewardAdjustmentInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *AdjustRewardProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.RewardAdjustmentInputs) > 0 {
		for _, e := range m.RewardAdjustmentInputs {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *RemovePoolProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *RemovePoolProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.PoolName)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func (m *AddTokensProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	return n
}

func (m *AddTokensProposalWithDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	if len(m.Tokens) > 0 {
		for _, e := range m.Tokens {
			l = e.Size()
			n += 1 + l + sovFarming(uint64(l))
		}
	}
	l = len(m.Deposit)
	if l > 0 {
		n += 1 + l + sovFarming(uint64(l))
	}
	return n
}

func sovFarming(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFarming(x uint64) (n int) {
	return sovFarming(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ERC20Token) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERC20Token: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERC20Token: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FarmingPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FarmingPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FarmingPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStakedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalStakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTokenInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTokenInfos = append(m.RewardTokenInfos, RewardTokenInfo{})
			if err := m.RewardTokenInfos[len(m.RewardTokenInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAccumulatedRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAccumulatedRewards = append(m.TotalAccumulatedRewards, types.DecCoin{})
			if err := m.TotalAccumulatedRewards[len(m.TotalAccumulatedRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumPools) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumPools: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumPools: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPools", wireType)
			}
			m.NumPools = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPools |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemainingAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardStartBlockHeight", wireType)
			}
			m.RewardStartBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardStartBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmountPerBlock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewardAmountPerBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlockHeight", wireType)
			}
			m.StartBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencePeriod", wireType)
			}
			m.ReferencePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferencePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolHistoricalRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolHistoricalRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolHistoricalRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeRewardRatio", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CumulativeRewardRatio = append(m.CumulativeRewardRatio, types.DecCoin{})
			if err := m.CumulativeRewardRatio[len(m.CumulativeRewardRatio)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceCount", wireType)
			}
			m.ReferenceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReferenceCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolCurrentRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolCurrentRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolCurrentRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBlockHeight", wireType)
			}
			m.StartBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Period", wireType)
			}
			m.Period = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Period |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, types.DecCoin{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Earnings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Earnings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Earnings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetBlockHeight", wireType)
			}
			m.TargetBlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetBlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAmount = append(m.RewardAmount, types.DecCoin{})
			if err := m.RewardAmount[len(m.RewardAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardAdjustmentInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardAdjustmentInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardAdjustmentInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardStartBlockDelay", wireType)
			}
			m.RewardStartBlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardStartBlockDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRewardAmountPerBlock", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NewRewardAmountPerBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPoolProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPoolProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPoolProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTokens = append(m.RewardTokens, ERC20Token{})
			if err := m.RewardTokens[len(m.RewardTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialRewardInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialRewardInputs = append(m.InitialRewardInputs, RewardAdjustmentInput{})
			if err := m.InitialRewardInputs[len(m.InitialRewardInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPoolProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPoolProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPoolProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StakeToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardTokens = append(m.RewardTokens, ERC20Token{})
			if err := m.RewardTokens[len(m.RewardTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialRewardInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialRewardInputs = append(m.InitialRewardInputs, RewardAdjustmentInput{})
			if err := m.InitialRewardInputs[len(m.InitialRewardInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdjustRewardProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdjustRewardProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdjustRewardProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAdjustmentInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAdjustmentInputs = append(m.RewardAdjustmentInputs, RewardAdjustmentInput{})
			if err := m.RewardAdjustmentInputs[len(m.RewardAdjustmentInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdjustRewardProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdjustRewardProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdjustRewardProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAdjustmentInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAdjustmentInputs = append(m.RewardAdjustmentInputs, RewardAdjustmentInput{})
			if err := m.RewardAdjustmentInputs[len(m.RewardAdjustmentInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemovePoolProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePoolProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePoolProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemovePoolProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePoolProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePoolProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PoolName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTokensProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTokensProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTokensProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, ERC20Token{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTokensProposalWithDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTokensProposalWithDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTokensProposalWithDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = append(m.Tokens, ERC20Token{})
			if err := m.Tokens[len(m.Tokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFarming
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFarming
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFarming(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFarming
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFarming(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFarming
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFarming
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFarming
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFarming
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFarming
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFarming        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFarming          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFarming = fmt.Errorf("proto: unexpected end of group")
)
