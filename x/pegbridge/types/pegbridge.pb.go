// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/pegbridge/v1/pegbridge.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	types "github.com/celer-network/sgn-v2/common/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/regen-network/cosmos-proto"
	_ "google.golang.org/protobuf/types/known/durationpb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the set of params for the pegbridge module.
type Params struct {
	// trigger_sign_cooldown defines the minimal time between two trigger signing requests.
	TriggerSignCooldown time.Duration `protobuf:"bytes,1,opt,name=trigger_sign_cooldown,json=triggerSignCooldown,proto3,stdduration" json:"trigger_sign_cooldown,omitempty" yaml:"trigger_sign_cooldown"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetTriggerSignCooldown() time.Duration {
	if m != nil {
		return m.TriggerSignCooldown
	}
	return 0
}

// PegConfig describes the pegbridge specific configs.
type PegConfig struct {
	// pegged_token_bridges defines the PeggedTokenBridge contracts.
	PeggedTokenBridges []types.ContractInfo `protobuf:"bytes,1,rep,name=pegged_token_bridges,json=peggedTokenBridges,proto3" json:"pegged_token_bridges" yaml:"pegged_token_bridges"`
	// original_token_vaults defines the OriginalTokenVault contracts.
	OriginalTokenVaults []types.ContractInfo `protobuf:"bytes,2,rep,name=original_token_vaults,json=originalTokenVaults,proto3" json:"original_token_vaults" yaml:"original_token_vaults"`
	// orig_pegged_pairs defines the original-pegged token pairs.
	OrigPeggedPairs []OrigPeggedPair `protobuf:"bytes,3,rep,name=orig_pegged_pairs,json=origPeggedPairs,proto3" json:"orig_pegged_pairs" yaml:"orig_pegged_pairs"`
}

func (m *PegConfig) Reset()         { *m = PegConfig{} }
func (m *PegConfig) String() string { return proto.CompactTextString(m) }
func (*PegConfig) ProtoMessage()    {}
func (*PegConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{1}
}
func (m *PegConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PegConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PegConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PegConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PegConfig.Merge(m, src)
}
func (m *PegConfig) XXX_Size() int {
	return m.Size()
}
func (m *PegConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PegConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PegConfig proto.InternalMessageInfo

func (m *PegConfig) GetPeggedTokenBridges() []types.ContractInfo {
	if m != nil {
		return m.PeggedTokenBridges
	}
	return nil
}

func (m *PegConfig) GetOriginalTokenVaults() []types.ContractInfo {
	if m != nil {
		return m.OriginalTokenVaults
	}
	return nil
}

func (m *PegConfig) GetOrigPeggedPairs() []OrigPeggedPair {
	if m != nil {
		return m.OrigPeggedPairs
	}
	return nil
}

// OrigPeggedPair describes a pair of original-pegged ERC20 tokens on two EVM-compatible chains.
type OrigPeggedPair struct {
	// orig defines the original token.
	Orig types.ERC20Token `protobuf:"bytes,1,opt,name=orig,proto3" json:"orig" yaml:"orig"`
	// pegged defines the pegged token.
	Pegged types.ERC20Token `protobuf:"bytes,2,opt,name=pegged,proto3" json:"pegged" yaml:"pegged"`
	// mint_fee_bps defines the fee percentage in points to mint pegged tokens. 1 pip = 0.0001%
	MintFeePips uint32 `protobuf:"varint,3,opt,name=mint_fee_pips,json=mintFeePips,proto3" json:"mint_fee_pips,omitempty" yaml:"mint_fee_pips"`
	// max_mint_fee defines the max mint fee chargeable.
	MaxMintFee string `protobuf:"bytes,4,opt,name=max_mint_fee,json=maxMintFee,proto3" json:"max_mint_fee,omitempty" yaml:"max_mint_fee"`
	// burn_fee_bps defines the fee percentage in points to burn pegged tokens. 1 pip = 0.0001%
	BurnFeePips uint32 `protobuf:"varint,5,opt,name=burn_fee_pips,json=burnFeePips,proto3" json:"burn_fee_pips,omitempty" yaml:"burn_fee_pips"`
	// max_burn_fee defines the max burn fee chargeable.
	MaxBurnFee string `protobuf:"bytes,6,opt,name=max_burn_fee,json=maxBurnFee,proto3" json:"max_burn_fee,omitempty" yaml:"max_burn_fee"`
	// used for gov only, to delete unintended config
	Obsolete bool `protobuf:"varint,7,opt,name=obsolete,proto3" json:"obsolete,omitempty" yaml:"obsolete"`
}

func (m *OrigPeggedPair) Reset()         { *m = OrigPeggedPair{} }
func (m *OrigPeggedPair) String() string { return proto.CompactTextString(m) }
func (*OrigPeggedPair) ProtoMessage()    {}
func (*OrigPeggedPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{2}
}
func (m *OrigPeggedPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrigPeggedPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrigPeggedPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrigPeggedPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrigPeggedPair.Merge(m, src)
}
func (m *OrigPeggedPair) XXX_Size() int {
	return m.Size()
}
func (m *OrigPeggedPair) XXX_DiscardUnknown() {
	xxx_messageInfo_OrigPeggedPair.DiscardUnknown(m)
}

var xxx_messageInfo_OrigPeggedPair proto.InternalMessageInfo

func (m *OrigPeggedPair) GetOrig() types.ERC20Token {
	if m != nil {
		return m.Orig
	}
	return types.ERC20Token{}
}

func (m *OrigPeggedPair) GetPegged() types.ERC20Token {
	if m != nil {
		return m.Pegged
	}
	return types.ERC20Token{}
}

func (m *OrigPeggedPair) GetMintFeePips() uint32 {
	if m != nil {
		return m.MintFeePips
	}
	return 0
}

func (m *OrigPeggedPair) GetMaxMintFee() string {
	if m != nil {
		return m.MaxMintFee
	}
	return ""
}

func (m *OrigPeggedPair) GetBurnFeePips() uint32 {
	if m != nil {
		return m.BurnFeePips
	}
	return 0
}

func (m *OrigPeggedPair) GetMaxBurnFee() string {
	if m != nil {
		return m.MaxBurnFee
	}
	return ""
}

func (m *OrigPeggedPair) GetObsolete() bool {
	if m != nil {
		return m.Obsolete
	}
	return false
}

// PeggedOrigIndex describes the reverse lookup index from a pegged token to the original token, if exists.
type PeggedOrigIndex struct {
	// pegged defines the pegged token info.
	Pegged types.ContractInfo `protobuf:"bytes,1,opt,name=pegged,proto3" json:"pegged" yaml:"pegged"`
	// orig defines the original token info.
	Orig types.ContractInfo `protobuf:"bytes,2,opt,name=orig,proto3" json:"orig" yaml:"orig"`
}

func (m *PeggedOrigIndex) Reset()         { *m = PeggedOrigIndex{} }
func (m *PeggedOrigIndex) String() string { return proto.CompactTextString(m) }
func (*PeggedOrigIndex) ProtoMessage()    {}
func (*PeggedOrigIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{3}
}
func (m *PeggedOrigIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeggedOrigIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeggedOrigIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeggedOrigIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeggedOrigIndex.Merge(m, src)
}
func (m *PeggedOrigIndex) XXX_Size() int {
	return m.Size()
}
func (m *PeggedOrigIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_PeggedOrigIndex.DiscardUnknown(m)
}

var xxx_messageInfo_PeggedOrigIndex proto.InternalMessageInfo

func (m *PeggedOrigIndex) GetPegged() types.ContractInfo {
	if m != nil {
		return m.Pegged
	}
	return types.ContractInfo{}
}

func (m *PeggedOrigIndex) GetOrig() types.ContractInfo {
	if m != nil {
		return m.Orig
	}
	return types.ContractInfo{}
}

// DepositInfo describes the info for an on-chain deposit tx submitted by a user to OriginalTokenVaults.
type DepositInfo struct {
	// chain_id defines the EVM chain ID on which the deposit happened.
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty" yaml:"chain_id"`
	// deposit_id defines the deposit ID.
	DepositId []byte `protobuf:"bytes,2,opt,name=deposit_id,json=depositId,proto3" json:"deposit_id,omitempty" yaml:"deposit_id"`
	// mint_id defines the corresponding mint ID.
	MintId []byte `protobuf:"bytes,3,opt,name=mint_id,json=mintId,proto3" json:"mint_id,omitempty" yaml:"mint_id"`
}

func (m *DepositInfo) Reset()      { *m = DepositInfo{} }
func (*DepositInfo) ProtoMessage() {}
func (*DepositInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{4}
}
func (m *DepositInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositInfo.Merge(m, src)
}
func (m *DepositInfo) XXX_Size() int {
	return m.Size()
}
func (m *DepositInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DepositInfo proto.InternalMessageInfo

func (m *DepositInfo) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *DepositInfo) GetDepositId() []byte {
	if m != nil {
		return m.DepositId
	}
	return nil
}

func (m *DepositInfo) GetMintId() []byte {
	if m != nil {
		return m.MintId
	}
	return nil
}

// MintInfo describes the info for an on-chain mint request to be submitted to PeggedTokenBridge.
type MintInfo struct {
	// chain_id defines the EVM chain ID to mint the pegged token.
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty" yaml:"chain_id"`
	// mint_proto_bytes defines the serialized mint protobuf to be submitted to PeggedTokenBridge.
	MintProtoBytes []byte `protobuf:"bytes,2,opt,name=mint_proto_bytes,json=mintProtoBytes,proto3" json:"mint_proto_bytes,omitempty" yaml:"mint_proto_bytes"`
	// signatures defines the signatures to be verified on PeggedTokenBridge.
	Signatures []types.Signature `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures" yaml:"signatures"`
	// base_fee defines the base fee charged for the mintage.
	BaseFee string `protobuf:"bytes,4,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty" yaml:"base_fee"`
	// percentage_fee defines the percentage fee charged for the mintage.
	PercentageFee string `protobuf:"bytes,5,opt,name=percentage_fee,json=percentageFee,proto3" json:"percentage_fee,omitempty" yaml:"percentage_fee"`
	// success defines whether the minting has been completed on-chain.
	Success     bool  `protobuf:"varint,6,opt,name=success,proto3" json:"success,omitempty" yaml:"success"`
	LastReqTime int64 `protobuf:"varint,7,opt,name=last_req_time,json=lastReqTime,proto3" json:"last_req_time,omitempty"`
}

func (m *MintInfo) Reset()      { *m = MintInfo{} }
func (*MintInfo) ProtoMessage() {}
func (*MintInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{5}
}
func (m *MintInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintInfo.Merge(m, src)
}
func (m *MintInfo) XXX_Size() int {
	return m.Size()
}
func (m *MintInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MintInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MintInfo proto.InternalMessageInfo

func (m *MintInfo) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *MintInfo) GetMintProtoBytes() []byte {
	if m != nil {
		return m.MintProtoBytes
	}
	return nil
}

func (m *MintInfo) GetSignatures() []types.Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *MintInfo) GetBaseFee() string {
	if m != nil {
		return m.BaseFee
	}
	return ""
}

func (m *MintInfo) GetPercentageFee() string {
	if m != nil {
		return m.PercentageFee
	}
	return ""
}

func (m *MintInfo) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *MintInfo) GetLastReqTime() int64 {
	if m != nil {
		return m.LastReqTime
	}
	return 0
}

// BurnInfo describes the info for an on-chain burn tx submitted by a user to PeggedTokenBridge.
type BurnInfo struct {
	// chain_id defines the EVM chain ID on which the burn happened.
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty" yaml:"chain_id"`
	// burn_id defines the burn ID.
	BurnId []byte `protobuf:"bytes,2,opt,name=burn_id,json=burnId,proto3" json:"burn_id,omitempty" yaml:"burn_id"`
	// withdraw_id defines the corresponding withdraw ID.
	WithdrawId []byte `protobuf:"bytes,3,opt,name=withdraw_id,json=withdrawId,proto3" json:"withdraw_id,omitempty" yaml:"withdraw_id"`
}

func (m *BurnInfo) Reset()      { *m = BurnInfo{} }
func (*BurnInfo) ProtoMessage() {}
func (*BurnInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{6}
}
func (m *BurnInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnInfo.Merge(m, src)
}
func (m *BurnInfo) XXX_Size() int {
	return m.Size()
}
func (m *BurnInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BurnInfo proto.InternalMessageInfo

func (m *BurnInfo) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *BurnInfo) GetBurnId() []byte {
	if m != nil {
		return m.BurnId
	}
	return nil
}

func (m *BurnInfo) GetWithdrawId() []byte {
	if m != nil {
		return m.WithdrawId
	}
	return nil
}

// WithdrawInfo describes the info for an on-chain withdraw request to be submitted to OriginalTokenVault.
type WithdrawInfo struct {
	// chain_id defines the EVM chain ID to withdraw the original token
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty" yaml:"chain_id"`
	// withdraw_proto_bytes defines the serialized withdraw protobuf to be submitted to OriginalTokenVault.
	WithdrawProtoBytes []byte `protobuf:"bytes,2,opt,name=withdraw_proto_bytes,json=withdrawProtoBytes,proto3" json:"withdraw_proto_bytes,omitempty" yaml:"withdraw_proto_bytes"`
	// signatures defines the signatures to be verified on OriginalTokenVault.
	Signatures []types.Signature `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures" yaml:"signatures"`
	// base_fee defines the base fee charged for the withdrawal.
	BaseFee string `protobuf:"bytes,4,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty" yaml:"base_fee"`
	// percentage_fee defines the percentage fee charged for the withdrawal.
	PercentageFee string `protobuf:"bytes,5,opt,name=percentage_fee,json=percentageFee,proto3" json:"percentage_fee,omitempty" yaml:"percentage_fee"`
	// success defines whether the withdrawal has been completed on-chain.
	Success     bool  `protobuf:"varint,6,opt,name=success,proto3" json:"success,omitempty" yaml:"success"`
	LastReqTime int64 `protobuf:"varint,7,opt,name=last_req_time,json=lastReqTime,proto3" json:"last_req_time,omitempty"`
}

func (m *WithdrawInfo) Reset()      { *m = WithdrawInfo{} }
func (*WithdrawInfo) ProtoMessage() {}
func (*WithdrawInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{7}
}
func (m *WithdrawInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawInfo.Merge(m, src)
}
func (m *WithdrawInfo) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawInfo proto.InternalMessageInfo

func (m *WithdrawInfo) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *WithdrawInfo) GetWithdrawProtoBytes() []byte {
	if m != nil {
		return m.WithdrawProtoBytes
	}
	return nil
}

func (m *WithdrawInfo) GetSignatures() []types.Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *WithdrawInfo) GetBaseFee() string {
	if m != nil {
		return m.BaseFee
	}
	return ""
}

func (m *WithdrawInfo) GetPercentageFee() string {
	if m != nil {
		return m.PercentageFee
	}
	return ""
}

func (m *WithdrawInfo) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *WithdrawInfo) GetLastReqTime() int64 {
	if m != nil {
		return m.LastReqTime
	}
	return 0
}

// FeeClaimInfo describes the info for a pegbridge fee claim.
type FeeClaimInfo struct {
	// withdraw_id defines the corresponding withdraw ID
	WithdrawId []byte `protobuf:"bytes,1,opt,name=withdraw_id,json=withdrawId,proto3" json:"withdraw_id,omitempty" yaml:"withdraw_id"`
}

func (m *FeeClaimInfo) Reset()         { *m = FeeClaimInfo{} }
func (m *FeeClaimInfo) String() string { return proto.CompactTextString(m) }
func (*FeeClaimInfo) ProtoMessage()    {}
func (*FeeClaimInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{8}
}
func (m *FeeClaimInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeClaimInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeClaimInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeClaimInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeClaimInfo.Merge(m, src)
}
func (m *FeeClaimInfo) XXX_Size() int {
	return m.Size()
}
func (m *FeeClaimInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeClaimInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FeeClaimInfo proto.InternalMessageInfo

func (m *FeeClaimInfo) GetWithdrawId() []byte {
	if m != nil {
		return m.WithdrawId
	}
	return nil
}

// MintOnChain describes the mint protobuf to be submitted on-chain.
type MintOnChain struct {
	// token defines the token address.
	Token []byte `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// account defines the account address that the tokens should be mint to.
	Account []byte `protobuf:"bytes,2,opt,name=account,proto3" json:"account,omitempty"`
	// amount defines the mint amount.
	Amount []byte `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// depositor defines the account address that made deposit at the original token chain.
	// Not applicable to governance-triggered mints.
	Depositor []byte `protobuf:"bytes,4,opt,name=depositor,proto3" json:"depositor,omitempty"`
	// ref_chain_id defines the reference chain ID, taking values of:
	// 1. The common case of deposit-mint: the chain ID on which the corresponding deposit happened;
	// 2. Governance-triggered mint: the chain ID on which the minting will happen.
	RefChainId uint64 `protobuf:"varint,5,opt,name=ref_chain_id,json=refChainId,proto3" json:"ref_chain_id,omitempty"`
	// ref_id defines a unique reference ID, taking values of:
	// 1. The common case of deposit-mint: the deposit ID;
	// 2. Governance-triggered mint: ID as needed.
	RefId []byte `protobuf:"bytes,6,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
}

func (m *MintOnChain) Reset()      { *m = MintOnChain{} }
func (*MintOnChain) ProtoMessage() {}
func (*MintOnChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{9}
}
func (m *MintOnChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintOnChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintOnChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintOnChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintOnChain.Merge(m, src)
}
func (m *MintOnChain) XXX_Size() int {
	return m.Size()
}
func (m *MintOnChain) XXX_DiscardUnknown() {
	xxx_messageInfo_MintOnChain.DiscardUnknown(m)
}

var xxx_messageInfo_MintOnChain proto.InternalMessageInfo

func (m *MintOnChain) GetToken() []byte {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *MintOnChain) GetAccount() []byte {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *MintOnChain) GetAmount() []byte {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *MintOnChain) GetDepositor() []byte {
	if m != nil {
		return m.Depositor
	}
	return nil
}

func (m *MintOnChain) GetRefChainId() uint64 {
	if m != nil {
		return m.RefChainId
	}
	return 0
}

func (m *MintOnChain) GetRefId() []byte {
	if m != nil {
		return m.RefId
	}
	return nil
}

// WithdrawOnChain describes the withdraw protobuf to be submitted on-chain.
type WithdrawOnChain struct {
	// token defines the token address.
	Token []byte `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// receiver defines the account address that the tokens should be withdrawn to.
	Receiver []byte `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	// amount defines the withdraw amount.
	Amount []byte `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// burn_account defines the account that burned the pegged token.
	// Not applicable to fee claims and governance-triggered withdrawals.
	BurnAccount []byte `protobuf:"bytes,4,opt,name=burn_account,json=burnAccount,proto3" json:"burn_account,omitempty"`
	// ref_chain_id defines the reference chain ID, taking values of:
	// 1. The common case of burn-withdraw: the chain ID on which the corresponding burn happened;
	// 2. Pegbridge fee claim: zero / Not applicable;
	// 3. Other governance-triggered withdrawals: the chain ID on which the withdrawal will happen.
	RefChainId uint64 `protobuf:"varint,5,opt,name=ref_chain_id,json=refChainId,proto3" json:"ref_chain_id,omitempty"`
	// ref_id defines a unique reference ID, taking values of:
	// 1. The common case of burn-withdraw: the burn ID;
	// 2. Pegbridge fee claim: a per-account nonce;
	// 3. Refund for wrong deposit: the deposit ID;
	// 4. Governance-triggered withdrawal: ID as needed.
	RefId []byte `protobuf:"bytes,6,opt,name=ref_id,json=refId,proto3" json:"ref_id,omitempty"`
}

func (m *WithdrawOnChain) Reset()      { *m = WithdrawOnChain{} }
func (*WithdrawOnChain) ProtoMessage() {}
func (*WithdrawOnChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{10}
}
func (m *WithdrawOnChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawOnChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawOnChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawOnChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawOnChain.Merge(m, src)
}
func (m *WithdrawOnChain) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawOnChain) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawOnChain.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawOnChain proto.InternalMessageInfo

func (m *WithdrawOnChain) GetToken() []byte {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *WithdrawOnChain) GetReceiver() []byte {
	if m != nil {
		return m.Receiver
	}
	return nil
}

func (m *WithdrawOnChain) GetAmount() []byte {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *WithdrawOnChain) GetBurnAccount() []byte {
	if m != nil {
		return m.BurnAccount
	}
	return nil
}

func (m *WithdrawOnChain) GetRefChainId() uint64 {
	if m != nil {
		return m.RefChainId
	}
	return 0
}

func (m *WithdrawOnChain) GetRefId() []byte {
	if m != nil {
		return m.RefId
	}
	return nil
}

// PegProposal describes a pegbridge config proposal, note it must be a whole json
type PegProposal struct {
	Title       string     `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string     `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	PegConfig   *PegConfig `protobuf:"bytes,3,opt,name=peg_config,json=pegConfig,proto3" json:"peg_config,omitempty"`
	// deposit defines the amount for MsgSubmitProposal
	Deposit github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=deposit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"deposit"`
}

func (m *PegProposal) Reset()         { *m = PegProposal{} }
func (m *PegProposal) String() string { return proto.CompactTextString(m) }
func (*PegProposal) ProtoMessage()    {}
func (*PegProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_87a392f2055d6dba, []int{11}
}
func (m *PegProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PegProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PegProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PegProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PegProposal.Merge(m, src)
}
func (m *PegProposal) XXX_Size() int {
	return m.Size()
}
func (m *PegProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_PegProposal.DiscardUnknown(m)
}

var xxx_messageInfo_PegProposal proto.InternalMessageInfo

func (m *PegProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PegProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PegProposal) GetPegConfig() *PegConfig {
	if m != nil {
		return m.PegConfig
	}
	return nil
}

func init() {
	proto.RegisterType((*Params)(nil), "sgn.pegbridge.v1.Params")
	proto.RegisterType((*PegConfig)(nil), "sgn.pegbridge.v1.PegConfig")
	proto.RegisterType((*OrigPeggedPair)(nil), "sgn.pegbridge.v1.OrigPeggedPair")
	proto.RegisterType((*PeggedOrigIndex)(nil), "sgn.pegbridge.v1.PeggedOrigIndex")
	proto.RegisterType((*DepositInfo)(nil), "sgn.pegbridge.v1.DepositInfo")
	proto.RegisterType((*MintInfo)(nil), "sgn.pegbridge.v1.MintInfo")
	proto.RegisterType((*BurnInfo)(nil), "sgn.pegbridge.v1.BurnInfo")
	proto.RegisterType((*WithdrawInfo)(nil), "sgn.pegbridge.v1.WithdrawInfo")
	proto.RegisterType((*FeeClaimInfo)(nil), "sgn.pegbridge.v1.FeeClaimInfo")
	proto.RegisterType((*MintOnChain)(nil), "sgn.pegbridge.v1.MintOnChain")
	proto.RegisterType((*WithdrawOnChain)(nil), "sgn.pegbridge.v1.WithdrawOnChain")
	proto.RegisterType((*PegProposal)(nil), "sgn.pegbridge.v1.PegProposal")
}

func init() { proto.RegisterFile("sgn/pegbridge/v1/pegbridge.proto", fileDescriptor_87a392f2055d6dba) }

var fileDescriptor_87a392f2055d6dba = []byte{
	// 1278 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0x4d, 0x6f, 0x1b, 0xc5,
	0x1b, 0xcf, 0xe6, 0xc5, 0x76, 0xc6, 0x4e, 0xd2, 0x4e, 0x92, 0xd6, 0x49, 0x2b, 0xaf, 0xff, 0xf3,
	0x47, 0x28, 0x52, 0x9b, 0x35, 0x09, 0x48, 0x88, 0x88, 0x03, 0xac, 0xdb, 0x52, 0x83, 0x50, 0xcd,
	0xb4, 0x02, 0x89, 0xcb, 0x6a, 0xbd, 0x3b, 0xde, 0x8e, 0xea, 0xdd, 0xd9, 0xce, 0xae, 0xf3, 0xf2,
	0x2d, 0x38, 0x56, 0x9c, 0x2a, 0x21, 0x55, 0x48, 0x5c, 0x10, 0xe2, 0xca, 0x81, 0x5b, 0x8f, 0x15,
	0x27, 0x84, 0xd0, 0x82, 0x52, 0x09, 0x21, 0x8e, 0xfe, 0x04, 0x68, 0x5e, 0xd6, 0x5e, 0x87, 0xb4,
	0xa9, 0xc2, 0x95, 0x93, 0xe7, 0x79, 0xfd, 0x3d, 0xf3, 0x3c, 0xbf, 0x99, 0x1d, 0x83, 0x66, 0x12,
	0x44, 0xad, 0x98, 0x04, 0x3d, 0x4e, 0xfd, 0x80, 0xb4, 0xf6, 0x77, 0x26, 0x82, 0x15, 0x73, 0x96,
	0x32, 0x78, 0x21, 0x09, 0x22, 0x6b, 0xa2, 0xdc, 0xdf, 0xd9, 0xdc, 0xf0, 0x58, 0x12, 0xb2, 0xc4,
	0x91, 0xf6, 0x96, 0x12, 0x94, 0xf3, 0xe6, 0x5a, 0xc0, 0x02, 0xa6, 0xf4, 0x62, 0xa5, 0xb5, 0x8d,
	0x80, 0xb1, 0x60, 0x40, 0x5a, 0x52, 0xea, 0x0d, 0xfb, 0x2d, 0x7f, 0xc8, 0xdd, 0x94, 0xb2, 0x48,
	0xdb, 0x37, 0x45, 0x11, 0x1e, 0x0b, 0x43, 0x16, 0x89, 0x0a, 0xd4, 0x4a, 0xd9, 0xd0, 0x37, 0x06,
	0x28, 0x75, 0x5d, 0xee, 0x86, 0x09, 0xfc, 0xd2, 0x00, 0xeb, 0x29, 0xa7, 0x41, 0x40, 0xb8, 0x93,
	0xd0, 0x20, 0x72, 0x3c, 0xc6, 0x06, 0x3e, 0x3b, 0x88, 0xea, 0x46, 0xd3, 0xd8, 0xaa, 0xee, 0x6e,
	0x58, 0x0a, 0xc7, 0xca, 0x71, 0xac, 0x1b, 0x1a, 0xc7, 0xfe, 0xe8, 0x69, 0x66, 0xce, 0xfc, 0x95,
	0x99, 0xe6, 0xa9, 0xf1, 0xd7, 0x59, 0x48, 0x53, 0x12, 0xc6, 0xe9, 0xd1, 0x28, 0x33, 0xaf, 0x1e,
	0xb9, 0xe1, 0x60, 0x0f, 0x9d, 0xea, 0x88, 0x1e, 0xfd, 0x66, 0x1a, 0x78, 0x55, 0xdb, 0xee, 0xd2,
	0x20, 0x6a, 0x6b, 0xcb, 0xde, 0xfc, 0xa3, 0xc7, 0xe6, 0x0c, 0xfa, 0x63, 0x16, 0x2c, 0x76, 0x49,
	0xd0, 0x66, 0x51, 0x9f, 0x06, 0x90, 0x83, 0xb5, 0x98, 0x04, 0x01, 0xf1, 0x9d, 0x94, 0x3d, 0x20,
	0x91, 0xa3, 0x5a, 0x98, 0xd4, 0x8d, 0xe6, 0xdc, 0x56, 0x75, 0xf7, 0x8a, 0x25, 0x3a, 0xab, 0x37,
	0xbb, 0xbf, 0x63, 0xb5, 0x59, 0x94, 0x72, 0xd7, 0x4b, 0x3b, 0x51, 0x9f, 0xd9, 0xff, 0x17, 0x05,
	0x8f, 0x32, 0xf3, 0x8a, 0xaa, 0xe6, 0xb4, 0x34, 0x08, 0x43, 0xa5, 0xbe, 0x27, 0xb4, 0xb6, 0x52,
	0xc2, 0x21, 0x58, 0x67, 0x9c, 0x06, 0x34, 0x72, 0x07, 0xda, 0x7d, 0xdf, 0x1d, 0x0e, 0xd2, 0xa4,
	0x3e, 0x7b, 0x36, 0xe8, 0x6b, 0x1a, 0x54, 0xb7, 0xe0, 0xd4, 0x3c, 0x08, 0xaf, 0xe6, 0x7a, 0x89,
	0xfb, 0xa9, 0xd4, 0xc2, 0x08, 0x5c, 0x14, 0x6a, 0x47, 0x17, 0x1a, 0xbb, 0x94, 0x27, 0xf5, 0x39,
	0x09, 0xd9, 0xb4, 0x4e, 0x32, 0xc8, 0xba, 0xc3, 0x69, 0xd0, 0x95, 0x9e, 0x5d, 0x97, 0x72, 0xbb,
	0xa9, 0x71, 0xeb, 0x13, 0xdc, 0xa9, 0x44, 0x08, 0xaf, 0xb0, 0xa9, 0x88, 0x04, 0xfd, 0x38, 0x07,
	0x96, 0xa7, 0xb3, 0x40, 0x1b, 0xcc, 0x0b, 0xaf, 0x31, 0x19, 0xa6, 0x37, 0x7a, 0x13, 0xb7, 0x77,
	0xdf, 0x50, 0x9d, 0x5a, 0xd5, 0x70, 0xd5, 0x09, 0x1c, 0xc2, 0x32, 0x16, 0xde, 0x06, 0x25, 0x05,
	0x5c, 0x9f, 0x3d, 0x2b, 0xcb, 0xba, 0xce, 0xb2, 0x54, 0x9c, 0x10, 0xc2, 0x3a, 0x1e, 0xbe, 0x0b,
	0x96, 0x42, 0x1a, 0xa5, 0x4e, 0x9f, 0x10, 0x27, 0xa6, 0xb1, 0x68, 0x86, 0xb1, 0xb5, 0x64, 0xd7,
	0x47, 0x99, 0xb9, 0xa6, 0x22, 0xa6, 0xcc, 0x08, 0x57, 0x85, 0x7c, 0x8b, 0x90, 0x2e, 0x8d, 0x13,
	0xf8, 0x0e, 0xa8, 0x85, 0xee, 0xa1, 0x93, 0xbb, 0xd4, 0xe7, 0x9b, 0xc6, 0xd6, 0xa2, 0x7d, 0x79,
	0x94, 0x99, 0xab, 0x3a, 0xb8, 0x60, 0x45, 0x18, 0x84, 0xee, 0xe1, 0xc7, 0x2a, 0x5c, 0x00, 0xf7,
	0x86, 0x3c, 0x9a, 0x00, 0x2f, 0x9c, 0x04, 0x9e, 0x32, 0x23, 0x5c, 0x15, 0xf2, 0x09, 0xe0, 0xdc,
	0xa5, 0x5e, 0x3a, 0x0d, 0x38, 0xb7, 0x2a, 0x60, 0x5b, 0x85, 0xc3, 0x16, 0xa8, 0xb0, 0x5e, 0xc2,
	0x06, 0x24, 0x25, 0xf5, 0x72, 0xd3, 0xd8, 0xaa, 0xd8, 0xab, 0xa3, 0xcc, 0x5c, 0xd1, 0x4d, 0xd6,
	0x16, 0x84, 0xc7, 0x4e, 0xe8, 0x2b, 0x03, 0xac, 0xa8, 0xf9, 0x89, 0x49, 0x76, 0x22, 0x9f, 0x1c,
	0xc2, 0x0f, 0xc7, 0x03, 0x50, 0x63, 0x7c, 0x29, 0x5f, 0xcf, 0x18, 0xc1, 0x0d, 0x4d, 0x88, 0xd9,
	0xb3, 0x33, 0xbd, 0x98, 0x12, 0xe8, 0x89, 0x01, 0xaa, 0x37, 0x48, 0xcc, 0x12, 0x2a, 0x5d, 0xa1,
	0x05, 0x2a, 0xde, 0x7d, 0x97, 0x46, 0x0e, 0x55, 0x35, 0xce, 0x17, 0xb7, 0x99, 0x5b, 0x10, 0x2e,
	0xcb, 0x65, 0xc7, 0x87, 0x6f, 0x01, 0xe0, 0xab, 0x70, 0x11, 0x21, 0x6a, 0xa9, 0xd9, 0xeb, 0xa3,
	0xcc, 0xbc, 0xa8, 0x22, 0x26, 0x36, 0x84, 0x17, 0xb5, 0xd0, 0xf1, 0xe1, 0x35, 0x50, 0x96, 0xe3,
	0xa5, 0xbe, 0x24, 0x4e, 0xcd, 0x86, 0xa3, 0xcc, 0x5c, 0x2e, 0x10, 0x47, 0xf8, 0x97, 0xc4, 0xaa,
	0xe3, 0xeb, 0xbb, 0xe7, 0xf1, 0x1c, 0xa8, 0x08, 0x12, 0x9c, 0xab, 0xca, 0x9b, 0xe0, 0x82, 0x4c,
	0x2b, 0xaf, 0x4e, 0xa7, 0x77, 0x94, 0x92, 0x44, 0xd7, 0x7a, 0x65, 0x94, 0x99, 0x97, 0x0b, 0xc0,
	0x05, 0x0f, 0x84, 0x97, 0x85, 0xaa, 0x2b, 0x34, 0xb6, 0x50, 0xc0, 0xbb, 0x00, 0x88, 0x0b, 0xd3,
	0x4d, 0x87, 0x9c, 0xe4, 0xe7, 0xbf, 0x7e, 0xa2, 0xf1, 0x77, 0x73, 0x07, 0x7b, 0x43, 0x77, 0x5d,
	0xb7, 0x62, 0x12, 0x89, 0x70, 0x21, 0x8d, 0xd8, 0x4b, 0xcf, 0x4d, 0x48, 0xe1, 0x20, 0x14, 0xf6,
	0x92, 0x5b, 0x10, 0x2e, 0x8b, 0xa5, 0x20, 0xe2, 0x7b, 0x60, 0x39, 0x26, 0xdc, 0x23, 0x51, 0xea,
	0x06, 0x2a, 0x6a, 0x41, 0x46, 0x6d, 0x8c, 0x32, 0x73, 0x3d, 0xa7, 0x4a, 0xd1, 0x8e, 0xf0, 0xd2,
	0x44, 0x21, 0x32, 0x5c, 0x07, 0xe5, 0x64, 0xe8, 0x79, 0x24, 0x49, 0xe4, 0x01, 0xa8, 0x14, 0xbb,
	0xaf, 0x0d, 0x08, 0xe7, 0x2e, 0x10, 0x81, 0xa5, 0x81, 0x9b, 0xa4, 0x0e, 0x27, 0x0f, 0x9d, 0x94,
	0x86, 0x8a, 0xfd, 0x73, 0xb8, 0x2a, 0x94, 0x98, 0x3c, 0xbc, 0x47, 0x43, 0xa2, 0x47, 0xf4, 0xc4,
	0x00, 0x15, 0x71, 0x5c, 0xce, 0x35, 0xa2, 0x6b, 0xa0, 0x2c, 0x0f, 0xde, 0x98, 0x45, 0x85, 0xa2,
	0xb4, 0x01, 0xe1, 0x92, 0x58, 0x75, 0x7c, 0xf8, 0x36, 0xa8, 0x1e, 0xd0, 0xf4, 0xbe, 0xcf, 0xdd,
	0x83, 0x09, 0x87, 0x2e, 0x8d, 0x32, 0x13, 0xaa, 0x80, 0x82, 0x11, 0x61, 0x90, 0x4b, 0x63, 0x2e,
	0x7d, 0x3b, 0x07, 0x6a, 0x9f, 0xe5, 0xca, 0xf3, 0x14, 0xfb, 0x09, 0x58, 0x1b, 0x43, 0xfc, 0x93,
	0x53, 0xe6, 0xe4, 0xcb, 0x76, 0x9a, 0x17, 0xc2, 0x30, 0x57, 0xff, 0xc7, 0xad, 0x57, 0xe5, 0xd6,
	0x07, 0xa0, 0x76, 0x8b, 0x90, 0xf6, 0xc0, 0xa5, 0xa1, 0x9c, 0xd8, 0x09, 0x06, 0x18, 0xaf, 0xca,
	0x00, 0xf4, 0x9d, 0x01, 0xaa, 0xe2, 0x1e, 0xb9, 0x13, 0xb5, 0xc5, 0x30, 0xe1, 0x1a, 0x58, 0x90,
	0x0f, 0x00, 0x95, 0x02, 0x2b, 0x01, 0xd6, 0x41, 0xd9, 0xf5, 0x3c, 0x36, 0x8c, 0x52, 0x35, 0x53,
	0x9c, 0x8b, 0xf0, 0x12, 0x28, 0xb9, 0xa1, 0x34, 0x48, 0xd6, 0x61, 0x2d, 0xc1, 0xab, 0x20, 0xbf,
	0xdf, 0x18, 0x97, 0xbd, 0xae, 0xe1, 0x89, 0x02, 0x36, 0x41, 0x8d, 0x93, 0xbe, 0x33, 0x26, 0x99,
	0x68, 0xeb, 0x3c, 0x06, 0x9c, 0xf4, 0xdb, 0x9a, 0x52, 0xeb, 0xa0, 0x24, 0x3c, 0xa8, 0x2f, 0xfb,
	0x56, 0xc3, 0x0b, 0x9c, 0xf4, 0xc7, 0x84, 0xfd, 0xc1, 0x00, 0x2b, 0x39, 0x61, 0x5f, 0x5e, 0xf8,
	0x26, 0xa8, 0x70, 0xe2, 0x11, 0xba, 0x4f, 0xb8, 0xae, 0x7c, 0x2c, 0xbf, 0xb0, 0xf4, 0xff, 0x81,
	0x9a, 0x3c, 0x61, 0xf9, 0x8e, 0x55, 0xf5, 0xf2, 0xc3, 0xf9, 0xbe, 0xde, 0xf5, 0xbf, 0xac, 0xff,
	0x57, 0x03, 0x54, 0xbb, 0x24, 0xe8, 0x72, 0x16, 0xb3, 0xc4, 0x1d, 0xc8, 0xda, 0x69, 0x3a, 0x20,
	0xb2, 0xf6, 0x45, 0xac, 0x04, 0xd8, 0x04, 0x55, 0x9f, 0x24, 0x1e, 0xa7, 0xb1, 0x78, 0xd5, 0xca,
	0xf2, 0x17, 0x71, 0x51, 0x05, 0xf7, 0x00, 0x88, 0x49, 0xe0, 0x78, 0xf2, 0x01, 0x2a, 0x77, 0x91,
	0x7f, 0xf9, 0xa6, 0x1e, 0x60, 0xe3, 0x37, 0x2a, 0x5e, 0x8c, 0xc7, 0xcf, 0xd5, 0xdb, 0xa0, 0xac,
	0xe7, 0xa1, 0x8f, 0x82, 0x25, 0xce, 0xd0, 0x2f, 0x99, 0xf9, 0x7a, 0x40, 0xd3, 0xfb, 0xc3, 0x9e,
	0x38, 0x67, 0xfa, 0xb9, 0xaf, 0x7f, 0xb6, 0x13, 0xff, 0x41, 0x2b, 0x3d, 0x8a, 0x49, 0x62, 0x75,
	0xa2, 0x14, 0xe7, 0xe1, 0x7b, 0x2b, 0x7f, 0x3e, 0x36, 0x67, 0x7e, 0xfa, 0x7e, 0xbb, 0x2c, 0x3e,
	0xb2, 0x24, 0x4a, 0xed, 0x3b, 0x5f, 0x1f, 0x37, 0x8c, 0xa7, 0xc7, 0x0d, 0xe3, 0xd9, 0x71, 0xc3,
	0xf8, 0xfd, 0xb8, 0x61, 0x7c, 0xf1, 0xbc, 0x31, 0xf3, 0xec, 0x79, 0x63, 0xe6, 0xe7, 0xe7, 0x8d,
	0x99, 0xcf, 0x77, 0x8a, 0xf9, 0xc9, 0x80, 0xf0, 0xed, 0x88, 0xa4, 0x07, 0x8c, 0x3f, 0x68, 0x25,
	0x41, 0xb4, 0xbd, 0xbf, 0xdb, 0x3a, 0x2c, 0xfc, 0x45, 0x91, 0x70, 0xbd, 0x92, 0xbc, 0x2e, 0xde,
	0xfc, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x24, 0xa5, 0x81, 0xc1, 0xc0, 0x0c, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TriggerSignCooldown != that1.TriggerSignCooldown {
		return false
	}
	return true
}
func (this *PegConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PegConfig)
	if !ok {
		that2, ok := that.(PegConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.PeggedTokenBridges) != len(that1.PeggedTokenBridges) {
		return false
	}
	for i := range this.PeggedTokenBridges {
		if !this.PeggedTokenBridges[i].Equal(&that1.PeggedTokenBridges[i]) {
			return false
		}
	}
	if len(this.OriginalTokenVaults) != len(that1.OriginalTokenVaults) {
		return false
	}
	for i := range this.OriginalTokenVaults {
		if !this.OriginalTokenVaults[i].Equal(&that1.OriginalTokenVaults[i]) {
			return false
		}
	}
	if len(this.OrigPeggedPairs) != len(that1.OrigPeggedPairs) {
		return false
	}
	for i := range this.OrigPeggedPairs {
		if !this.OrigPeggedPairs[i].Equal(&that1.OrigPeggedPairs[i]) {
			return false
		}
	}
	return true
}
func (this *OrigPeggedPair) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrigPeggedPair)
	if !ok {
		that2, ok := that.(OrigPeggedPair)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Orig.Equal(&that1.Orig) {
		return false
	}
	if !this.Pegged.Equal(&that1.Pegged) {
		return false
	}
	if this.MintFeePips != that1.MintFeePips {
		return false
	}
	if this.MaxMintFee != that1.MaxMintFee {
		return false
	}
	if this.BurnFeePips != that1.BurnFeePips {
		return false
	}
	if this.MaxBurnFee != that1.MaxBurnFee {
		return false
	}
	if this.Obsolete != that1.Obsolete {
		return false
	}
	return true
}
func (this *PeggedOrigIndex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PeggedOrigIndex)
	if !ok {
		that2, ok := that.(PeggedOrigIndex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Pegged.Equal(&that1.Pegged) {
		return false
	}
	if !this.Orig.Equal(&that1.Orig) {
		return false
	}
	return true
}
func (this *DepositInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DepositInfo)
	if !ok {
		that2, ok := that.(DepositInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	if !bytes.Equal(this.DepositId, that1.DepositId) {
		return false
	}
	if !bytes.Equal(this.MintId, that1.MintId) {
		return false
	}
	return true
}
func (this *MintInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MintInfo)
	if !ok {
		that2, ok := that.(MintInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	if !bytes.Equal(this.MintProtoBytes, that1.MintProtoBytes) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !this.Signatures[i].Equal(&that1.Signatures[i]) {
			return false
		}
	}
	if this.BaseFee != that1.BaseFee {
		return false
	}
	if this.PercentageFee != that1.PercentageFee {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.LastReqTime != that1.LastReqTime {
		return false
	}
	return true
}
func (this *BurnInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BurnInfo)
	if !ok {
		that2, ok := that.(BurnInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	if !bytes.Equal(this.BurnId, that1.BurnId) {
		return false
	}
	if !bytes.Equal(this.WithdrawId, that1.WithdrawId) {
		return false
	}
	return true
}
func (this *WithdrawInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithdrawInfo)
	if !ok {
		that2, ok := that.(WithdrawInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	if !bytes.Equal(this.WithdrawProtoBytes, that1.WithdrawProtoBytes) {
		return false
	}
	if len(this.Signatures) != len(that1.Signatures) {
		return false
	}
	for i := range this.Signatures {
		if !this.Signatures[i].Equal(&that1.Signatures[i]) {
			return false
		}
	}
	if this.BaseFee != that1.BaseFee {
		return false
	}
	if this.PercentageFee != that1.PercentageFee {
		return false
	}
	if this.Success != that1.Success {
		return false
	}
	if this.LastReqTime != that1.LastReqTime {
		return false
	}
	return true
}
func (this *FeeClaimInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeeClaimInfo)
	if !ok {
		that2, ok := that.(FeeClaimInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.WithdrawId, that1.WithdrawId) {
		return false
	}
	return true
}
func (this *MintOnChain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MintOnChain)
	if !ok {
		that2, ok := that.(MintOnChain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Token, that1.Token) {
		return false
	}
	if !bytes.Equal(this.Account, that1.Account) {
		return false
	}
	if !bytes.Equal(this.Amount, that1.Amount) {
		return false
	}
	if !bytes.Equal(this.Depositor, that1.Depositor) {
		return false
	}
	if this.RefChainId != that1.RefChainId {
		return false
	}
	if !bytes.Equal(this.RefId, that1.RefId) {
		return false
	}
	return true
}
func (this *WithdrawOnChain) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WithdrawOnChain)
	if !ok {
		that2, ok := that.(WithdrawOnChain)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Token, that1.Token) {
		return false
	}
	if !bytes.Equal(this.Receiver, that1.Receiver) {
		return false
	}
	if !bytes.Equal(this.Amount, that1.Amount) {
		return false
	}
	if !bytes.Equal(this.BurnAccount, that1.BurnAccount) {
		return false
	}
	if this.RefChainId != that1.RefChainId {
		return false
	}
	if !bytes.Equal(this.RefId, that1.RefId) {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TriggerSignCooldown, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerSignCooldown):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintPegbridge(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PegConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PegConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PegConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrigPeggedPairs) > 0 {
		for iNdEx := len(m.OrigPeggedPairs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrigPeggedPairs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPegbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OriginalTokenVaults) > 0 {
		for iNdEx := len(m.OriginalTokenVaults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OriginalTokenVaults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPegbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PeggedTokenBridges) > 0 {
		for iNdEx := len(m.PeggedTokenBridges) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PeggedTokenBridges[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPegbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrigPeggedPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrigPeggedPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrigPeggedPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Obsolete {
		i--
		if m.Obsolete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.MaxBurnFee) > 0 {
		i -= len(m.MaxBurnFee)
		copy(dAtA[i:], m.MaxBurnFee)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.MaxBurnFee)))
		i--
		dAtA[i] = 0x32
	}
	if m.BurnFeePips != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.BurnFeePips))
		i--
		dAtA[i] = 0x28
	}
	if len(m.MaxMintFee) > 0 {
		i -= len(m.MaxMintFee)
		copy(dAtA[i:], m.MaxMintFee)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.MaxMintFee)))
		i--
		dAtA[i] = 0x22
	}
	if m.MintFeePips != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.MintFeePips))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Pegged.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPegbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Orig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPegbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PeggedOrigIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeggedOrigIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeggedOrigIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Orig.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPegbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Pegged.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPegbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DepositInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MintId) > 0 {
		i -= len(m.MintId)
		copy(dAtA[i:], m.MintId)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.MintId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DepositId) > 0 {
		i -= len(m.DepositId)
		copy(dAtA[i:], m.DepositId)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.DepositId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MintInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastReqTime != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.LastReqTime))
		i--
		dAtA[i] = 0x38
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.PercentageFee) > 0 {
		i -= len(m.PercentageFee)
		copy(dAtA[i:], m.PercentageFee)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.PercentageFee)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BaseFee) > 0 {
		i -= len(m.BaseFee)
		copy(dAtA[i:], m.BaseFee)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.BaseFee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPegbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MintProtoBytes) > 0 {
		i -= len(m.MintProtoBytes)
		copy(dAtA[i:], m.MintProtoBytes)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.MintProtoBytes)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BurnInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WithdrawId) > 0 {
		i -= len(m.WithdrawId)
		copy(dAtA[i:], m.WithdrawId)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.WithdrawId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BurnId) > 0 {
		i -= len(m.BurnId)
		copy(dAtA[i:], m.BurnId)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.BurnId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastReqTime != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.LastReqTime))
		i--
		dAtA[i] = 0x38
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.PercentageFee) > 0 {
		i -= len(m.PercentageFee)
		copy(dAtA[i:], m.PercentageFee)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.PercentageFee)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BaseFee) > 0 {
		i -= len(m.BaseFee)
		copy(dAtA[i:], m.BaseFee)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.BaseFee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPegbridge(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WithdrawProtoBytes) > 0 {
		i -= len(m.WithdrawProtoBytes)
		copy(dAtA[i:], m.WithdrawProtoBytes)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.WithdrawProtoBytes)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeClaimInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeClaimInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeClaimInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.WithdrawId) > 0 {
		i -= len(m.WithdrawId)
		copy(dAtA[i:], m.WithdrawId)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.WithdrawId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MintOnChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintOnChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintOnChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefId) > 0 {
		i -= len(m.RefId)
		copy(dAtA[i:], m.RefId)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.RefId)))
		i--
		dAtA[i] = 0x32
	}
	if m.RefChainId != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.RefChainId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawOnChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawOnChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawOnChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefId) > 0 {
		i -= len(m.RefId)
		copy(dAtA[i:], m.RefId)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.RefId)))
		i--
		dAtA[i] = 0x32
	}
	if m.RefChainId != 0 {
		i = encodeVarintPegbridge(dAtA, i, uint64(m.RefChainId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.BurnAccount) > 0 {
		i -= len(m.BurnAccount)
		copy(dAtA[i:], m.BurnAccount)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.BurnAccount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PegProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PegProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PegProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Deposit.Size()
		i -= size
		if _, err := m.Deposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPegbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.PegConfig != nil {
		{
			size, err := m.PegConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPegbridge(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintPegbridge(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPegbridge(dAtA []byte, offset int, v uint64) int {
	offset -= sovPegbridge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerSignCooldown)
	n += 1 + l + sovPegbridge(uint64(l))
	return n
}

func (m *PegConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PeggedTokenBridges) > 0 {
		for _, e := range m.PeggedTokenBridges {
			l = e.Size()
			n += 1 + l + sovPegbridge(uint64(l))
		}
	}
	if len(m.OriginalTokenVaults) > 0 {
		for _, e := range m.OriginalTokenVaults {
			l = e.Size()
			n += 1 + l + sovPegbridge(uint64(l))
		}
	}
	if len(m.OrigPeggedPairs) > 0 {
		for _, e := range m.OrigPeggedPairs {
			l = e.Size()
			n += 1 + l + sovPegbridge(uint64(l))
		}
	}
	return n
}

func (m *OrigPeggedPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Orig.Size()
	n += 1 + l + sovPegbridge(uint64(l))
	l = m.Pegged.Size()
	n += 1 + l + sovPegbridge(uint64(l))
	if m.MintFeePips != 0 {
		n += 1 + sovPegbridge(uint64(m.MintFeePips))
	}
	l = len(m.MaxMintFee)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if m.BurnFeePips != 0 {
		n += 1 + sovPegbridge(uint64(m.BurnFeePips))
	}
	l = len(m.MaxBurnFee)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if m.Obsolete {
		n += 2
	}
	return n
}

func (m *PeggedOrigIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Pegged.Size()
	n += 1 + l + sovPegbridge(uint64(l))
	l = m.Orig.Size()
	n += 1 + l + sovPegbridge(uint64(l))
	return n
}

func (m *DepositInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovPegbridge(uint64(m.ChainId))
	}
	l = len(m.DepositId)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.MintId)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	return n
}

func (m *MintInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovPegbridge(uint64(m.ChainId))
	}
	l = len(m.MintProtoBytes)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovPegbridge(uint64(l))
		}
	}
	l = len(m.BaseFee)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.PercentageFee)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.LastReqTime != 0 {
		n += 1 + sovPegbridge(uint64(m.LastReqTime))
	}
	return n
}

func (m *BurnInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovPegbridge(uint64(m.ChainId))
	}
	l = len(m.BurnId)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.WithdrawId)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	return n
}

func (m *WithdrawInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovPegbridge(uint64(m.ChainId))
	}
	l = len(m.WithdrawProtoBytes)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovPegbridge(uint64(l))
		}
	}
	l = len(m.BaseFee)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.PercentageFee)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.LastReqTime != 0 {
		n += 1 + sovPegbridge(uint64(m.LastReqTime))
	}
	return n
}

func (m *FeeClaimInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WithdrawId)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	return n
}

func (m *MintOnChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if m.RefChainId != 0 {
		n += 1 + sovPegbridge(uint64(m.RefChainId))
	}
	l = len(m.RefId)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	return n
}

func (m *WithdrawOnChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.BurnAccount)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if m.RefChainId != 0 {
		n += 1 + sovPegbridge(uint64(m.RefChainId))
	}
	l = len(m.RefId)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	return n
}

func (m *PegProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPegbridge(uint64(l))
	}
	if m.PegConfig != nil {
		l = m.PegConfig.Size()
		n += 1 + l + sovPegbridge(uint64(l))
	}
	l = m.Deposit.Size()
	n += 1 + l + sovPegbridge(uint64(l))
	return n
}

func sovPegbridge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPegbridge(x uint64) (n int) {
	return sovPegbridge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerSignCooldown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TriggerSignCooldown, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PegConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PegConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PegConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeggedTokenBridges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeggedTokenBridges = append(m.PeggedTokenBridges, types.ContractInfo{})
			if err := m.PeggedTokenBridges[len(m.PeggedTokenBridges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalTokenVaults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalTokenVaults = append(m.OriginalTokenVaults, types.ContractInfo{})
			if err := m.OriginalTokenVaults[len(m.OriginalTokenVaults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrigPeggedPairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrigPeggedPairs = append(m.OrigPeggedPairs, OrigPeggedPair{})
			if err := m.OrigPeggedPairs[len(m.OrigPeggedPairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrigPeggedPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrigPeggedPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrigPeggedPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Orig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pegged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pegged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintFeePips", wireType)
			}
			m.MintFeePips = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MintFeePips |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMintFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxMintFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnFeePips", wireType)
			}
			m.BurnFeePips = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BurnFeePips |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurnFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxBurnFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Obsolete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Obsolete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeggedOrigIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeggedOrigIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeggedOrigIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pegged", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pegged.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Orig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DepositId = append(m.DepositId[:0], dAtA[iNdEx:postIndex]...)
			if m.DepositId == nil {
				m.DepositId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintId = append(m.MintId[:0], dAtA[iNdEx:postIndex]...)
			if m.MintId == nil {
				m.MintId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintProtoBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintProtoBytes = append(m.MintProtoBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.MintProtoBytes == nil {
				m.MintProtoBytes = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, types.Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentageFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercentageFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReqTime", wireType)
			}
			m.LastReqTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReqTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurnInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnId = append(m.BurnId[:0], dAtA[iNdEx:postIndex]...)
			if m.BurnId == nil {
				m.BurnId = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawId = append(m.WithdrawId[:0], dAtA[iNdEx:postIndex]...)
			if m.WithdrawId == nil {
				m.WithdrawId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawProtoBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawProtoBytes = append(m.WithdrawProtoBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.WithdrawProtoBytes == nil {
				m.WithdrawProtoBytes = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, types.Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercentageFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercentageFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReqTime", wireType)
			}
			m.LastReqTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReqTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeClaimInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeClaimInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeClaimInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawId = append(m.WithdrawId[:0], dAtA[iNdEx:postIndex]...)
			if m.WithdrawId == nil {
				m.WithdrawId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintOnChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintOnChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintOnChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token[:0], dAtA[iNdEx:postIndex]...)
			if m.Token == nil {
				m.Token = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = append(m.Account[:0], dAtA[iNdEx:postIndex]...)
			if m.Account == nil {
				m.Account = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount[:0], dAtA[iNdEx:postIndex]...)
			if m.Amount == nil {
				m.Amount = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = append(m.Depositor[:0], dAtA[iNdEx:postIndex]...)
			if m.Depositor == nil {
				m.Depositor = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefChainId", wireType)
			}
			m.RefChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefId = append(m.RefId[:0], dAtA[iNdEx:postIndex]...)
			if m.RefId == nil {
				m.RefId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawOnChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawOnChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawOnChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token[:0], dAtA[iNdEx:postIndex]...)
			if m.Token == nil {
				m.Token = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = append(m.Receiver[:0], dAtA[iNdEx:postIndex]...)
			if m.Receiver == nil {
				m.Receiver = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount[:0], dAtA[iNdEx:postIndex]...)
			if m.Amount == nil {
				m.Amount = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnAccount", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BurnAccount = append(m.BurnAccount[:0], dAtA[iNdEx:postIndex]...)
			if m.BurnAccount == nil {
				m.BurnAccount = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefChainId", wireType)
			}
			m.RefChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefId = append(m.RefId[:0], dAtA[iNdEx:postIndex]...)
			if m.RefId == nil {
				m.RefId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PegProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PegProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PegProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PegConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PegConfig == nil {
				m.PegConfig = &PegConfig{}
			}
			if err := m.PegConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPegbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPegbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPegbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPegbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPegbridge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPegbridge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPegbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPegbridge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPegbridge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPegbridge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPegbridge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPegbridge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPegbridge = fmt.Errorf("proto: unexpected end of group")
)
