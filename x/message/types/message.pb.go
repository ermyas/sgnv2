// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/message/v1/message.proto

package types

import (
	fmt "fmt"
	types "github.com/celer-network/sgn-v2/common/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/regen-network/cosmos-proto"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TransferType defines the type of a transfer associated with a message, if applicable.
type TransferType int32

const (
	// TRANSFER_TYPE_NULL indicates no transfer association.
	TRANSFER_TYPE_NULL TransferType = 0
	// TRANSFER_TYPE_LIQUIDITY_SEND defines a send transfer via a liquidity bridge.
	TRANSFER_TYPE_LIQUIDITY_SEND TransferType = 1
	// TRANSFER_TYPE_LIQUIDITY_WITHDRAW defines a withdraw transfer from a liquidity bridge.
	TRANSFER_TYPE_LIQUIDITY_WITHDRAW TransferType = 2
	// TRANSFER_TYPE_PEG_MINT defines a mint transfer via a pegged token bridge.
	TRANSFER_TYPE_PEG_MINT TransferType = 3
	// TRANSFER_TYPE_PEG_MINT defines a withdraw transfer from an original token vault.
	TRANSFER_TYPE_PEG_WITHDRAW TransferType = 4
	// TRANSFER_TYPE_PEG_MINT_V2 defines a mint transfer via a pegged token bridge v2.
	TRANSFER_TYPE_PEG_MINT_V2 TransferType = 5
	// TRANSFER_TYPE_PEG_MINT_V2 defines a withdraw transfer from an original token vault v2.
	TRANSFER_TYPE_PEG_WITHDRAW_V2 TransferType = 6
)

var TransferType_name = map[int32]string{
	0: "TRANSFER_TYPE_NULL",
	1: "TRANSFER_TYPE_LIQUIDITY_SEND",
	2: "TRANSFER_TYPE_LIQUIDITY_WITHDRAW",
	3: "TRANSFER_TYPE_PEG_MINT",
	4: "TRANSFER_TYPE_PEG_WITHDRAW",
	5: "TRANSFER_TYPE_PEG_MINT_V2",
	6: "TRANSFER_TYPE_PEG_WITHDRAW_V2",
}

var TransferType_value = map[string]int32{
	"TRANSFER_TYPE_NULL":               0,
	"TRANSFER_TYPE_LIQUIDITY_SEND":     1,
	"TRANSFER_TYPE_LIQUIDITY_WITHDRAW": 2,
	"TRANSFER_TYPE_PEG_MINT":           3,
	"TRANSFER_TYPE_PEG_WITHDRAW":       4,
	"TRANSFER_TYPE_PEG_MINT_V2":        5,
	"TRANSFER_TYPE_PEG_WITHDRAW_V2":    6,
}

func (x TransferType) String() string {
	return proto.EnumName(TransferType_name, int32(x))
}

func (TransferType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{0}
}

// ExecutionStatus defines the on-chain execution status of a message.
type ExecutionStatus int32

const (
	// EXECUTION_STATUS_PENDING defines the pending on-chain execution status.
	EXECUTION_STATUS_PENDING ExecutionStatus = 0
	// EXECUTION_STATUS_SUCCESS defines the successful on-chain execution status.
	EXECUTION_STATUS_SUCCESS ExecutionStatus = 1
	// EXECUTION_STATUS_FAILURE defines the failed on-chain execution status.
	EXECUTION_STATUS_FAILURE ExecutionStatus = 2
	// EXECUTION_STATUS_FALLBACK defines the fallback on-chain execution status.
	EXECUTION_STATUS_FALLBACK ExecutionStatus = 3
)

var ExecutionStatus_name = map[int32]string{
	0: "EXECUTION_STATUS_PENDING",
	1: "EXECUTION_STATUS_SUCCESS",
	2: "EXECUTION_STATUS_FAILURE",
	3: "EXECUTION_STATUS_FALLBACK",
}

var ExecutionStatus_value = map[string]int32{
	"EXECUTION_STATUS_PENDING":  0,
	"EXECUTION_STATUS_SUCCESS":  1,
	"EXECUTION_STATUS_FAILURE":  2,
	"EXECUTION_STATUS_FALLBACK": 3,
}

func (x ExecutionStatus) String() string {
	return proto.EnumName(ExecutionStatus_name, int32(x))
}

func (ExecutionStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{1}
}

// MsgType defines enum in contract MessageReceiver.sol
type MsgType int32

const (
	MsgType_MSG_TYPE_MESSAGE_WITH_TRANSFER MsgType = 0
	MsgType_MSG_TYPE_MESSAGE               MsgType = 1
)

var MsgType_name = map[int32]string{
	0: "MSG_TYPE_MESSAGE_WITH_TRANSFER",
	1: "MSG_TYPE_MESSAGE",
}

var MsgType_value = map[string]int32{
	"MSG_TYPE_MESSAGE_WITH_TRANSFER": 0,
	"MSG_TYPE_MESSAGE":               1,
}

func (x MsgType) String() string {
	return proto.EnumName(MsgType_name, int32(x))
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{2}
}

type BridgeType int32

const (
	BRIDGE_TYPE_NULL       BridgeType = 0
	BRIDGE_TYPE_LIQUIDITY  BridgeType = 1
	BRIDGE_TYPE_PEG_VAULT  BridgeType = 2
	BRIDGE_TYPE_PEG_BRIDGE BridgeType = 3
)

var BridgeType_name = map[int32]string{
	0: "BRIDGE_TYPE_NULL",
	1: "BRIDGE_TYPE_LIQUIDITY",
	2: "BRIDGE_TYPE_PEG_VAULT",
	3: "BRIDGE_TYPE_PEG_BRIDGE",
}

var BridgeType_value = map[string]int32{
	"BRIDGE_TYPE_NULL":       0,
	"BRIDGE_TYPE_LIQUIDITY":  1,
	"BRIDGE_TYPE_PEG_VAULT":  2,
	"BRIDGE_TYPE_PEG_BRIDGE": 3,
}

func (x BridgeType) String() string {
	return proto.EnumName(BridgeType_name, int32(x))
}

func (BridgeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{3}
}

// Params defines the parameters for the module.
type Params struct {
	// trigger_sign_cooldown defines the minimal time between two trigger signing requests.
	TriggerSignCooldown time.Duration `protobuf:"bytes,1,opt,name=trigger_sign_cooldown,json=triggerSignCooldown,proto3,stdduration" json:"trigger_sign_cooldown,omitempty" yaml:"trigger_sign_cooldown"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetTriggerSignCooldown() time.Duration {
	if m != nil {
		return m.TriggerSignCooldown
	}
	return 0
}

// Message describes the info of a cross-chain message.
type Message struct {
	// src_chain_id defines the source EVM chain ID.
	SrcChainId uint64 `protobuf:"varint,1,opt,name=src_chain_id,json=srcChainId,proto3" json:"src_chain_id,omitempty" yaml:"src_chain_id"`
	// sender defines the sender EVM address.
	Sender string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty" yaml:"sender"`
	// dst_chain_id defines the destination EVM chain ID.
	DstChainId uint64 `protobuf:"varint,3,opt,name=dst_chain_id,json=dstChainId,proto3" json:"dst_chain_id,omitempty" yaml:"dst_chain_id"`
	// receiver defines the receiver EVM address.
	Receiver string `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty" yaml:"receiver"`
	// data defines the message data.
	Data []byte `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty" yaml:"data"`
	// fee defines the message fee paid to SGN.
	Fee string `protobuf:"bytes,6,opt,name=fee,proto3" json:"fee,omitempty" yaml:"fee"`
	// transfer_type defines the associated type of transfer.
	TransferType TransferType `protobuf:"varint,7,opt,name=transfer_type,json=transferType,proto3,enum=sgn.message.v1.TransferType" json:"transfer_type,omitempty" yaml:"transfer_type"`
	// transfer_ref_id defines the reference ID of the transfer.
	// For sending via a liquidity bridge, ref_id is the src transfer ID.
	// For mint / withdrawal via a pegged bridge, ref_id is the reference ID of the pegged transfer.
	TransferRefId []byte `protobuf:"bytes,11,opt,name=transfer_ref_id,json=transferRefId,proto3" json:"transfer_ref_id,omitempty" yaml:"transfer"`
	// execution_status defines the on-chain execution status.
	ExecutionStatus ExecutionStatus `protobuf:"varint,8,opt,name=execution_status,json=executionStatus,proto3,enum=sgn.message.v1.ExecutionStatus" json:"execution_status,omitempty" yaml:"execution_status"`
	// signatures defines the signatures to be verified on MessageBus.
	Signatures []types.Signature `protobuf:"bytes,9,rep,name=signatures,proto3" json:"signatures" yaml:"signatures"`
	// last_sig_req_time defines the latest timestamp a signing request was made.
	// Used for anti-dos.
	LastSigReqTime int64 `protobuf:"varint,10,opt,name=last_sig_req_time,json=lastSigReqTime,proto3" json:"last_sig_req_time,omitempty" yaml:"last_sig_req_time"`
	// source tx hash of the message
	SrcTxHash string `protobuf:"bytes,12,opt,name=src_tx_hash,json=srcTxHash,proto3" json:"src_tx_hash,omitempty" yaml:"receiver"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{1}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetSrcChainId() uint64 {
	if m != nil {
		return m.SrcChainId
	}
	return 0
}

func (m *Message) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *Message) GetDstChainId() uint64 {
	if m != nil {
		return m.DstChainId
	}
	return 0
}

func (m *Message) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func (m *Message) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Message) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *Message) GetTransferType() TransferType {
	if m != nil {
		return m.TransferType
	}
	return TRANSFER_TYPE_NULL
}

func (m *Message) GetTransferRefId() []byte {
	if m != nil {
		return m.TransferRefId
	}
	return nil
}

func (m *Message) GetExecutionStatus() ExecutionStatus {
	if m != nil {
		return m.ExecutionStatus
	}
	return EXECUTION_STATUS_PENDING
}

func (m *Message) GetSignatures() []types.Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *Message) GetLastSigReqTime() int64 {
	if m != nil {
		return m.LastSigReqTime
	}
	return 0
}

func (m *Message) GetSrcTxHash() string {
	if m != nil {
		return m.SrcTxHash
	}
	return ""
}

// Transfer defines the optional transfer info associated with a message.
// This is not directly stored in consensus db.
type Transfer struct {
	// token defines the token address of a transfer.
	Token []byte `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty" yaml:"token"`
	// amount defines the amount of a transfer.
	Amount string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty" yaml:"amount"`
	// seq_num defines the sequence number required for withdrawals from a liquidity bridge.
	SeqNum uint64 `protobuf:"varint,3,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty" yaml:"seq_num"`
}

func (m *Transfer) Reset()         { *m = Transfer{} }
func (m *Transfer) String() string { return proto.CompactTextString(m) }
func (*Transfer) ProtoMessage()    {}
func (*Transfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{2}
}
func (m *Transfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transfer.Merge(m, src)
}
func (m *Transfer) XXX_Size() int {
	return m.Size()
}
func (m *Transfer) XXX_DiscardUnknown() {
	xxx_messageInfo_Transfer.DiscardUnknown(m)
}

var xxx_messageInfo_Transfer proto.InternalMessageInfo

func (m *Transfer) GetToken() []byte {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *Transfer) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Transfer) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

// ExecutionContext defines all the info needed for executing a message.
type ExecutionContext struct {
	// message_id defines the message ID.
	MessageId []byte `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty" yaml:"message_id"`
	// message defines the message to be executed, along with the required relayer signatures.
	Message Message `protobuf:"bytes,2,opt,name=message,proto3" json:"message" yaml:"message"`
	// transfer defines the optional transfer info associated with the message.
	// it is not stored in consensus db, but derived from message fields.
	Transfer *Transfer `protobuf:"bytes,3,opt,name=transfer,proto3" json:"transfer,omitempty" yaml:"transfer"`
}

func (m *ExecutionContext) Reset()         { *m = ExecutionContext{} }
func (m *ExecutionContext) String() string { return proto.CompactTextString(m) }
func (*ExecutionContext) ProtoMessage()    {}
func (*ExecutionContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{3}
}
func (m *ExecutionContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionContext.Merge(m, src)
}
func (m *ExecutionContext) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionContext) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionContext.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionContext proto.InternalMessageInfo

func (m *ExecutionContext) GetMessageId() []byte {
	if m != nil {
		return m.MessageId
	}
	return nil
}

func (m *ExecutionContext) GetMessage() Message {
	if m != nil {
		return m.Message
	}
	return Message{}
}

func (m *ExecutionContext) GetTransfer() *Transfer {
	if m != nil {
		return m.Transfer
	}
	return nil
}

// FeeClaimDetails describes the fees to be claimed on the EVM chain.
type FeeClaimDetails struct {
	// chain_id defines the EVM chain ID for the claim.
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// cumulative_fee_amount defines the cumulative fees claimable on the EVM chain.
	CumulativeFeeAmount types1.DecCoin `protobuf:"bytes,2,opt,name=cumulative_fee_amount,json=cumulativeFeeAmount,proto3" json:"cumulative_fee_amount" yaml:"cumulative_fee_amount"`
	// signatures defines the signatures to be verified on the EVM chain.
	Signatures []types.Signature `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures" yaml:"signatures"`
}

func (m *FeeClaimDetails) Reset()         { *m = FeeClaimDetails{} }
func (m *FeeClaimDetails) String() string { return proto.CompactTextString(m) }
func (*FeeClaimDetails) ProtoMessage()    {}
func (*FeeClaimDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{4}
}
func (m *FeeClaimDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeClaimDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeClaimDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeClaimDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeClaimDetails.Merge(m, src)
}
func (m *FeeClaimDetails) XXX_Size() int {
	return m.Size()
}
func (m *FeeClaimDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeClaimDetails.DiscardUnknown(m)
}

var xxx_messageInfo_FeeClaimDetails proto.InternalMessageInfo

func (m *FeeClaimDetails) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *FeeClaimDetails) GetCumulativeFeeAmount() types1.DecCoin {
	if m != nil {
		return m.CumulativeFeeAmount
	}
	return types1.DecCoin{}
}

func (m *FeeClaimDetails) GetSignatures() []types.Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// FeeClaimInfo describes the fee claim metadata and details for a recipient.
type FeeClaimInfo struct {
	// recipient defines the Ethereum address of the fee recipient.
	Recipient string `protobuf:"bytes,1,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// last_claim_time defines the last time a fee claim was signed by the validators.
	LastClaimTime time.Time `protobuf:"bytes,2,opt,name=last_claim_time,json=lastClaimTime,proto3,stdtime" json:"last_claim_time" yaml:"last_claim_time"`
	// fee_claim_details_list defines the list of fee claim details
	FeeClaimDetailsList []FeeClaimDetails `protobuf:"bytes,3,rep,name=fee_claim_details_list,json=feeClaimDetailsList,proto3" json:"fee_claim_details_list" yaml:"fee_claim_details_list"`
}

func (m *FeeClaimInfo) Reset()         { *m = FeeClaimInfo{} }
func (m *FeeClaimInfo) String() string { return proto.CompactTextString(m) }
func (*FeeClaimInfo) ProtoMessage()    {}
func (*FeeClaimInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{5}
}
func (m *FeeClaimInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeClaimInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeClaimInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeClaimInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeClaimInfo.Merge(m, src)
}
func (m *FeeClaimInfo) XXX_Size() int {
	return m.Size()
}
func (m *FeeClaimInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeClaimInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FeeClaimInfo proto.InternalMessageInfo

func (m *FeeClaimInfo) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *FeeClaimInfo) GetLastClaimTime() time.Time {
	if m != nil {
		return m.LastClaimTime
	}
	return time.Time{}
}

func (m *FeeClaimInfo) GetFeeClaimDetailsList() []FeeClaimDetails {
	if m != nil {
		return m.FeeClaimDetailsList
	}
	return nil
}

// MessageBusInfo defines the info of a MessageBus contract.
type MessageBusInfo struct {
	// contract_info defines the MessageBus contract info.
	ContractInfo *types.ContractInfo `protobuf:"bytes,1,opt,name=contract_info,json=contractInfo,proto3" json:"contract_info,omitempty" yaml:"contract_info"`
	// fee_token_symbol defines the symbol of the native gas token to pay message fees.
	FeeTokenSymbol string `protobuf:"bytes,2,opt,name=fee_token_symbol,json=feeTokenSymbol,proto3" json:"fee_token_symbol,omitempty" yaml:"fee_token_symbol"`
}

func (m *MessageBusInfo) Reset()         { *m = MessageBusInfo{} }
func (m *MessageBusInfo) String() string { return proto.CompactTextString(m) }
func (*MessageBusInfo) ProtoMessage()    {}
func (*MessageBusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{6}
}
func (m *MessageBusInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageBusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageBusInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageBusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageBusInfo.Merge(m, src)
}
func (m *MessageBusInfo) XXX_Size() int {
	return m.Size()
}
func (m *MessageBusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageBusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MessageBusInfo proto.InternalMessageInfo

func (m *MessageBusInfo) GetContractInfo() *types.ContractInfo {
	if m != nil {
		return m.ContractInfo
	}
	return nil
}

func (m *MessageBusInfo) GetFeeTokenSymbol() string {
	if m != nil {
		return m.FeeTokenSymbol
	}
	return ""
}

// MsgProposal describes a message config proposal, note it must be a whole json
type MsgProposal struct {
	// title defines the title of the proposal.
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty" yaml:"title"`
	// description defines the proposal description.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	// message_buses defines the list of MessageBus infos to update.
	MessageBuses []*MessageBusInfo `protobuf:"bytes,3,rep,name=message_buses,json=messageBuses,proto3" json:"message_buses,omitempty" yaml:"message_buses"`
	// deposit defines the amount for MsgSubmitProposal
	Deposit github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=deposit,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"deposit" yaml:"deposit"`
}

func (m *MsgProposal) Reset()         { *m = MsgProposal{} }
func (m *MsgProposal) String() string { return proto.CompactTextString(m) }
func (*MsgProposal) ProtoMessage()    {}
func (*MsgProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_1199d6c48a0ec756, []int{7}
}
func (m *MsgProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposal.Merge(m, src)
}
func (m *MsgProposal) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposal proto.InternalMessageInfo

func (m *MsgProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MsgProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgProposal) GetMessageBuses() []*MessageBusInfo {
	if m != nil {
		return m.MessageBuses
	}
	return nil
}

func init() {
	proto.RegisterEnum("sgn.message.v1.TransferType", TransferType_name, TransferType_value)
	proto.RegisterEnum("sgn.message.v1.ExecutionStatus", ExecutionStatus_name, ExecutionStatus_value)
	proto.RegisterEnum("sgn.message.v1.MsgType", MsgType_name, MsgType_value)
	proto.RegisterEnum("sgn.message.v1.BridgeType", BridgeType_name, BridgeType_value)
	proto.RegisterType((*Params)(nil), "sgn.message.v1.Params")
	proto.RegisterType((*Message)(nil), "sgn.message.v1.Message")
	proto.RegisterType((*Transfer)(nil), "sgn.message.v1.Transfer")
	proto.RegisterType((*ExecutionContext)(nil), "sgn.message.v1.ExecutionContext")
	proto.RegisterType((*FeeClaimDetails)(nil), "sgn.message.v1.FeeClaimDetails")
	proto.RegisterType((*FeeClaimInfo)(nil), "sgn.message.v1.FeeClaimInfo")
	proto.RegisterType((*MessageBusInfo)(nil), "sgn.message.v1.MessageBusInfo")
	proto.RegisterType((*MsgProposal)(nil), "sgn.message.v1.MsgProposal")
}

func init() { proto.RegisterFile("sgn/message/v1/message.proto", fileDescriptor_1199d6c48a0ec756) }

var fileDescriptor_1199d6c48a0ec756 = []byte{
	// 1525 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x73, 0xdb, 0xc6,
	0x15, 0x27, 0xf4, 0x45, 0x69, 0x49, 0x91, 0xf0, 0xea, 0xc3, 0x94, 0x4c, 0x13, 0xec, 0xd6, 0xf5,
	0xa8, 0x6e, 0x45, 0x8e, 0xe4, 0x1e, 0x5a, 0xf7, 0x52, 0x82, 0xa4, 0x64, 0x8c, 0x29, 0x56, 0x05,
	0x28, 0xbb, 0x76, 0xa7, 0x83, 0x81, 0xc0, 0x25, 0x84, 0x31, 0x01, 0x50, 0xd8, 0xa5, 0x2c, 0xb5,
	0xff, 0x40, 0xa7, 0x27, 0xe7, 0xe6, 0xc9, 0xc9, 0x33, 0x39, 0xe6, 0x98, 0xdc, 0xf2, 0x0f, 0xf8,
	0xe8, 0xc9, 0x29, 0x93, 0x03, 0x92, 0xb1, 0x2f, 0x99, 0x1c, 0x79, 0x4a, 0x6e, 0x99, 0x05, 0x16,
	0xfc, 0x12, 0x75, 0xcb, 0x89, 0xd8, 0xf7, 0x7e, 0x6f, 0xdf, 0xd7, 0xef, 0xbd, 0x95, 0x40, 0x9e,
	0x58, 0x6e, 0xd9, 0xc1, 0x84, 0x18, 0x16, 0x2e, 0x5f, 0xec, 0xc5, 0x9f, 0xa5, 0x9e, 0xef, 0x51,
	0x0f, 0x66, 0x88, 0xe5, 0x96, 0x62, 0xd1, 0xc5, 0xde, 0xf6, 0x96, 0xe9, 0x11, 0xc7, 0x23, 0x7a,
	0xa8, 0x2d, 0x47, 0x87, 0x08, 0xba, 0x5d, 0x88, 0x4e, 0xe5, 0x53, 0x83, 0xb0, 0x8b, 0x4e, 0x31,
	0x35, 0xf6, 0xca, 0xa6, 0x67, 0xbb, 0x5c, 0xbf, 0x6e, 0x79, 0x96, 0x17, 0xd9, 0xb1, 0xaf, 0xd8,
	0xca, 0xf2, 0x3c, 0xab, 0x8b, 0xcb, 0xe1, 0xe9, 0xb4, 0xdf, 0x29, 0xb7, 0xfb, 0xbe, 0x41, 0x6d,
	0x2f, 0xb6, 0x92, 0xa6, 0xf5, 0xd4, 0x76, 0x30, 0xa1, 0x86, 0xd3, 0xe3, 0x80, 0x6d, 0x16, 0xbf,
	0xe9, 0x39, 0x8e, 0xe7, 0xb2, 0xf0, 0xa3, 0xaf, 0x48, 0x87, 0x3e, 0x17, 0xc0, 0xd2, 0xb1, 0xe1,
	0x1b, 0x0e, 0x81, 0x9f, 0x0a, 0x60, 0x83, 0xfa, 0xb6, 0x65, 0x61, 0x5f, 0x27, 0xb6, 0xe5, 0xea,
	0xa6, 0xe7, 0x75, 0xdb, 0xde, 0x2b, 0x37, 0x27, 0x14, 0x85, 0x9d, 0xd4, 0xfe, 0x56, 0x29, 0x72,
	0x54, 0x8a, 0x1d, 0x95, 0x6a, 0x3c, 0x10, 0xf9, 0xc9, 0xbb, 0x40, 0x4a, 0xfc, 0x18, 0x48, 0xd2,
	0x4c, 0xfb, 0x3f, 0x7a, 0x8e, 0x4d, 0xb1, 0xd3, 0xa3, 0x57, 0x83, 0x40, 0xca, 0x5f, 0x19, 0x4e,
	0xf7, 0x11, 0x9a, 0x09, 0x44, 0x6f, 0xbe, 0x93, 0x04, 0x75, 0x8d, 0xeb, 0x34, 0xdb, 0x72, 0xab,
	0x5c, 0xf3, 0x68, 0xe1, 0xcd, 0x5b, 0x29, 0x81, 0x7e, 0x5a, 0x04, 0xc9, 0xa3, 0xa8, 0xd4, 0xf0,
	0x2f, 0x20, 0x4d, 0x7c, 0x53, 0x37, 0xcf, 0x0c, 0xdb, 0xd5, 0xed, 0x76, 0x18, 0xe4, 0x82, 0x7c,
	0x7b, 0x10, 0x48, 0x6b, 0x91, 0x8b, 0x71, 0x2d, 0x52, 0x01, 0xf1, 0xcd, 0x2a, 0x3b, 0x29, 0x6d,
	0xf8, 0x7b, 0xb0, 0x44, 0xb0, 0xdb, 0xc6, 0x7e, 0x6e, 0xae, 0x28, 0xec, 0xac, 0xc8, 0xb7, 0x06,
	0x81, 0xb4, 0xca, 0x8d, 0x42, 0x39, 0x52, 0x39, 0x80, 0x79, 0x69, 0x13, 0x3a, 0xf2, 0x32, 0x3f,
	0xed, 0x65, 0x5c, 0x8b, 0x54, 0xd0, 0x26, 0x34, 0xf6, 0x52, 0x06, 0xcb, 0x3e, 0x36, 0xb1, 0x7d,
	0x81, 0xfd, 0xdc, 0x42, 0xe8, 0x67, 0x6d, 0x10, 0x48, 0xd9, 0xc8, 0x2c, 0xd6, 0x20, 0x75, 0x08,
	0x82, 0xbf, 0x05, 0x0b, 0x6d, 0x83, 0x1a, 0xb9, 0xc5, 0xa2, 0xb0, 0x93, 0x96, 0xb3, 0x83, 0x40,
	0x4a, 0x71, 0x1f, 0x06, 0x35, 0x90, 0x1a, 0x2a, 0x61, 0x11, 0xcc, 0x77, 0x30, 0xce, 0x2d, 0x85,
	0x17, 0x66, 0x06, 0x81, 0x04, 0x22, 0x4c, 0x07, 0x63, 0xa4, 0x32, 0x15, 0xfc, 0x17, 0x58, 0xa5,
	0xbe, 0xe1, 0x92, 0x0e, 0xf6, 0x75, 0x7a, 0xd5, 0xc3, 0xb9, 0x64, 0x51, 0xd8, 0xc9, 0xec, 0xe7,
	0x4b, 0x93, 0x44, 0x2d, 0xb5, 0x38, 0xa8, 0x75, 0xd5, 0xc3, 0x72, 0x6e, 0x10, 0x48, 0xeb, 0x71,
	0x6b, 0xc6, 0x8c, 0x91, 0x9a, 0xa6, 0x63, 0x38, 0xf8, 0x57, 0x90, 0x1d, 0xea, 0x7d, 0xdc, 0x61,
	0x25, 0x49, 0x85, 0xe1, 0x8e, 0xe5, 0x16, 0x03, 0x90, 0x3a, 0x0c, 0x44, 0xc5, 0x1d, 0xa5, 0x0d,
	0x2d, 0x20, 0xe2, 0x4b, 0x6c, 0xf6, 0x19, 0x67, 0x74, 0x42, 0x0d, 0xda, 0x27, 0xb9, 0xe5, 0x30,
	0x38, 0x69, 0x3a, 0xb8, 0x7a, 0x8c, 0xd3, 0x42, 0x98, 0x7c, 0x67, 0x10, 0x48, 0xb7, 0xa3, 0xeb,
	0xa7, 0xaf, 0x40, 0x6a, 0x16, 0x4f, 0xa2, 0xa1, 0x06, 0x00, 0x23, 0x96, 0x41, 0xfb, 0x3e, 0x26,
	0xb9, 0x95, 0xe2, 0xfc, 0x4e, 0x6a, 0x3f, 0x17, 0xba, 0xe0, 0xe4, 0xbf, 0xd8, 0x2b, 0x69, 0x31,
	0x40, 0xde, 0x62, 0xec, 0x1d, 0x04, 0xd2, 0x2d, 0x4e, 0x81, 0xa1, 0x25, 0x63, 0xcd, 0xf0, 0x00,
	0x0f, 0xc1, 0xad, 0xae, 0x41, 0x28, 0xa3, 0xac, 0xee, 0xe3, 0x73, 0x9d, 0x8d, 0x59, 0x0e, 0x14,
	0x85, 0x9d, 0x79, 0x39, 0x3f, 0x08, 0xa4, 0x5c, 0x64, 0x7d, 0x0d, 0x82, 0xd4, 0x0c, 0x93, 0x69,
	0xb6, 0xa5, 0xe2, 0xf3, 0x96, 0xed, 0x60, 0xf8, 0x10, 0xa4, 0x18, 0x37, 0xe9, 0xa5, 0x7e, 0x66,
	0x90, 0xb3, 0x5c, 0xfa, 0x66, 0x6e, 0xac, 0x10, 0xdf, 0x6c, 0x5d, 0x3e, 0x36, 0xc8, 0x19, 0xfa,
	0xbf, 0x00, 0x96, 0xe3, 0x8e, 0xc1, 0xfb, 0x60, 0x91, 0x7a, 0x2f, 0x71, 0x34, 0x99, 0x69, 0x59,
	0x1c, 0x04, 0x52, 0x9a, 0xd7, 0x9e, 0x89, 0x91, 0x1a, 0xa9, 0x19, 0xd1, 0x0d, 0xc7, 0xeb, 0xbb,
	0xf4, 0x3a, 0xd1, 0x23, 0x39, 0x52, 0x39, 0x00, 0xfe, 0x01, 0x24, 0x09, 0x3e, 0xd7, 0xdd, 0xbe,
	0xc3, 0x39, 0x0e, 0x07, 0x81, 0x94, 0x89, 0x87, 0x22, 0x54, 0x84, 0x53, 0x71, 0xde, 0xec, 0x3b,
	0x28, 0x10, 0x80, 0x38, 0xec, 0x50, 0xd5, 0x73, 0x29, 0xbe, 0xa4, 0xf0, 0x4f, 0x00, 0xf0, 0x06,
	0xc6, 0xe3, 0x98, 0x96, 0x37, 0x46, 0x65, 0x1d, 0xe9, 0x90, 0xba, 0xc2, 0x0f, 0x4a, 0x1b, 0x2a,
	0x20, 0xc9, 0x0f, 0x61, 0x8c, 0xa9, 0xfd, 0xdb, 0xd3, 0x54, 0xe0, 0x03, 0x2f, 0x6f, 0xf2, 0x36,
	0x65, 0x26, 0xee, 0x43, 0x6a, 0x6c, 0x0f, 0x15, 0xb0, 0x1c, 0xf3, 0x2d, 0xcc, 0x21, 0xee, 0xf9,
	0x0c, 0xce, 0xcf, 0xa6, 0xeb, 0xd0, 0x1c, 0xfd, 0x2c, 0x80, 0xec, 0x01, 0xc6, 0xd5, 0xae, 0x61,
	0x3b, 0x35, 0x4c, 0x0d, 0xbb, 0x4b, 0xe0, 0x16, 0x58, 0x9e, 0x5c, 0x36, 0x6a, 0xd2, 0xe4, 0xa3,
	0x7e, 0x01, 0x36, 0xcc, 0xbe, 0xd3, 0xef, 0x1a, 0xd4, 0xbe, 0xc0, 0x7a, 0x07, 0x63, 0x7d, 0xac,
	0xec, 0xa9, 0xfd, 0x7c, 0x89, 0x3f, 0x03, 0x6c, 0xf1, 0x97, 0xf8, 0xe2, 0x2f, 0xd5, 0xb0, 0x59,
	0xf5, 0x6c, 0x57, 0xbe, 0xc7, 0xf3, 0xe2, 0x9b, 0x71, 0xe6, 0x45, 0x48, 0x5d, 0x1b, 0xc9, 0x0f,
	0x30, 0xae, 0x44, 0x4d, 0x9b, 0xe4, 0xf9, 0xfc, 0xaf, 0xc2, 0x73, 0xf4, 0xc9, 0x1c, 0x48, 0xc7,
	0xb9, 0x2b, 0x6e, 0xc7, 0x83, 0x79, 0xb0, 0xe2, 0x63, 0xd3, 0xee, 0xd9, 0xd8, 0xa5, 0x61, 0xe6,
	0x2b, 0xea, 0x48, 0x00, 0x3b, 0x20, 0x1b, 0x72, 0xde, 0x64, 0xf8, 0x68, 0x28, 0xa2, 0xac, 0xb7,
	0xaf, 0xbd, 0x17, 0xad, 0xf8, 0x61, 0x92, 0x11, 0x0f, 0x65, 0x73, 0x6c, 0x68, 0x46, 0x17, 0xa0,
	0xd7, 0xec, 0x1d, 0x58, 0x65, 0xd2, 0x30, 0x8a, 0x70, 0x6a, 0xfe, 0x0b, 0x36, 0x59, 0x3d, 0x22,
	0x54, 0x3b, 0xea, 0x89, 0xde, 0xb5, 0x09, 0xe5, 0x79, 0x5f, 0x5b, 0x21, 0x53, 0xfd, 0x93, 0x7f,
	0xc7, 0x7d, 0xde, 0x1d, 0x2e, 0xcc, 0x19, 0x97, 0x21, 0x75, 0xad, 0x33, 0x69, 0xd7, 0x60, 0xd2,
	0x2f, 0x04, 0x90, 0x89, 0x79, 0xd8, 0x27, 0x61, 0x55, 0x5e, 0x80, 0x55, 0xd3, 0x73, 0xa9, 0x6f,
	0x98, 0x54, 0xb7, 0xdd, 0x8e, 0xc7, 0x5f, 0xc9, 0x3b, 0x53, 0xe5, 0xaf, 0x72, 0x0c, 0xb3, 0x19,
	0xdf, 0xb2, 0x13, 0xb6, 0x48, 0x4d, 0x9b, 0x63, 0x38, 0x58, 0x07, 0x22, 0x0b, 0x2f, 0x1c, 0x62,
	0x9d, 0x5c, 0x39, 0xa7, 0x5e, 0x97, 0x4f, 0xf0, 0xd8, 0x1e, 0x9c, 0x46, 0x20, 0x35, 0xd3, 0xc1,
	0xb8, 0xc5, 0x24, 0x5a, 0x24, 0xf8, 0x6a, 0x0e, 0xa4, 0x8e, 0x88, 0x75, 0xec, 0x7b, 0x3d, 0x8f,
	0x18, 0xdd, 0x70, 0x6d, 0xd8, 0xb4, 0x8b, 0xa3, 0x26, 0x4e, 0xac, 0x0d, 0x26, 0x66, 0x6b, 0x83,
	0xfd, 0xc2, 0x3f, 0x83, 0x54, 0x1b, 0x13, 0xd3, 0xb7, 0x7b, 0x6c, 0xbe, 0xb9, 0xe7, 0xcd, 0x41,
	0x20, 0x41, 0xfe, 0x1e, 0x8d, 0x94, 0x48, 0x1d, 0x87, 0xc2, 0x7f, 0x83, 0xd5, 0x78, 0xce, 0x4f,
	0xfb, 0x64, 0xc8, 0xc9, 0xc2, 0x4d, 0x33, 0x1d, 0xd5, 0x72, 0xbc, 0x2e, 0x13, 0xe6, 0x48, 0x4d,
	0x3b, 0x43, 0x24, 0x26, 0xf0, 0x05, 0x48, 0xb6, 0x71, 0xcf, 0x23, 0x36, 0xe5, 0x2f, 0xea, 0xdf,
	0x58, 0x4f, 0xbf, 0x0d, 0xa4, 0xfb, 0x96, 0x4d, 0xcf, 0xfa, 0xa7, 0xac, 0xee, 0xfc, 0x4f, 0x2e,
	0xfe, 0xb3, 0x4b, 0xda, 0x2f, 0xcb, 0xec, 0x21, 0x23, 0x25, 0xc5, 0xa5, 0xa3, 0xed, 0xc1, 0xaf,
	0x41, 0x6a, 0x7c, 0xe1, 0xa3, 0xec, 0x0f, 0x6f, 0xa5, 0xc4, 0xd7, 0x5f, 0xee, 0x26, 0xc3, 0x7d,
	0xe6, 0xd2, 0x07, 0x03, 0x01, 0xa4, 0xc7, 0xdf, 0x48, 0xb8, 0x09, 0x60, 0x4b, 0xad, 0x34, 0xb5,
	0x83, 0xba, 0xaa, 0xb7, 0x9e, 0x1f, 0xd7, 0xf5, 0xe6, 0x49, 0xa3, 0x21, 0x26, 0x60, 0x11, 0xe4,
	0x27, 0xe5, 0x0d, 0xe5, 0x1f, 0x27, 0x4a, 0x4d, 0x69, 0x3d, 0xd7, 0xb5, 0x7a, 0xb3, 0x26, 0x0a,
	0xf0, 0x1e, 0x28, 0xde, 0x84, 0x78, 0xa6, 0xb4, 0x1e, 0xd7, 0xd4, 0xca, 0x33, 0x71, 0x0e, 0x6e,
	0x83, 0xcd, 0x49, 0xd4, 0x71, 0xfd, 0x50, 0x3f, 0x52, 0x9a, 0x2d, 0x71, 0x1e, 0x16, 0xc0, 0xf6,
	0x75, 0xdd, 0xd0, 0x76, 0x01, 0xde, 0x05, 0x5b, 0xb3, 0x6d, 0xf5, 0xa7, 0xfb, 0xe2, 0x22, 0xfc,
	0x0d, 0xb8, 0x7b, 0xb3, 0x39, 0x83, 0x2c, 0x6d, 0x2f, 0xfc, 0xef, 0xb3, 0x42, 0xe2, 0xc1, 0x6b,
	0x01, 0x64, 0xa7, 0xde, 0x5e, 0x98, 0x07, 0xb9, 0xfa, 0x3f, 0xeb, 0xd5, 0x93, 0x96, 0xf2, 0xf7,
	0xa6, 0xae, 0xb5, 0x2a, 0xad, 0x13, 0x4d, 0x3f, 0xae, 0x37, 0x6b, 0x4a, 0xf3, 0x50, 0x4c, 0xcc,
	0xd4, 0x6a, 0x27, 0xd5, 0x6a, 0x5d, 0xd3, 0x44, 0x61, 0xa6, 0xf6, 0xa0, 0xa2, 0x34, 0x4e, 0xd4,
	0xba, 0x38, 0xc7, 0xa2, 0x9e, 0xa1, 0x6d, 0x34, 0xe4, 0x4a, 0xf5, 0x89, 0x38, 0xcf, 0x43, 0xaa,
	0x82, 0xe4, 0x11, 0xb1, 0xc2, 0x0e, 0x20, 0x50, 0x38, 0xd2, 0x0e, 0xa3, 0x0c, 0x8e, 0xea, 0x9a,
	0x56, 0x39, 0xac, 0x87, 0x59, 0xe8, 0x71, 0x72, 0x62, 0x02, 0xae, 0x03, 0x71, 0x1a, 0x23, 0x0a,
	0x0f, 0xfe, 0x03, 0x80, 0xec, 0xdb, 0x6d, 0x0b, 0x87, 0xf7, 0xac, 0x03, 0x51, 0x56, 0x95, 0xda,
	0x61, 0x7d, 0xa2, 0x8f, 0x5b, 0x60, 0x63, 0x5c, 0x3a, 0xec, 0x91, 0x28, 0x4c, 0xab, 0x58, 0xf5,
	0x9e, 0x56, 0x4e, 0x1a, 0xad, 0xa8, 0x6b, 0xd3, 0xaa, 0xe8, 0x1c, 0x27, 0x20, 0x2b, 0xef, 0x3e,
	0x14, 0x84, 0xf7, 0x1f, 0x0a, 0xc2, 0xf7, 0x1f, 0x0a, 0xc2, 0xeb, 0x8f, 0x85, 0xc4, 0xfb, 0x8f,
	0x85, 0xc4, 0x37, 0x1f, 0x0b, 0x89, 0x17, 0xe5, 0x71, 0xda, 0xe2, 0x2e, 0xf6, 0x77, 0x5d, 0x4c,
	0x5f, 0x79, 0xfe, 0xcb, 0x32, 0xb1, 0xdc, 0xdd, 0x8b, 0xfd, 0xf2, 0xe5, 0xf0, 0xff, 0x8e, 0x90,
	0xc3, 0xa7, 0x4b, 0xe1, 0x2e, 0x7d, 0xf8, 0x4b, 0x00, 0x00, 0x00, 0xff, 0xff, 0xde, 0x32, 0x74,
	0xe9, 0x93, 0x0c, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.TriggerSignCooldown, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerSignCooldown):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintMessage(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SrcTxHash) > 0 {
		i -= len(m.SrcTxHash)
		copy(dAtA[i:], m.SrcTxHash)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.SrcTxHash)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TransferRefId) > 0 {
		i -= len(m.TransferRefId)
		copy(dAtA[i:], m.TransferRefId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.TransferRefId)))
		i--
		dAtA[i] = 0x5a
	}
	if m.LastSigReqTime != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.LastSigReqTime))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.ExecutionStatus != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ExecutionStatus))
		i--
		dAtA[i] = 0x40
	}
	if m.TransferType != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.TransferType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Fee) > 0 {
		i -= len(m.Fee)
		copy(dAtA[i:], m.Fee)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Fee)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x22
	}
	if m.DstChainId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.DstChainId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if m.SrcChainId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SrcChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Transfer != nil {
		{
			size, err := m.Transfer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FeeClaimDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeClaimDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeClaimDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Signatures[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size, err := m.CumulativeFeeAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ChainId != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FeeClaimInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeClaimInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeClaimInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeeClaimDetailsList) > 0 {
		for iNdEx := len(m.FeeClaimDetailsList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FeeClaimDetailsList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastClaimTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastClaimTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintMessage(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x12
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MessageBusInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageBusInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageBusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeeTokenSymbol) > 0 {
		i -= len(m.FeeTokenSymbol)
		copy(dAtA[i:], m.FeeTokenSymbol)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.FeeTokenSymbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.ContractInfo != nil {
		{
			size, err := m.ContractInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Deposit.Size()
		i -= size
		if _, err := m.Deposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintMessage(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.MessageBuses) > 0 {
		for iNdEx := len(m.MessageBuses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MessageBuses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.TriggerSignCooldown)
	n += 1 + l + sovMessage(uint64(l))
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcChainId != 0 {
		n += 1 + sovMessage(uint64(m.SrcChainId))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.DstChainId != 0 {
		n += 1 + sovMessage(uint64(m.DstChainId))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.TransferType != 0 {
		n += 1 + sovMessage(uint64(m.TransferType))
	}
	if m.ExecutionStatus != 0 {
		n += 1 + sovMessage(uint64(m.ExecutionStatus))
	}
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	if m.LastSigReqTime != 0 {
		n += 1 + sovMessage(uint64(m.LastSigReqTime))
	}
	l = len(m.TransferRefId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.SrcTxHash)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Transfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovMessage(uint64(m.SeqNum))
	}
	return n
}

func (m *ExecutionContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = m.Message.Size()
	n += 1 + l + sovMessage(uint64(l))
	if m.Transfer != nil {
		l = m.Transfer.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *FeeClaimDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovMessage(uint64(m.ChainId))
	}
	l = m.CumulativeFeeAmount.Size()
	n += 1 + l + sovMessage(uint64(l))
	if len(m.Signatures) > 0 {
		for _, e := range m.Signatures {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *FeeClaimInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastClaimTime)
	n += 1 + l + sovMessage(uint64(l))
	if len(m.FeeClaimDetailsList) > 0 {
		for _, e := range m.FeeClaimDetailsList {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	return n
}

func (m *MessageBusInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContractInfo != nil {
		l = m.ContractInfo.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.FeeTokenSymbol)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *MsgProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if len(m.MessageBuses) > 0 {
		for _, e := range m.MessageBuses {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = m.Deposit.Size()
	n += 1 + l + sovMessage(uint64(l))
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerSignCooldown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.TriggerSignCooldown, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcChainId", wireType)
			}
			m.SrcChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstChainId", wireType)
			}
			m.DstChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferType", wireType)
			}
			m.TransferType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransferType |= TransferType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionStatus", wireType)
			}
			m.ExecutionStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionStatus |= ExecutionStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, types.Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSigReqTime", wireType)
			}
			m.LastSigReqTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSigReqTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferRefId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferRefId = append(m.TransferRefId[:0], dAtA[iNdEx:postIndex]...)
			if m.TransferRefId == nil {
				m.TransferRefId = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token[:0], dAtA[iNdEx:postIndex]...)
			if m.Token == nil {
				m.Token = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = append(m.MessageId[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageId == nil {
				m.MessageId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transfer == nil {
				m.Transfer = &Transfer{}
			}
			if err := m.Transfer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeClaimDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeClaimDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeClaimDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativeFeeAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CumulativeFeeAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, types.Signature{})
			if err := m.Signatures[len(m.Signatures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeeClaimInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeClaimInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeClaimInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastClaimTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastClaimTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeClaimDetailsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeClaimDetailsList = append(m.FeeClaimDetailsList, FeeClaimDetails{})
			if err := m.FeeClaimDetailsList[len(m.FeeClaimDetailsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageBusInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageBusInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageBusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractInfo == nil {
				m.ContractInfo = &types.ContractInfo{}
			}
			if err := m.ContractInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeTokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeTokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageBuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageBuses = append(m.MessageBuses, &MessageBusInfo{})
			if err := m.MessageBuses[len(m.MessageBuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
