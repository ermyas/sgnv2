// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package dal

import (
	"context"

	"github.com/celer-network/goutils/big"
	"github.com/lib/pq"
)

const allEvsAdd = `-- name: AllEvsAdd :exec
INSERT INTO allevs (chid, nft, from_addr, to_addr, tok_id) VALUES ($1, $2, $3, $4, $5)
`

type AllEvsAddParams struct {
	Chid     uint64  `json:"chid"`
	Nft      string  `json:"nft"`
	FromAddr string  `json:"fromAddr"`
	ToAddr   string  `json:"toAddr"`
	TokID    big.Int `json:"tokID"`
}

func (q *Queries) AllEvsAdd(ctx context.Context, arg AllEvsAddParams) error {
	_, err := q.db.ExecContext(ctx, allEvsAdd,
		arg.Chid,
		arg.Nft,
		arg.FromAddr,
		arg.ToAddr,
		arg.TokID,
	)
	return err
}

const monGet = `-- name: MonGet :one

SELECT key, blknum, blkidx FROM monitor WHERE key = $1
`

// NOTE: sqlc gen query.sql.go sorted by func name, so all func should have table name prefix
// comment must be "name: TableXXX :yyy" see https://docs.sqlc.dev/en/latest/reference/query-annotations.html
func (q *Queries) MonGet(ctx context.Context, key string) (Monitor, error) {
	row := q.db.QueryRowContext(ctx, monGet, key)
	var i Monitor
	err := row.Scan(&i.Key, &i.Blknum, &i.Blkidx)
	return i, err
}

const monSet = `-- name: MonSet :exec
INSERT INTO monitor (key, blknum, blkidx) VALUES ($1, $2, $3) ON CONFLICT (key) DO UPDATE
SET blknum = excluded.blknum, blkidx = excluded.blkidx
`

type MonSetParams struct {
	Key    string `json:"key"`
	Blknum uint64 `json:"blknum"`
	Blkidx int64  `json:"blkidx"`
}

func (q *Queries) MonSet(ctx context.Context, arg MonSetParams) error {
	_, err := q.db.ExecContext(ctx, monSet, arg.Key, arg.Blknum, arg.Blkidx)
	return err
}

const nftAddSend = `-- name: NftAddSend :exec
INSERT INTO nftxfer (created_at, src_chid, dst_chid, sender, receiver, src_nft, dst_nft, tok_id, src_tx, dst_tx)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, '')
`

type NftAddSendParams struct {
	CreatedAt int64   `json:"createdAt"`
	SrcChid   uint64  `json:"srcChid"`
	DstChid   uint64  `json:"dstChid"`
	Sender    string  `json:"sender"`
	Receiver  string  `json:"receiver"`
	SrcNft    string  `json:"srcNft"`
	DstNft    string  `json:"dstNft"`
	TokID     big.Int `json:"tokID"`
	SrcTx     string  `json:"srcTx"`
}

func (q *Queries) NftAddSend(ctx context.Context, arg NftAddSendParams) error {
	_, err := q.db.ExecContext(ctx, nftAddSend,
		arg.CreatedAt,
		arg.SrcChid,
		arg.DstChid,
		arg.Sender,
		arg.Receiver,
		arg.SrcNft,
		arg.DstNft,
		arg.TokID,
		arg.SrcTx,
	)
	return err
}

const nftGetByDstInfo = `-- name: NftGetByDstInfo :one
SELECT src_tx FROM nftxfer WHERE src_chid = $1 AND dst_chid = $2 AND receiver = $3 AND dst_nft = $4 AND tok_id = $5 AND status = $6
`

type NftGetByDstInfoParams struct {
	SrcChid  uint64  `json:"srcChid"`
	DstChid  uint64  `json:"dstChid"`
	Receiver string  `json:"receiver"`
	DstNft   string  `json:"dstNft"`
	TokID    big.Int `json:"tokID"`
	Status   int16   `json:"status"`
}

func (q *Queries) NftGetByDstInfo(ctx context.Context, arg NftGetByDstInfoParams) (string, error) {
	row := q.db.QueryRowContext(ctx, nftGetByDstInfo,
		arg.SrcChid,
		arg.DstChid,
		arg.Receiver,
		arg.DstNft,
		arg.TokID,
		arg.Status,
	)
	var src_tx string
	err := row.Scan(&src_tx)
	return src_tx, err
}

const nftGetBySender = `-- name: NftGetBySender :many
SELECT created_at, src_chid, dst_chid, sender, receiver, src_nft, dst_nft, tok_id, src_tx, dst_tx, status FROM nftxfer WHERE sender = $1 AND created_at < $2 ORDER BY created_at desc LIMIT $3
`

type NftGetBySenderParams struct {
	Sender    string `json:"sender"`
	CreatedAt int64  `json:"createdAt"`
	Limit     int32  `json:"limit"`
}

// user's history, support pagination
func (q *Queries) NftGetBySender(ctx context.Context, arg NftGetBySenderParams) ([]Nftxfer, error) {
	rows, err := q.db.QueryContext(ctx, nftGetBySender, arg.Sender, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Nftxfer
	for rows.Next() {
		var i Nftxfer
		if err := rows.Scan(
			&i.CreatedAt,
			&i.SrcChid,
			&i.DstChid,
			&i.Sender,
			&i.Receiver,
			&i.SrcNft,
			&i.DstNft,
			&i.TokID,
			&i.SrcTx,
			&i.DstTx,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nftSetDoneByDstTx = `-- name: NftSetDoneByDstTx :exec
UPDATE nftxfer SET status = 3 WHERE dst_tx = $1
`

func (q *Queries) NftSetDoneByDstTx(ctx context.Context, dstTx string) error {
	_, err := q.db.ExecContext(ctx, nftSetDoneByDstTx, dstTx)
	return err
}

const nftSetDstTx = `-- name: NftSetDstTx :exec
UPDATE nftxfer SET status = 2, dst_tx = $6 WHERE src_chid = $1 AND dst_chid = $2 AND receiver = $3 AND dst_nft = $4 AND tok_id = $5 AND status = 1
`

type NftSetDstTxParams struct {
	SrcChid  uint64  `json:"srcChid"`
	DstChid  uint64  `json:"dstChid"`
	Receiver string  `json:"receiver"`
	DstNft   string  `json:"dstNft"`
	TokID    big.Int `json:"tokID"`
	DstTx    string  `json:"dstTx"`
}

// also set status to 2 wait for dst tx
func (q *Queries) NftSetDstTx(ctx context.Context, arg NftSetDstTxParams) error {
	_, err := q.db.ExecContext(ctx, nftSetDstTx,
		arg.SrcChid,
		arg.DstChid,
		arg.Receiver,
		arg.DstNft,
		arg.TokID,
		arg.DstTx,
	)
	return err
}

const usrGetNfts = `-- name: UsrGetNfts :one
SELECT tokens FROM usrnfts WHERE chid = $1 AND nft = $2 AND usr = $3
`

type UsrGetNftsParams struct {
	Chid uint64 `json:"chid"`
	Nft  string `json:"nft"`
	Usr  string `json:"usr"`
}

func (q *Queries) UsrGetNfts(ctx context.Context, arg UsrGetNftsParams) ([]string, error) {
	row := q.db.QueryRowContext(ctx, usrGetNfts, arg.Chid, arg.Nft, arg.Usr)
	var tokens []string
	err := row.Scan(pq.Array(&tokens))
	return tokens, err
}

const usrSetNfts = `-- name: UsrSetNfts :exec
INSERT INTO usrnfts (chid, nft, usr, tokens) VALUES ($1, $2, $3, $4) ON CONFLICT (chid, nft, usr) DO UPDATE
SET tokens = excluded.tokens
`

type UsrSetNftsParams struct {
	Chid   uint64   `json:"chid"`
	Nft    string   `json:"nft"`
	Usr    string   `json:"usr"`
	Tokens []string `json:"tokens"`
}

func (q *Queries) UsrSetNfts(ctx context.Context, arg UsrSetNftsParams) error {
	_, err := q.db.ExecContext(ctx, usrSetNfts,
		arg.Chid,
		arg.Nft,
		arg.Usr,
		pq.Array(arg.Tokens),
	)
	return err
}
