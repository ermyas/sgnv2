// Code generated by sqlc. DO NOT EDIT.
// source: queries.sql

package dal

import (
	"context"

	"github.com/celer-network/goutils/big"
)

const monGet = `-- name: MonGet :one

SELECT key, blknum, blkidx FROM monitor WHERE key = $1
`

// NOTE: sqlc gen query.sql.go sorted by func name, so all func should have table name prefix
// comment must be "name: TableXXX :yyy" see https://docs.sqlc.dev/en/latest/reference/query-annotations.html
func (q *Queries) MonGet(ctx context.Context, key string) (Monitor, error) {
	row := q.db.QueryRowContext(ctx, monGet, key)
	var i Monitor
	err := row.Scan(&i.Key, &i.Blknum, &i.Blkidx)
	return i, err
}

const monSet = `-- name: MonSet :exec
INSERT INTO monitor (key, blknum, blkidx) VALUES ($1, $2, $3) ON CONFLICT (key) DO UPDATE
SET blknum = excluded.blknum, blkidx = excluded.blkidx
`

type MonSetParams struct {
	Key    string
	Blknum uint64
	Blkidx int64
}

func (q *Queries) MonSet(ctx context.Context, arg MonSetParams) error {
	_, err := q.db.ExecContext(ctx, monSet, arg.Key, arg.Blknum, arg.Blkidx)
	return err
}

const nftAddSend = `-- name: NftAddSend :exec
INSERT INTO nftxfer (created_at, src_chid, dst_chid, sender, receiver, src_nft, dst_nft, tok_id, src_tx, dst_tx)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, '')
`

type NftAddSendParams struct {
	CreatedAt int64
	SrcChid   uint64
	DstChid   uint64
	Sender    string
	Receiver  string
	SrcNft    string
	DstNft    string
	TokID     big.Int
	SrcTx     string
}

func (q *Queries) NftAddSend(ctx context.Context, arg NftAddSendParams) error {
	_, err := q.db.ExecContext(ctx, nftAddSend,
		arg.CreatedAt,
		arg.SrcChid,
		arg.DstChid,
		arg.Sender,
		arg.Receiver,
		arg.SrcNft,
		arg.DstNft,
		arg.TokID,
		arg.SrcTx,
	)
	return err
}

const nftGetByDstInfo = `-- name: NftGetByDstInfo :one
SELECT src_tx FROM nftxfer WHERE src_chid = $1 AND dst_chid = $2 AND receiver = $3 AND dst_nft = $4 AND tok_id = $5 AND status = $6
`

type NftGetByDstInfoParams struct {
	SrcChid  uint64
	DstChid  uint64
	Receiver string
	DstNft   string
	TokID    big.Int
	Status   int16
}

func (q *Queries) NftGetByDstInfo(ctx context.Context, arg NftGetByDstInfoParams) (string, error) {
	row := q.db.QueryRowContext(ctx, nftGetByDstInfo,
		arg.SrcChid,
		arg.DstChid,
		arg.Receiver,
		arg.DstNft,
		arg.TokID,
		arg.Status,
	)
	var src_tx string
	err := row.Scan(&src_tx)
	return src_tx, err
}

const nftGetBySender = `-- name: NftGetBySender :many
SELECT created_at, src_chid, dst_chid, sender, receiver, src_nft, dst_nft, tok_id, src_tx, dst_tx, status FROM nftxfer WHERE sender = $1 ORDER BY created_at desc
`

// user's history
func (q *Queries) NftGetBySender(ctx context.Context, sender string) ([]Nftxfer, error) {
	rows, err := q.db.QueryContext(ctx, nftGetBySender, sender)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Nftxfer
	for rows.Next() {
		var i Nftxfer
		if err := rows.Scan(
			&i.CreatedAt,
			&i.SrcChid,
			&i.DstChid,
			&i.Sender,
			&i.Receiver,
			&i.SrcNft,
			&i.DstNft,
			&i.TokID,
			&i.SrcTx,
			&i.DstTx,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nftSetDoneByDstTx = `-- name: NftSetDoneByDstTx :exec
UPDATE nftxfer SET status = 3 WHERE dst_tx = $1
`

func (q *Queries) NftSetDoneByDstTx(ctx context.Context, dstTx string) error {
	_, err := q.db.ExecContext(ctx, nftSetDoneByDstTx, dstTx)
	return err
}

const nftSetDstTx = `-- name: NftSetDstTx :exec
UPDATE nftxfer SET status = 2, dst_tx = $6 WHERE src_chid = $1 AND dst_chid = $2 AND receiver = $3 AND dst_nft = $4 AND tok_id = $5 AND status = 1
`

type NftSetDstTxParams struct {
	SrcChid  uint64
	DstChid  uint64
	Receiver string
	DstNft   string
	TokID    big.Int
	DstTx    string
}

// also set status to 2 wait for dst tx
func (q *Queries) NftSetDstTx(ctx context.Context, arg NftSetDstTxParams) error {
	_, err := q.db.ExecContext(ctx, nftSetDstTx,
		arg.SrcChid,
		arg.DstChid,
		arg.Receiver,
		arg.DstNft,
		arg.TokID,
		arg.DstTx,
	)
	return err
}
