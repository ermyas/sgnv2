syntax = "proto3";
package sgn.cbridge.v1;

import "gogoproto/gogo.proto";
import "sgn/cbridge/v1/cbridge.proto";

option go_package = "github.com/celer-network/sgn-v2/x/cbridge/types";

service Msg {
  // called by gateway to start a withdraw flow
  // async call, client will query by addr and reqid for status
  // if req is invalid, an error w/ errcode will be returned
  rpc InitWithdraw(MsgInitWithdraw) returns (MsgInitWithdrawResp);

  // user can request to sign a previous withdraw again
  rpc SignAgain(MsgSignAgain) returns (MsgSignAgainResp);

  // sgn validator send its sig, so the msg can be later submitted onchain
  rpc SendMySig(MsgSendMySig) returns (MsgSendMySigResp);

  rpc UpdateLatestSigners(MsgUpdateLatestSigners) returns (MsgUpdateLatestSignersResp);
}

enum SignDataType {
  INVALID = 0;
  RELAY = 1;     // data is serialized RelayOnChain
  WITHDRAW = 2;  // data is serialized WithdrawOnchain
  SIGNERS = 3;   // data is packed(triggerTime, signerAddrs, signerPowers)
}

message MsgSendMySig {
  SignDataType datatype = 1;
  bytes data = 2;             // signed data
  repeated MySig my_sigs = 3; // eth address should be recovered by x/cbridge and compare to validators

  string creator = 4;  // must be bonded validator
}

message MySig {
  uint64 chain_id = 1;
  bytes sig = 2;
}

message MsgSendMySigResp {}

message WithdrawLq {
  uint64 from_chain_id = 1;  // withdraw from this chain
  string token_addr = 2;     // token addr hex string
  uint32 ratio = 3;          // max = ie8, e.g, 0.01% -> 10000
  uint32 max_slippage = 4;   // slippage * 1M, eg. 0.5% -> 5000
}

// WithdrawType enumerates the withdraw types.
enum WithdrawType {
  option (gogoproto.goproto_enum_prefix) = false;

  WITHDRAW_TYPE_REMOVE_LIQUIDITY = 0 [(gogoproto.enumvalue_customname) = "RemoveLiquidity"];
  WITHDRAW_TYPE_REFUND_TRANSFER = 1 [(gogoproto.enumvalue_customname) = "RefundTransfer"];
  WITHDRAW_TYPE_CLAIM_FEE_SHARE = 2 [(gogoproto.enumvalue_customname) = "ClaimFeeShare"];
}

message WithdrawReq {
  // if set, user refund src transfer id
  string xfer_id = 1;
  // lp withdraw, only set if xfer_id is empty
  repeated WithdrawLq withdraws = 2;
  uint64 exit_chain_id = 3;  // submit onchain withdraw at this chain
  // per user unique request id. generated by client, duplicated req_id will be ignored
  uint64 req_id = 4;
  WithdrawType withdraw_type = 5;
}

message MsgInitWithdraw {
  bytes withdraw_req = 1;  // serialized WithdrawReq
  bytes user_sig = 2;      // sig of withdraw_req from client
  string creator = 3;
}

message MsgInitWithdrawResp {}

// Next tag: 6
message MsgSignAgain {
  SignDataType data_type = 4;  // relay, withdraw, signer
  // for withdraw
  bytes user_addr = 1;  // user eth address
  uint64 req_id = 2;    // req_id in previous InitWithdraw
  // for relay
  bytes xfer_id = 5;

  string creator = 3;  // for log only
}

message MsgSignAgainResp {}

message MsgUpdateLatestSigners {
  string creator = 1;
}

message MsgUpdateLatestSignersResp {}

message ErrMsg {
  ErrCode code = 1;
  string desc = 2;
}

enum ErrCode {
  UNDEFINED = 0;
  INVALID_REQ = 1;
  INVALID_SIG = 2;
  INVALID_STATUS = 3;
  NOT_FOUND = 4;
  DUP_REQID = 5;
  REQ_TOO_SOON = 6;
  BAL_NOT_ENOUGH = 7;
  XFER_NOT_REFUNDABLE = 10;
  XFER_REFUND_STARTED = 11;
  WD_INTERNAL_XFER_FAILURE = 12;
  WD_EXCEED_MAX_OUT_AMOUNT = 13;
}
