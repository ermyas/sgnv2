syntax = "proto3";
package sgn.cbridge.v1;

import "gogoproto/gogo.proto";
import "sgn/cbridge/v1/cbridge.proto";

option go_package = "github.com/celer-network/sgn-v2/x/cbridge/types";

service Msg {
    // called by gateway to start a withdraw flow
    // async call, client will query by addr and reqid for status
    // if req is invalid, an error w/ errcode will be returned 
    rpc InitWithdraw(MsgInitWithdraw) returns (MsgInitWithdrawResp);

    // user can request to sign a previous withdraw again
    rpc SignAgain(MsgSignAgain) returns (MsgSignAgainResp);

    // sgn validator send its sig, so the msg can be later submitted onchain
    rpc SendMySig(MsgSendMySig) returns (MsgSendMySigResp);
}

enum SignDataType {
    INVALID = 0;
    RELAY = 1; // data is serialized RelayOnChain
    WITHDRAW = 2; // data is serialized WithdrawOnchain
    SIGNERS = 3; // data is serialized SortedSigners
}

message MsgSendMySig {
    SignDataType datatype = 1; // relay or withdraw
    bytes data = 2; // signed data
    bytes my_sig = 3; // eth address should be recovered by x/cbridge and compare to validators

    string creator = 4; // must be bonded validator
}

message MsgSendMySigResp {
}

message MsgInitWithdraw {
    option (gogoproto.goproto_stringer) = false;

    bytes xfer_id = 1; // if set, user refund src transfer id
    // lp withdraw, only set if xfer_id is nil
    uint64 chainid = 2;
    bytes lp_addr = 3;
    bytes token = 4;
    bytes amount = 5;

    string creator = 6; // this is for log only, non-validator can also send this msg

    // per user unique request id. generated by client, duplicated req_id will be ignored
    uint64 req_id = 7;
    bytes user_sig = 8; // sign req_id as msg, also from client
}

message MsgInitWithdrawResp {
}

message MsgSignAgain {
    bytes user_addr = 1; // user eth address
    uint64 req_id = 2; // req_id in previous initwithdraw

    string creator = 3; // for log only    
}

message MsgSignAgainResp {
}

// returned in grpc call if request is invalid
enum WdErr {
    NOT_USED = 0; // not used, if success err is nil
    // if initwithdraw has xfer_id, but it's not bad_xxx, no refund
    XFER_NOT_REFUNDABLE = 1;
    // already requested initwithdraw for this bad xfer, user should use sign again
    XFER_HAS_WITHDRAW = 2;
  
    // if lp withdraw liquidity but balance is not enough, msg is current balance.String()
    LP_BAL_NOT_ENOUGH = 3;
  
    // below are sign again err code
    NOT_FOUND = 4; // req id in signAgain request not found
    ALREADY_DONE = 5; // withdraw already completed, don't allow sign again
    REQ_TOO_SOON = 6; // withdraw was last requested within past 10min, try again after 10min

    // below are initwithdraw due to new user sig and req id fields
    INVALID_SIG = 7; // if eth recover from sig doesn't match expected
    DUP_REQID = 8; // already exist reqid for this user
  }