syntax = "proto3";
package sgn.cbridge.v1;

import "sgn/cbridge/v1/cbridge.proto";

option go_package = "github.com/celer-network/sgn-v2/x/cbridge/types";

service Msg {
    // called by gateway to start a withdraw flow
    rpc InitWithdraw(MsgInitWithdraw) returns (MsgInitWithdrawResp);

    // user can request to sign a previous withdraw again
    // to mitigate dos attack, we could be smart and re-use sigs if
    // they are still valid. we should also deny if withdraw already
    // completed
    rpc SignAgain(MsgSignAgain) returns (MsgSignAgainResp);

    // send my sig for data, so it can be later submitted onchain
    rpc SendMySig(MsgSendMySig) returns (MsgSendMySigResp);
}

enum SignDataType {
    INVALID = 0;
    RELAY = 1; // data is serialized RelayOnChain
    WITHDRAW = 2; // data is serialized WithdrawOnchain
    SIGNERS = 3; // data is serialized SortedSigners
}

message MsgSendMySig {
    SignDataType datatype = 1; // relay or withdraw
    bytes data = 2; // signed data
    bytes my_sig = 3; // address should be recovered by x/cbridge and compare to validators

    string creator = 4;
}

message MsgSendMySigResp {}

message MsgInitWithdraw {
    bytes xfer_id = 1; // if set, user refund src transfer id
    // lp withdraw, only set if xfer_id is nil
    uint64 chainid = 2;
    bytes lp_addr = 3;
    bytes token = 4;
    bytes amount = 5;

    string creator = 6;

    // request unique id, due to async nature, client must provide a request id to associate
    // with emitted withdrawresp event, similar to jsonrpc design. It's client's responsibility
    // to keep track of request id, a simple way is to use epoch millisec
    uint64 req_id = 7;
}

// due to async tx nature, this can't be returned to caller in a sync call, so we emit below as an event instead
message MsgInitWithdrawResp {
    // global unique withdraw sequence number, valid value >=1
    uint64 seqnum = 1;
    // if errmsg is not nil, seqnum must be 0. if seqnum is >=1, errmsg must be nil
    ErrMsg errmsg = 2;
    // req_id in MsgInitWithdraw so client can correlate this event with its own request
    uint64 req_id = 3;
}

message MsgSignAgain {
    uint64 seqnum = 1; // received in MsgInitWithdrawResp
    string creator = 2;
    bytes xfer_id = 3; // if set, re-emit sign for relay, xfer_id is src xfer_id

    // although we could use seqnum/xfer_id to correlate req/resp, use req_id is more consistent for all methods
    uint64 req_id = 4;
}

message MsgSignAgainResp {
    ErrMsg errmsg = 1; // if nil means accepted
    uint64 req_id = 2; // req_id in MsgSignAgain
}

enum ErrCode {
    UNDEFINED = 0;
    // if initwithdraw has xfer_id, but it's not bad_xxx, no refund
    XFER_NOT_REFUNDABLE = 1;
    // already requested initwithdraw for this bad xfer, and x/cbridge already assigned seqnum
    // msg is fmt.Sprintf("%d", seqnum), user should use sign again
    XFER_HAS_SEQNUM = 2;

    // if lp withdraw liquidity but balance is not enough, msg is current balance.String()
    LP_BAL_NOT_ENOUGH = 3;

    // below are sign again err code
    SEQ_NOT_FOUND = 4; // withdraw seq num in signAgain request not found
    ALREADY_DONE = 5; // withdraw already completed, don't allow sign again
    REQ_TOO_SOON = 6; // withdraw seq sig was last requested within past 10min, try again after 10min
}

message ErrMsg {
    ErrCode code = 1;
    string msg = 2;
}