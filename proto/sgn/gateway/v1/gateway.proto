syntax = "proto3";
package sgn.gateway.v1;

import "google/api/annotations.proto";
import "sgn/cbridge/v1/query.proto";
import "sgn/cbridge/v1/cbridge.proto";
import "sgn/farming/v1/farming.proto";
import "cosmos/base/v1beta1/coin.proto";

option go_package = "github.com/celer-network/sgn-v2/gateway/webapi";

service Web {
    // current only for slippage_tolerance setting
    rpc SetAdvancedInfo (SetAdvancedInfoRequest) returns (SetAdvancedInfoResponse) {
        option (google.api.http) = {
      post: "/v1/setAdvancedInfo"
      body: "*"
    };
    }

    // current only for slippage_tolerance setting
    rpc GetAdvancedInfo (GetAdvancedInfoRequest) returns (GetAdvancedInfoResponse) {
        option (google.api.http) = {
      post: "/v1/getAdvancedInfo"
      body: "*"
    };
    }

    // get chain and token selector
    // after getting these info, remember to record them(especially decimal)
    rpc GetTransferConfigs (GetTransferConfigsRequest) returns (GetTransferConfigsResponse) {
        option (google.api.http) = {
      get: "/v1/getTransferConfigs"
    };
    }

    // estimate transfer fee
    rpc EstimateAmt (EstimateAmtRequest) returns (EstimateAmtResponse) {
        option (google.api.http) = {
      get: "/v1/estimateAmt"
    };
    }

    // same as V1, call this api after user confirm transfer on metamask
    rpc MarkTransfer (MarkTransferRequest) returns (MarkTransferResponse) {
        option (google.api.http) = {
      post: "/v1/markTransfer"
      body: "*"
    };
    }

    rpc GetTransferStatus (GetTransferStatusRequest) returns (GetTransferStatusResponse) {
        option (google.api.http) = {
      post: "/v1/getTransferStatus"
      body: "*"
    };
    }

    //LP
    // get LP table info
    rpc GetLPInfoList (GetLPInfoListRequest) returns (GetLPInfoListResponse) {
        option (google.api.http) = {
      get: "/v1/getLPInfoList"
    };
    }

    rpc MarkLiquidity (MarkLiquidityRequest) returns (MarkLiquidityResponse) {
        option (google.api.http) = {
      post: "/v1/markLiquidity"
      body: "*"
    };
    }

    //https://github.com/celer-network/sgn-v2/blob/main/proto/sgn/cbridge/v1/tx.proto#L10
    // remove liquidity or refund transfer calling this api
    rpc WithdrawLiquidity (WithdrawLiquidityRequest) returns (WithdrawLiquidityResponse) {
        option (google.api.http) = {
      post: "/v1/withdrawLiquidity"
      body: "*"
    };
    }

    // bcz it's time cost for sgn voting, so we need a polling api to check the status
    rpc QueryLiquidityStatus (QueryLiquidityStatusRequest) returns (QueryLiquidityStatusResponse) {
        option (google.api.http) = {
      get: "/v1/queryLiquidityStatus"
    };
    }

    // web will use this api to init reward cliam
    rpc ClaimWithdrawReward (ClaimWithdrawRewardRequest) returns (ClaimWithdrawRewardResponse) {
        option (google.api.http) = {
      post: "/v1/claimWithdrawReward"
      body: "*"
    };
    }

    // web polling this api after ClaimWithdrawReward
    rpc ClaimRewardDetails (ClaimRewardDetailsRequest) returns (ClaimRewardDetailsResponse) {
        option (google.api.http) = {
      post: "/v1/claimRewardDetails"
      body: "*"
    };
    }

    //History
    rpc TransferHistory (TransferHistoryRequest) returns (TransferHistoryResponse) {
        option (google.api.http) = {
      get: "/v1/transferHistory"
    };
    }

    rpc LPHistory (LPHistoryRequest) returns (LPHistoryResponse) {
        option (google.api.http) = {
      get: "/v1/lpHistory"
    };
    }

    rpc RewardingData (RewardingDataRequest) returns (RewardingDataResponse) {
        option (google.api.http) = {
      get: "/v1/rewardingData"
    };
    }
}

message QueryLiquidityStatusResponse {
    ErrMsg err = 1;
    cbridge.v1.LPHistoryStatus status = 2;
    bytes wd_onchain = 3; // for withdraw only
    repeated bytes sorted_sigs = 4; // for withdraw only
    repeated bytes signers = 5; // for withdraw only
    repeated bytes powers = 6; // for withdraw only
}

message Chain {
    uint32 id = 1;
    string name = 2;
    string icon = 3;
}

message ChainTokenInfo {
    repeated TokenInfo token = 1;
}

message TokenInfo {
    cbridge.v1.Token token = 1;
    string name = 2;
    string icon = 3;
    string contract_addr = 4; // contract addr
}

message TransferInfo {
    Chain chain = 1;
    cbridge.v1.Token token = 2;
    string amount = 3;
}

message SetAdvancedInfoRequest {
    string addr = 1;
    uint32 slippage_tolerance = 2; // slippage * 1M, eg. 0.5% is 5000
}

message SetAdvancedInfoResponse {
    ErrMsg err = 1;
}

message GetAdvancedInfoRequest {
    string addr = 1;
}

message GetAdvancedInfoResponse {
    ErrMsg err = 1;
    uint32 slippage_tolerance = 2; // slippage * 1M, eg. 0.5% is 5000
}

message GetTransferStatusRequest {
    string transfer_id = 1;
}

message GetTransferStatusResponse {
    ErrMsg err = 1;
    cbridge.v1.TransferHistoryStatus status = 2;
    bytes wd_onchain = 3; // for refund only
    repeated bytes sorted_sigs = 4; // for refund only
    repeated bytes signers = 5; // for refund only
    repeated bytes powers = 6; // for refund only
    cbridge.v1.XferStatus refund_reason = 7; // used only for to_be_refund TransferStatus. BAD_LIQUIDITY, BAD_SLIPPAGE and BAD_TOKEN are used here
    uint32 block_delay = 8; // waiting
}

message GetTransferConfigsRequest {

}

message GetTransferConfigsResponse {
    ErrMsg err = 1;
    repeated Chain chains = 2;
    map<uint32, ChainTokenInfo> chain_token = 3; //map<chain_id, ChainTokenInfo>
}

message EstimateAmtRequest {
    uint32 src_chain_id = 1;
    uint32 dst_chain_id = 2;
    string token_symbol = 3;
    string amt = 4;
    string usr_addr = 5;
}

message EstimateAmtResponse {
    ErrMsg err = 1;
    string eq_value_token_amt = 2; //on_dst_chain, to cal minimum_received_amt = eq_value_token_amt*(1-slippage_tolerance) -  fee
    float bridge_rate = 3;
    string fee = 4; //on_dst_chain
    uint32 slippage_tolerance = 5; // user setting, for ui only, slippage * 1M, eg. 0.5% is 5000
    uint32 max_slippage = 6; // param for requesting on chain, slippage * 1M, eg. 0.5% is 5000
}

enum TransferType {
    TRANSFER_TYPE_UNKNOWN = 0;
    TRANSFER_TYPE_SEND = 1;
    TRANSFER_TYPE_REFUND = 2;
}
message MarkTransferRequest {
    string transfer_id = 1;
    TransferInfo src_send_info = 2;
    TransferInfo dst_min_received_info = 3;
    string addr = 4;
    string src_tx_hash = 5;
    TransferType type = 6;
}

message MarkTransferResponse {
    ErrMsg err = 1;
}

message GetLPInfoListRequest {
    string addr = 1;
}

message LPInfo {
    Chain chain = 1;
    TokenInfo token = 2;
    double liquidity = 3; // current liquidity of user in usd
    string liquidity_amt = 4; // current liquidity of user in token
    bool has_farming_sessions = 5;
    double lp_fee_earning = 6; // in usd
    double farming_reward_earning = 7; // in usd
    double volume_24h = 8; //gateway cal this based on local db
    double total_liquidity = 9; // total liquidity of user in usd
    string total_liquidity_amt = 10; // total liquidity of user in token
    double lp_fee_earning_apy = 11;
    double farming_apy = 12;
}
message GetLPInfoListResponse {
    ErrMsg err = 1;
    repeated LPInfo lp_info = 2;
}

message WithdrawLiquidityRequest {
    string transfer_id = 1; // if set, user refund src transfer id
    // lp withdraw, only set if xfer_id is nil
    string receiver_addr = 2;
    string amount = 3;
    string token_addr = 4;
    uint32 chain_id = 5;

    // unique req id from client and sig to avoid dos attack
    uint64 reqid = 6;
    bytes sig = 7;
}

message WithdrawLiquidityResponse {
    ErrMsg err = 1;
    uint64 seq_num = 2; // same as WithdrawLiquidityRequest.reqid
}

message MarkLiquidityRequest {
    string lp_addr = 1;
    string amt = 2;
    string token_addr = 3;
    uint32 chain_id = 4;
    uint64 seq_num = 5;
    string tx_hash = 6;
    LPType type = 7;
}

message MarkLiquidityResponse {
    ErrMsg err = 1;
}


message ClaimWithdrawRewardRequest {
    string addr = 1;
}

message ClaimWithdrawRewardResponse {
    ErrMsg err = 1;
}
message ClaimRewardDetailsRequest {
    string addr = 1;
}

message ClaimRewardDetailsResponse {
    ErrMsg err = 1;
    repeated farming.v1.RewardClaimDetails details = 2;
}

message QueryLiquidityStatusRequest {
    uint64 seq_num = 1;
    string lp_addr = 2;
    uint32 chain_id = 3;
    LPType type = 4;
}

enum LPType {
    LP_TYPE_UNKNOWN = 0;
    LP_TYPE_ADD = 1;
    LP_TYPE_REMOVE = 2;
}

message TransferHistory {
    string transfer_id = 1;
    TransferInfo src_send_info = 2;
    TransferInfo dst_received_info = 3;
    uint64 ts = 4;
    string src_block_tx_link = 5;
    string dst_block_tx_link = 6;
    cbridge.v1.TransferHistoryStatus status = 7;
    cbridge.v1.XferStatus refund_reason = 8; // used only for to_be_refund TransferStatus. BAD_LIQUIDITY, BAD_SLIPPAGE and BAD_TOKEN are used here
}

message LPHistory {
    Chain chain = 1;
    TokenInfo token = 2;
    string amount = 3;
    uint64 ts = 4;
    string block_tx_link = 5;
    cbridge.v1.LPHistoryStatus status = 6;
    LPType type = 7;
    uint64 seq_num = 8;
}

message TransferHistoryRequest {
    string next_page_token = 1; // for first page, it's ""
    uint64 page_size = 2;
    string addr = 3;
}

message TransferHistoryResponse {
    ErrMsg err = 1;
    repeated TransferHistory history = 2;
    string next_page_token = 3;
    uint64 current_size = 4;
}

message LPHistoryRequest {
    string next_page_token = 1; // for first page, it's ""
    uint64 page_size = 2;
    string addr = 3;
}

message LPHistoryResponse {
    ErrMsg err = 1;
    repeated LPHistory history = 2;
    string next_page_token = 3;
    uint64 current_size = 4;
}

message RewardingDataRequest {
    string addr = 1;
}

message Reward {
    string amt = 1;
    string token_symbol = 2;
}
message RewardingDataResponse {
    ErrMsg err = 1;
    double total_farming_rewards = 2;
    repeated Reward historical_cumulative_rewards = 3;
    repeated Reward unlocked_cumulative_rewards = 4;
}

message ErrMsg {
    ErrCode code = 1;
    string msg = 2;
}

enum ErrCode {
    ERROR_CODE_UNDEFINED = 0;
    ERROR_CODE_COMMON = 500;
    ERROR_NO_TOKEN_ON_DST_CHAIN = 1001;
}
