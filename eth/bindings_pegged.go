// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package eth

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OriginalTokenVaultMetaData contains all meta data concerning the OriginalTokenVault contract.
var OriginalTokenVaultMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mintChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintAccount\",\"type\":\"address\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"depositNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeWrap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"setWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b506040516200379338038062003793833981016040819052620000349162000255565b6001600055620000443362000079565b6001805460ff60a01b191690556200005c33620000cb565b620000673362000195565b6001600160a01b031660805262000287565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03811660009081526002602052604090205460ff16156200013a5760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526003602052604090205460ff1615620002005760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f720000000000604482015260640162000131565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b591016200018a565b6000602082840312156200026857600080fd5b81516001600160a01b03811681146200028057600080fd5b9392505050565b6080516134e9620002aa6000396000818161078201526117c101526134e96000f3fe6080604052600436106102a35760003560e01c80636b2c0f551161016e578063adc0d57f116100cb578063e3eece261161007f578063eecdac8811610064578063eecdac8814610822578063f2fde38b14610842578063f83213831461086257600080fd5b8063e3eece26146107b9578063e43581b8146107e957600080fd5b8063b5f2bc47116100b0578063b5f2bc4714610743578063ccf2683b14610770578063e026049c146107a457600080fd5b8063adc0d57f146106b3578063b1c94d941461072d57600080fd5b80638456cb59116101225780639e25fc5c116101075780639e25fc5c146106535780639ff9001a14610673578063a21a92801461069357600080fd5b80638456cb59146106205780638da5cb5b1461063557600080fd5b8063715018a611610153578063715018a6146105bb57806380f51c12146105d057806382dc1ec41461060057600080fd5b80636b2c0f55146105865780636ef8d66d146105a657600080fd5b8063402d267d1161021c57806354eea796116101d05780635c975abb116101b55780635c975abb1461051a5780635ec2fa261461053957806360216b001461055957600080fd5b806354eea796146104e457806357d775f81461050457600080fd5b806346fbf68e1161020157806346fbf68e1461045e57806347b16c6c1461049757806352532faa146104b757600080fd5b8063402d267d146103f9578063457bfa2f1461042657600080fd5b8063303b6442116102735780633c4a25d0116102585780633c4a25d0146103a45780633d572107146103c45780633f4ba83a146103e457600080fd5b8063303b6442146103495780633c29f8391461036957600080fd5b8062a95fd7146102af57806301e64725146102c457806317bdbae514610309578063234636241461032957600080fd5b366102aa57005b600080fd5b6102c26102bd366004612ee8565b61088f565b005b3480156102d057600080fd5b506102f46102df366004612f35565b600b6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b34801561031557600080fd5b506102c2610324366004612f9a565b610ae8565b34801561033557600080fd5b506102c2610344366004613006565b610c86565b34801561035557600080fd5b506102c2610364366004612f9a565b610dc4565b34801561037557600080fd5b50610396610384366004613064565b600c6020526000908152604090205481565b604051908152602001610300565b3480156103b057600080fd5b506102c26103bf366004613064565b610f5b565b3480156103d057600080fd5b506102c26103df366004612f35565b610fc1565b3480156103f057600080fd5b506102c2611055565b34801561040557600080fd5b50610396610414366004613064565b600d6020526000908152604090205481565b34801561043257600080fd5b50600e54610446906001600160a01b031681565b6040516001600160a01b039091168152602001610300565b34801561046a57600080fd5b506102f4610479366004613064565b6001600160a01b031660009081526002602052604090205460ff1690565b3480156104a357600080fd5b506102c26104b2366004612f9a565b6110be565b3480156104c357600080fd5b506103966104d2366004613064565b60096020526000908152604090205481565b3480156104f057600080fd5b506102c26104ff366004612f35565b611255565b34801561051057600080fd5b5061039660045481565b34801561052657600080fd5b50600154600160a01b900460ff166102f4565b34801561054557600080fd5b506102c2610554366004612f9a565b6112e2565b34801561056557600080fd5b50610396610574366004613064565b60056020526000908152604090205481565b34801561059257600080fd5b506102c26105a1366004613064565b611479565b3480156105b257600080fd5b506102c26114dc565b3480156105c757600080fd5b506102c26114e5565b3480156105dc57600080fd5b506102f46105eb366004613064565b60026020526000908152604090205460ff1681565b34801561060c57600080fd5b506102c261061b366004613064565b611549565b34801561062c57600080fd5b506102c26115ac565b34801561064157600080fd5b506001546001600160a01b0316610446565b34801561065f57600080fd5b506102c261066e366004612f35565b611613565b34801561067f57600080fd5b506102c261068e366004613064565b611688565b34801561069f57600080fd5b506102c26106ae36600461307f565b611704565b3480156106bf57600080fd5b506107026106ce366004612f35565b60086020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b039586168152949093166020850152918301526060820152608001610300565b34801561073957600080fd5b50610396600a5481565b34801561074f57600080fd5b5061039661075e366004613064565b60066020526000908152604090205481565b34801561077c57600080fd5b506104467f000000000000000000000000000000000000000000000000000000000000000081565b3480156107b057600080fd5b506102c2611ac0565b3480156107c557600080fd5b506102f46107d4366004613064565b60036020526000908152604090205460ff1681565b3480156107f557600080fd5b506102f4610804366004613064565b6001600160a01b031660009081526003602052604090205460ff1690565b34801561082e57600080fd5b506102c261083d366004613064565b611ac9565b34801561084e57600080fd5b506102c261085d366004613064565b611b2c565b34801561086e57600080fd5b5061039661087d366004613064565b60076020526000908152604090205481565b600260005414156108e75760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b6002600055600154600160a01b900460ff16156109395760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108de565b8334146109885760405162461bcd60e51b815260206004820152600f60248201527f416d6f756e74206d69736d61746368000000000000000000000000000000000060448201526064016108de565b600e546001600160a01b03166109e05760405162461bcd60e51b815260206004820152601360248201527f4e61746976652077726170206e6f74207365740000000000000000000000000060448201526064016108de565b600e546000906109fc906001600160a01b031686868686611c0b565b9050600e60009054906101000a90046001600160a01b03166001600160a01b031663d0e30db0866040518263ffffffff1660e01b81526004016000604051808303818588803b158015610a4e57600080fd5b505af1158015610a62573d6000803e3d6000fd5b5050600e54604080518681523360208201526001600160a01b0392831691810191909152606081018a905267ffffffffffffffff8916608082015290871660a08201527f15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789935060c0019150610ad49050565b60405180910390a150506001600055505050565b3360009081526003602052604090205460ff16610b405760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108de565b828114610b815760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108de565b60005b83811015610c7f57828282818110610b9e57610b9e61316e565b9050602002013560096000878785818110610bbb57610bbb61316e565b9050602002016020810190610bd09190613064565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce858583818110610c1d57610c1d61316e565b9050602002016020810190610c329190613064565b848484818110610c4457610c4461316e565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610c778161319a565b915050610b84565b5050505050565b60026000541415610cd95760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016108de565b6002600055600154600160a01b900460ff1615610d2b5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108de565b6000610d3a8686868686611c0b565b9050610d516001600160a01b038716333088611e01565b604080518281523360208201526001600160a01b03888116828401526060820188905267ffffffffffffffff87166080830152851660a082015290517f15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac7899181900360c00190a15050600160005550505050565b3360009081526003602052604090205460ff16610e1c5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108de565b828114610e5d5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108de565b60005b83811015610c7f57828282818110610e7a57610e7a61316e565b90506020020135600d6000878785818110610e9757610e9761316e565b9050602002016020810190610eac9190613064565b6001600160a01b031681526020810191909152604001600020557f0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72858583818110610ef957610ef961316e565b9050602002016020810190610f0e9190613064565b848484818110610f2057610f2061316e565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610f538161319a565b915050610e60565b6001546001600160a01b03163314610fb55760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108de565b610fbe81611e9f565b50565b3360009081526003602052604090205460ff166110195760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108de565b600a8190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526002602052604090205460ff166110b45760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108de565b6110bc611f5c565b565b3360009081526003602052604090205460ff166111165760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108de565b8281146111575760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108de565b60005b83811015610c7f578282828181106111745761117461316e565b90506020020135600660008787858181106111915761119161316e565b90506020020160208101906111a69190613064565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e898585838181106111f3576111f361316e565b90506020020160208101906112089190613064565b84848481811061121a5761121a61316e565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061124d8161319a565b91505061115a565b3360009081526003602052604090205460ff166112ad5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108de565b60048190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b39060200161104a565b3360009081526003602052604090205460ff1661133a5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108de565b82811461137b5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108de565b60005b83811015610c7f578282828181106113985761139861316e565b90506020020135600c60008787858181106113b5576113b561316e565b90506020020160208101906113ca9190613064565b6001600160a01b031681526020810191909152604001600020557f0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba68585838181106114175761141761316e565b905060200201602081019061142c9190613064565b84848481811061143e5761143e61316e565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a1806114718161319a565b91505061137e565b6001546001600160a01b031633146114d35760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108de565b610fbe81612002565b6110bc33612002565b6001546001600160a01b0316331461153f5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108de565b6110bc60006120bb565b6001546001600160a01b031633146115a35760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108de565b610fbe8161210d565b3360009081526002602052604090205460ff1661160b5760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108de565b6110bc6121ca565b600154600160a01b900460ff16156116605760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108de565b600061166b82612252565b9050611684816000015182602001518360400151612417565b5050565b6001546001600160a01b031633146116e25760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108de565b600e80546001600160a01b0319166001600160a01b0392909216919091179055565b600154600160a01b900460ff16156117515760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108de565b600046306040516020016117a792919091825260601b6bffffffffffffffffffffffff191660208201527f57697468647261770000000000000000000000000000000000000000000000006034820152603c0190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828b8b604051602001611803939291906131b5565b6040516020818303038152906040528989898989896040518863ffffffff1660e01b815260040161183a97969594939291906132e6565b60006040518083038186803b15801561185257600080fd5b505afa158015611866573d6000803e3d6000fd5b5050505060006118ab8a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061254c92505050565b6020818101518251604080850151606080870151608088015160a0890151855197841b6bffffffffffffffffffffffff19908116898b015296841b871660348901526048880194909452911b909316606885015260c09290921b77ffffffffffffffffffffffffffffffffffffffffffffffff1916607c8401526084808401929092528051808403909201825260a490920182528051908301206000818152600b9093529120549192509060ff16156119965760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108de565b6000818152600b602052604090819020805460ff191660011790558251908301516119c191906126ae565b81516001600160a01b031660009081526009602052604090205480158015906119ed5750808360400151115b15611a0f57611a0a828460200151856000015186604001516127c6565b611a26565b611a26836020015184600001518560400151612417565b602080840151845160408087015160808089015160a0808b01516060808d015187518d81526001600160a01b039a8b169b81019b909b52978916968a01969096529488019390935267ffffffffffffffff16908601528401521660c08201527f296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb9060e00160405180910390a1505050505050505050505050565b6110bc336128d9565b6001546001600160a01b03163314611b235760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108de565b610fbe816128d9565b6001546001600160a01b03163314611b865760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108de565b6001600160a01b038116611c025760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016108de565b610fbe816120bb565b6001600160a01b0385166000908152600c60205260408120548511611c725760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c0000000000000000000000000000000060448201526064016108de565b6001600160a01b0386166000908152600d60205260409020541580611caf57506001600160a01b0386166000908152600d60205260409020548511155b611cfb5760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c617267650000000000000000000000000000000060448201526064016108de565b6040516bffffffffffffffffffffffff1933606090811b8216602084015288811b821660348401526048830188905277ffffffffffffffffffffffffffffffffffffffffffffffff1960c088811b821660688601529187901b909216607084015284811b8216608484015246901b16608c82015260009060940160408051601f1981840301815291815281516020928301206000818152600b90935291205490915060ff1615611ddd5760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108de565b6000818152600b60205260409020805460ff19166001179055905095945050505050565b6040516001600160a01b0380851660248301528316604482015260648101829052611e999085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612992565b50505050565b6001600160a01b03811660009081526003602052604090205460ff1615611f085760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016108de565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5910161104a565b600154600160a01b900460ff16611fb55760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f742070617573656400000000000000000000000060448201526064016108de565b6001805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526002602052604090205460ff1661206a5760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f7420706175736572000000000000000000000060448201526064016108de565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e910161104a565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03811660009081526002602052604090205460ff16156121765760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064016108de565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8910161104a565b600154600160a01b900460ff16156122175760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108de565b6001805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611fe53390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260086020908152604091829020825160808101845281546001600160a01b03908116825260018301541692810192909252600281015492820192909252600390910154606082018190526123115760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f7420657869737400000000000060448201526064016108de565b600a54816060015161232391906133c6565b42116123715760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b656400000060448201526064016108de565b600083815260086020908152604080832080546001600160a01b03199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d44269361240993889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b600e546001600160a01b038381169116141561253357600e54604051632e1a7d4d60e01b8152600481018390526001600160a01b0390911690632e1a7d4d90602401600060405180830381600087803b15801561247357600080fd5b505af1158015612487573d6000803e3d6000fd5b505050506000836001600160a01b03168261c35090604051600060405180830381858888f193505050503d80600081146124dd576040519150601f19603f3d011682016040523d82523d6000602084013e6124e2565b606091505b5050905080611e995760405162461bcd60e51b815260206004820152601b60248201527f6661696c656420746f2073656e64206e617469766520746f6b656e000000000060448201526064016108de565b6125476001600160a01b0383168483612a77565b505050565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b602083015151835110156126a6576125aa83612aa7565b909250905081600114156125d9576125c96125c484612ae1565b612b9e565b6001600160a01b03168452612593565b8160021415612601576125ee6125c484612ae1565b6001600160a01b03166020850152612593565b81600314156126255761261b61261684612ae1565b612baf565b6040850152612593565b816004141561264d5761263a6125c484612ae1565b6001600160a01b03166060850152612593565b81600514156126735761265f83612be6565b67ffffffffffffffff166080850152612593565b81600614156126975761268d61268884612ae1565b612c68565b60a0850152612593565b6126a18382612c80565b612593565b505050919050565b6004546126b9575050565b6001600160a01b038216600090815260066020526040902054806126dc57505050565b6001600160a01b0383166000908152600560205260408120546004549091429161270681846133de565b6127109190613400565b6001600160a01b03871660009081526007602052604090205490915081111561273b57849250612748565b61274585846133c6565b92505b838311156127985760405162461bcd60e51b815260206004820152601260248201527f766f6c756d65206578636565647320636170000000000000000000000000000060448201526064016108de565b506001600160a01b039094166000908152600560209081526040808320939093556007905220929092555050565b600084815260086020526040902060030154156128255760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c7265616479206578697374730060448201526064016108de565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b8152600890935291869020945185549085166001600160a01b031991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6906128cb9086815260200190565b60405180910390a150505050565b6001600160a01b03811660009081526003602052604090205460ff166129415760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f7200000000000000000060448201526064016108de565b6001600160a01b038116600081815260036020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b910161104a565b60006129e7826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316612cf29092919063ffffffff16565b8051909150156125475780806020019051810190612a05919061341f565b6125475760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016108de565b6040516001600160a01b03831660248201526044810182905261254790849063a9059cbb60e01b90606401611e35565b6000806000612ab584612be6565b9050612ac26008826133de565b9250806007166005811115612ad957612ad9613441565b915050915091565b60606000612aee83612be6565b90506000818460000151612b0291906133c6565b9050836020015151811115612b1657600080fd5b8167ffffffffffffffff811115612b2f57612b2f613457565b6040519080825280601f01601f191660200182016040528015612b59576020820181803683370190505b50602080860151865192955091818601919083010160005b85811015612b93578181015183820152612b8c6020826133c6565b9050612b71565b505050935250919050565b6000612ba982612d0b565b92915050565b6000602082511115612bc057600080fd5b6020820151905081516020612bd5919061346d565b612be0906008613400565b1c919050565b602080820151825181019091015160009182805b600a811015612c625783811a9150612c13816007613400565b82607f16901b851794508160801660001415612c5057612c348160016133c6565b86518790612c439083906133c6565b9052509395945050505050565b80612c5a8161319a565b915050612bfa565b50600080fd5b60008151602014612c7857600080fd5b506020015190565b6000816005811115612c9457612c94613441565b1415612ca35761254782612be6565b6002816005811115612cb757612cb7613441565b14156102aa576000612cc883612be6565b90508083600001818151612cdc91906133c6565b9052506020830151518351111561254757600080fd5b6060612d018484600085612d33565b90505b9392505050565b60008151601414612d1b57600080fd5b50602001516c01000000000000000000000000900490565b606082471015612dab5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016108de565b6001600160a01b0385163b612e025760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016108de565b600080866001600160a01b03168587604051612e1e9190613484565b60006040518083038185875af1925050503d8060008114612e5b576040519150601f19603f3d011682016040523d82523d6000602084013e612e60565b606091505b5091509150612e70828286612e7b565b979650505050505050565b60608315612e8a575081612d04565b825115612e9a5782518084602001fd5b8160405162461bcd60e51b81526004016108de91906134a0565b803567ffffffffffffffff81168114612ecc57600080fd5b919050565b80356001600160a01b0381168114612ecc57600080fd5b60008060008060808587031215612efe57600080fd5b84359350612f0e60208601612eb4565b9250612f1c60408601612ed1565b9150612f2a60608601612eb4565b905092959194509250565b600060208284031215612f4757600080fd5b5035919050565b60008083601f840112612f6057600080fd5b50813567ffffffffffffffff811115612f7857600080fd5b6020830191508360208260051b8501011115612f9357600080fd5b9250929050565b60008060008060408587031215612fb057600080fd5b843567ffffffffffffffff80821115612fc857600080fd5b612fd488838901612f4e565b90965094506020870135915080821115612fed57600080fd5b50612ffa87828801612f4e565b95989497509550505050565b600080600080600060a0868803121561301e57600080fd5b61302786612ed1565b94506020860135935061303c60408701612eb4565b925061304a60608701612ed1565b915061305860808701612eb4565b90509295509295909350565b60006020828403121561307657600080fd5b612d0482612ed1565b6000806000806000806000806080898b03121561309b57600080fd5b883567ffffffffffffffff808211156130b357600080fd5b818b0191508b601f8301126130c757600080fd5b8135818111156130d657600080fd5b8c60208285010111156130e857600080fd5b60209283019a509850908a0135908082111561310357600080fd5b61310f8c838d01612f4e565b909850965060408b013591508082111561312857600080fd5b6131348c838d01612f4e565b909650945060608b013591508082111561314d57600080fd5b5061315a8b828c01612f4e565b999c989b5096995094979396929594505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006000198214156131ae576131ae613184565b5060010190565b838152818360208301376000910160200190815292915050565b60005b838110156131ea5781810151838201526020016131d2565b83811115611e995750506000910152565b600081518084526132138160208601602086016131cf565b601f01601f19169290920160200192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8183526000602080850194508260005b8581101561328c576001600160a01b0361327983612ed1565b1687529582019590820190600101613260565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8311156132c957600080fd5b8260051b8083602087013760009401602001938452509192915050565b6080815260006132f9608083018a6131fb565b82810360208401528088825260208201905060208960051b8301018a60005b8b81101561338c57848303601f190184528135368e9003601e1901811261333e57600080fd5b8d01803567ffffffffffffffff81111561335757600080fd5b8036038f131561336657600080fd5b613374858260208501613227565b60209687019690955093909301925050600101613318565b505084810360408601526133a181898b613250565b9250505082810360608401526133b8818587613297565b9a9950505050505050505050565b600082198211156133d9576133d9613184565b500190565b6000826133fb57634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561341a5761341a613184565b500290565b60006020828403121561343157600080fd5b81518015158114612d0457600080fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b60008282101561347f5761347f613184565b500390565b600082516134968184602087016131cf565b9190910192915050565b602081526000612d0460208301846131fb56fea2646970667358221220d33e8b27b03f82587e63d542e9c1f6b103031a4cdbd4d79a2f9f877d84cb284364736f6c63430008090033",
}

// OriginalTokenVaultABI is the input ABI used to generate the binding from.
// Deprecated: Use OriginalTokenVaultMetaData.ABI instead.
var OriginalTokenVaultABI = OriginalTokenVaultMetaData.ABI

// OriginalTokenVaultBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OriginalTokenVaultMetaData.Bin instead.
var OriginalTokenVaultBin = OriginalTokenVaultMetaData.Bin

// DeployOriginalTokenVault deploys a new Ethereum contract, binding an instance of OriginalTokenVault to it.
func DeployOriginalTokenVault(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *OriginalTokenVault, error) {
	parsed, err := OriginalTokenVaultMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OriginalTokenVaultBin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &OriginalTokenVault{OriginalTokenVaultCaller: OriginalTokenVaultCaller{contract: contract}, OriginalTokenVaultTransactor: OriginalTokenVaultTransactor{contract: contract}, OriginalTokenVaultFilterer: OriginalTokenVaultFilterer{contract: contract}}, nil
}

// OriginalTokenVault is an auto generated Go binding around an Ethereum contract.
type OriginalTokenVault struct {
	OriginalTokenVaultCaller     // Read-only binding to the contract
	OriginalTokenVaultTransactor // Write-only binding to the contract
	OriginalTokenVaultFilterer   // Log filterer for contract events
}

// OriginalTokenVaultCaller is an auto generated read-only Go binding around an Ethereum contract.
type OriginalTokenVaultCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OriginalTokenVaultTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OriginalTokenVaultFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OriginalTokenVaultSession struct {
	Contract     *OriginalTokenVault // Generic contract binding to set the session for
	CallOpts     bind.CallOpts       // Call options to use throughout this session
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// OriginalTokenVaultCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OriginalTokenVaultCallerSession struct {
	Contract *OriginalTokenVaultCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts             // Call options to use throughout this session
}

// OriginalTokenVaultTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OriginalTokenVaultTransactorSession struct {
	Contract     *OriginalTokenVaultTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts             // Transaction auth options to use throughout this session
}

// OriginalTokenVaultRaw is an auto generated low-level Go binding around an Ethereum contract.
type OriginalTokenVaultRaw struct {
	Contract *OriginalTokenVault // Generic contract binding to access the raw methods on
}

// OriginalTokenVaultCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OriginalTokenVaultCallerRaw struct {
	Contract *OriginalTokenVaultCaller // Generic read-only contract binding to access the raw methods on
}

// OriginalTokenVaultTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OriginalTokenVaultTransactorRaw struct {
	Contract *OriginalTokenVaultTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOriginalTokenVault creates a new instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVault(address common.Address, backend bind.ContractBackend) (*OriginalTokenVault, error) {
	contract, err := bindOriginalTokenVault(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVault{OriginalTokenVaultCaller: OriginalTokenVaultCaller{contract: contract}, OriginalTokenVaultTransactor: OriginalTokenVaultTransactor{contract: contract}, OriginalTokenVaultFilterer: OriginalTokenVaultFilterer{contract: contract}}, nil
}

// NewOriginalTokenVaultCaller creates a new read-only instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVaultCaller(address common.Address, caller bind.ContractCaller) (*OriginalTokenVaultCaller, error) {
	contract, err := bindOriginalTokenVault(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultCaller{contract: contract}, nil
}

// NewOriginalTokenVaultTransactor creates a new write-only instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVaultTransactor(address common.Address, transactor bind.ContractTransactor) (*OriginalTokenVaultTransactor, error) {
	contract, err := bindOriginalTokenVault(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultTransactor{contract: contract}, nil
}

// NewOriginalTokenVaultFilterer creates a new log filterer instance of OriginalTokenVault, bound to a specific deployed contract.
func NewOriginalTokenVaultFilterer(address common.Address, filterer bind.ContractFilterer) (*OriginalTokenVaultFilterer, error) {
	contract, err := bindOriginalTokenVault(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultFilterer{contract: contract}, nil
}

// bindOriginalTokenVault binds a generic wrapper to an already deployed contract.
func bindOriginalTokenVault(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OriginalTokenVaultABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVault *OriginalTokenVaultRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVault.Contract.OriginalTokenVaultCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVault *OriginalTokenVaultRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.OriginalTokenVaultTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVault *OriginalTokenVaultRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.OriginalTokenVaultTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVault *OriginalTokenVaultCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVault.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVault *OriginalTokenVaultTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVault *OriginalTokenVaultTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayPeriod(&_OriginalTokenVault.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayPeriod(&_OriginalTokenVault.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayThresholds(&_OriginalTokenVault.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.DelayThresholds(&_OriginalTokenVault.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVault *OriginalTokenVaultCaller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVault *OriginalTokenVaultSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVault.Contract.DelayedTransfers(&_OriginalTokenVault.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVault.Contract.DelayedTransfers(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) EpochLength() (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochLength(&_OriginalTokenVault.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) EpochLength() (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochLength(&_OriginalTokenVault.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumeCaps(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumeCaps(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumes(&_OriginalTokenVault.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.EpochVolumes(&_OriginalTokenVault.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Governors(&_OriginalTokenVault.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Governors(&_OriginalTokenVault.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsGovernor(&_OriginalTokenVault.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsGovernor(&_OriginalTokenVault.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsPauser(&_OriginalTokenVault.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.IsPauser(&_OriginalTokenVault.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.LastOpTimestamps(&_OriginalTokenVault.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.LastOpTimestamps(&_OriginalTokenVault.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) MaxDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "maxDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MaxDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MaxDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCaller) MinDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "minDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MinDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVault.Contract.MinDeposit(&_OriginalTokenVault.CallOpts, arg0)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCaller) NativeWrap(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "nativeWrap")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultSession) NativeWrap() (common.Address, error) {
	return _OriginalTokenVault.Contract.NativeWrap(&_OriginalTokenVault.CallOpts)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) NativeWrap() (common.Address, error) {
	return _OriginalTokenVault.Contract.NativeWrap(&_OriginalTokenVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultSession) Owner() (common.Address, error) {
	return _OriginalTokenVault.Contract.Owner(&_OriginalTokenVault.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Owner() (common.Address, error) {
	return _OriginalTokenVault.Contract.Owner(&_OriginalTokenVault.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Paused() (bool, error) {
	return _OriginalTokenVault.Contract.Paused(&_OriginalTokenVault.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Paused() (bool, error) {
	return _OriginalTokenVault.Contract.Paused(&_OriginalTokenVault.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Pausers(&_OriginalTokenVault.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVault.Contract.Pausers(&_OriginalTokenVault.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultSession) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVault.Contract.Records(&_OriginalTokenVault.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVault.Contract.Records(&_OriginalTokenVault.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCaller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVault.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultSession) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVault.Contract.SigsVerifier(&_OriginalTokenVault.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVault *OriginalTokenVaultCallerSession) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVault.Contract.SigsVerifier(&_OriginalTokenVault.CallOpts)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddPauser(&_OriginalTokenVault.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.AddPauser(&_OriginalTokenVault.TransactOpts, account)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Deposit(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "deposit", _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Deposit(&_OriginalTokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Deposit(&_OriginalTokenVault.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) DepositNative(opts *bind.TransactOpts, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "depositNative", _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.DepositNative(&_OriginalTokenVault.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.DepositNative(&_OriginalTokenVault.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.ExecuteDelayedTransfer(&_OriginalTokenVault.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.ExecuteDelayedTransfer(&_OriginalTokenVault.TransactOpts, id)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Pause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Pause(&_OriginalTokenVault.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Pause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Pause(&_OriginalTokenVault.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemoveGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemoveGovernor(&_OriginalTokenVault.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemovePauser(&_OriginalTokenVault.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RemovePauser(&_OriginalTokenVault.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenounceGovernor(&_OriginalTokenVault.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenounceGovernor(&_OriginalTokenVault.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RenounceOwnership() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenounceOwnership(&_OriginalTokenVault.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenounceOwnership(&_OriginalTokenVault.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenouncePauser(&_OriginalTokenVault.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.RenouncePauser(&_OriginalTokenVault.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayPeriod(&_OriginalTokenVault.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayPeriod(&_OriginalTokenVault.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayThresholds(&_OriginalTokenVault.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetDelayThresholds(&_OriginalTokenVault.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochLength(&_OriginalTokenVault.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochLength(&_OriginalTokenVault.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochVolumeCaps(&_OriginalTokenVault.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetEpochVolumeCaps(&_OriginalTokenVault.TransactOpts, _tokens, _caps)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetMaxDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setMaxDeposit", _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMaxDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMaxDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetMinDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setMinDeposit", _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMinDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetMinDeposit(&_OriginalTokenVault.TransactOpts, _tokens, _amounts)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) SetWrap(opts *bind.TransactOpts, _weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "setWrap", _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetWrap(&_OriginalTokenVault.TransactOpts, _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.SetWrap(&_OriginalTokenVault.TransactOpts, _weth)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.TransferOwnership(&_OriginalTokenVault.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.TransferOwnership(&_OriginalTokenVault.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Unpause(&_OriginalTokenVault.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Unpause(&_OriginalTokenVault.TransactOpts)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Withdraw(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.Transact(opts, "withdraw", _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Withdraw(&_OriginalTokenVault.TransactOpts, _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Withdraw(&_OriginalTokenVault.TransactOpts, _request, _sigs, _signers, _powers)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVault.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVault *OriginalTokenVaultSession) Receive() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Receive(&_OriginalTokenVault.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVault *OriginalTokenVaultTransactorSession) Receive() (*types.Transaction, error) {
	return _OriginalTokenVault.Contract.Receive(&_OriginalTokenVault.TransactOpts)
}

// OriginalTokenVaultDelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayPeriodUpdatedIterator struct {
	Event *OriginalTokenVaultDelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayPeriodUpdated represents a DelayPeriodUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultDelayPeriodUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayPeriodUpdatedIterator{contract: _OriginalTokenVault.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayPeriodUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayPeriodUpdated(log types.Log) (*OriginalTokenVaultDelayPeriodUpdated, error) {
	event := new(OriginalTokenVaultDelayPeriodUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayThresholdUpdatedIterator struct {
	Event *OriginalTokenVaultDelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayThresholdUpdated represents a DelayThresholdUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultDelayThresholdUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayThresholdUpdatedIterator{contract: _OriginalTokenVault.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayThresholdUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayThresholdUpdated(log types.Log) (*OriginalTokenVaultDelayThresholdUpdated, error) {
	event := new(OriginalTokenVaultDelayThresholdUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferAddedIterator struct {
	Event *OriginalTokenVaultDelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayedTransferAdded represents a DelayedTransferAdded event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*OriginalTokenVaultDelayedTransferAddedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayedTransferAddedIterator{contract: _OriginalTokenVault.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayedTransferAdded)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayedTransferAdded(log types.Log) (*OriginalTokenVaultDelayedTransferAdded, error) {
	event := new(OriginalTokenVaultDelayedTransferAdded)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferExecutedIterator struct {
	Event *OriginalTokenVaultDelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDelayedTransferExecuted represents a DelayedTransferExecuted event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*OriginalTokenVaultDelayedTransferExecutedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDelayedTransferExecutedIterator{contract: _OriginalTokenVault.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDelayedTransferExecuted)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDelayedTransferExecuted(log types.Log) (*OriginalTokenVaultDelayedTransferExecuted, error) {
	event := new(OriginalTokenVaultDelayedTransferExecuted)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultDepositedIterator is returned from FilterDeposited and is used to iterate over the raw logs and unpacked data for Deposited events raised by the OriginalTokenVault contract.
type OriginalTokenVaultDepositedIterator struct {
	Event *OriginalTokenVaultDeposited // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultDepositedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultDeposited)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultDeposited)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultDepositedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultDepositedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultDeposited represents a Deposited event raised by the OriginalTokenVault contract.
type OriginalTokenVaultDeposited struct {
	DepositId   [32]byte
	Depositor   common.Address
	Token       common.Address
	Amount      *big.Int
	MintChainId uint64
	MintAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDeposited is a free log retrieval operation binding the contract event 0x15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterDeposited(opts *bind.FilterOpts) (*OriginalTokenVaultDepositedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultDepositedIterator{contract: _OriginalTokenVault.contract, event: "Deposited", logs: logs, sub: sub}, nil
}

// WatchDeposited is a free log subscription operation binding the contract event 0x15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchDeposited(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultDeposited) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultDeposited)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposited is a log parse operation binding the contract event 0x15d2eeefbe4963b5b2178f239ddcc730dda55f1c23c22efb79ded0eb854ac789.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseDeposited(log types.Log) (*OriginalTokenVaultDeposited, error) {
	event := new(OriginalTokenVaultDeposited)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Deposited", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultEpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochLengthUpdatedIterator struct {
	Event *OriginalTokenVaultEpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultEpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultEpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultEpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultEpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultEpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultEpochLengthUpdated represents a EpochLengthUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultEpochLengthUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultEpochLengthUpdatedIterator{contract: _OriginalTokenVault.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultEpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultEpochLengthUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseEpochLengthUpdated(log types.Log) (*OriginalTokenVaultEpochLengthUpdated, error) {
	event := new(OriginalTokenVaultEpochLengthUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultEpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochVolumeUpdatedIterator struct {
	Event *OriginalTokenVaultEpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultEpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultEpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultEpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultEpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultEpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultEpochVolumeUpdated represents a EpochVolumeUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultEpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultEpochVolumeUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultEpochVolumeUpdatedIterator{contract: _OriginalTokenVault.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultEpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultEpochVolumeUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseEpochVolumeUpdated(log types.Log) (*OriginalTokenVaultEpochVolumeUpdated, error) {
	event := new(OriginalTokenVaultEpochVolumeUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultGovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorAddedIterator struct {
	Event *OriginalTokenVaultGovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultGovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultGovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultGovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultGovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultGovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultGovernorAdded represents a GovernorAdded event raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterGovernorAdded(opts *bind.FilterOpts) (*OriginalTokenVaultGovernorAddedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultGovernorAddedIterator{contract: _OriginalTokenVault.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultGovernorAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultGovernorAdded)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseGovernorAdded(log types.Log) (*OriginalTokenVaultGovernorAdded, error) {
	event := new(OriginalTokenVaultGovernorAdded)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultGovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorRemovedIterator struct {
	Event *OriginalTokenVaultGovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultGovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultGovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultGovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultGovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultGovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultGovernorRemoved represents a GovernorRemoved event raised by the OriginalTokenVault contract.
type OriginalTokenVaultGovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultGovernorRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultGovernorRemovedIterator{contract: _OriginalTokenVault.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultGovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultGovernorRemoved)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseGovernorRemoved(log types.Log) (*OriginalTokenVaultGovernorRemoved, error) {
	event := new(OriginalTokenVaultGovernorRemoved)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultMaxDepositUpdatedIterator is returned from FilterMaxDepositUpdated and is used to iterate over the raw logs and unpacked data for MaxDepositUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultMaxDepositUpdatedIterator struct {
	Event *OriginalTokenVaultMaxDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultMaxDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultMaxDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultMaxDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultMaxDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultMaxDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultMaxDepositUpdated represents a MaxDepositUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultMaxDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxDepositUpdated is a free log retrieval operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterMaxDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultMaxDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultMaxDepositUpdatedIterator{contract: _OriginalTokenVault.contract, event: "MaxDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxDepositUpdated is a free log subscription operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchMaxDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultMaxDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultMaxDepositUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxDepositUpdated is a log parse operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseMaxDepositUpdated(log types.Log) (*OriginalTokenVaultMaxDepositUpdated, error) {
	event := new(OriginalTokenVaultMaxDepositUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultMinDepositUpdatedIterator is returned from FilterMinDepositUpdated and is used to iterate over the raw logs and unpacked data for MinDepositUpdated events raised by the OriginalTokenVault contract.
type OriginalTokenVaultMinDepositUpdatedIterator struct {
	Event *OriginalTokenVaultMinDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultMinDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultMinDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultMinDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultMinDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultMinDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultMinDepositUpdated represents a MinDepositUpdated event raised by the OriginalTokenVault contract.
type OriginalTokenVaultMinDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinDepositUpdated is a free log retrieval operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterMinDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultMinDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultMinDepositUpdatedIterator{contract: _OriginalTokenVault.contract, event: "MinDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMinDepositUpdated is a free log subscription operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchMinDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultMinDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultMinDepositUpdated)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinDepositUpdated is a log parse operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseMinDepositUpdated(log types.Log) (*OriginalTokenVaultMinDepositUpdated, error) {
	event := new(OriginalTokenVaultMinDepositUpdated)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the OriginalTokenVault contract.
type OriginalTokenVaultOwnershipTransferredIterator struct {
	Event *OriginalTokenVaultOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultOwnershipTransferred represents a OwnershipTransferred event raised by the OriginalTokenVault contract.
type OriginalTokenVaultOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OriginalTokenVaultOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultOwnershipTransferredIterator{contract: _OriginalTokenVault.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultOwnershipTransferred)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseOwnershipTransferred(log types.Log) (*OriginalTokenVaultOwnershipTransferred, error) {
	event := new(OriginalTokenVaultOwnershipTransferred)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the OriginalTokenVault contract.
type OriginalTokenVaultPausedIterator struct {
	Event *OriginalTokenVaultPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultPaused represents a Paused event raised by the OriginalTokenVault contract.
type OriginalTokenVaultPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterPaused(opts *bind.FilterOpts) (*OriginalTokenVaultPausedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultPausedIterator{contract: _OriginalTokenVault.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultPaused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultPaused)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParsePaused(log types.Log) (*OriginalTokenVaultPaused, error) {
	event := new(OriginalTokenVaultPaused)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultPauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserAddedIterator struct {
	Event *OriginalTokenVaultPauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultPauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultPauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultPauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultPauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultPauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultPauserAdded represents a PauserAdded event raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*OriginalTokenVaultPauserAddedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultPauserAddedIterator{contract: _OriginalTokenVault.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultPauserAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultPauserAdded)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParsePauserAdded(log types.Log) (*OriginalTokenVaultPauserAdded, error) {
	event := new(OriginalTokenVaultPauserAdded)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultPauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserRemovedIterator struct {
	Event *OriginalTokenVaultPauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultPauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultPauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultPauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultPauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultPauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultPauserRemoved represents a PauserRemoved event raised by the OriginalTokenVault contract.
type OriginalTokenVaultPauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultPauserRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultPauserRemovedIterator{contract: _OriginalTokenVault.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultPauserRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultPauserRemoved)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParsePauserRemoved(log types.Log) (*OriginalTokenVaultPauserRemoved, error) {
	event := new(OriginalTokenVaultPauserRemoved)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the OriginalTokenVault contract.
type OriginalTokenVaultUnpausedIterator struct {
	Event *OriginalTokenVaultUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultUnpaused represents a Unpaused event raised by the OriginalTokenVault contract.
type OriginalTokenVaultUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterUnpaused(opts *bind.FilterOpts) (*OriginalTokenVaultUnpausedIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultUnpausedIterator{contract: _OriginalTokenVault.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultUnpaused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultUnpaused)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseUnpaused(log types.Log) (*OriginalTokenVaultUnpaused, error) {
	event := new(OriginalTokenVaultUnpaused)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultWithdrawnIterator is returned from FilterWithdrawn and is used to iterate over the raw logs and unpacked data for Withdrawn events raised by the OriginalTokenVault contract.
type OriginalTokenVaultWithdrawnIterator struct {
	Event *OriginalTokenVaultWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultWithdrawn represents a Withdrawn event raised by the OriginalTokenVault contract.
type OriginalTokenVaultWithdrawn struct {
	WithdrawId  [32]byte
	Receiver    common.Address
	Token       common.Address
	Amount      *big.Int
	RefChainId  uint64
	RefId       [32]byte
	BurnAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawn is a free log retrieval operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) FilterWithdrawn(opts *bind.FilterOpts) (*OriginalTokenVaultWithdrawnIterator, error) {

	logs, sub, err := _OriginalTokenVault.contract.FilterLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultWithdrawnIterator{contract: _OriginalTokenVault.contract, event: "Withdrawn", logs: logs, sub: sub}, nil
}

// WatchWithdrawn is a free log subscription operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) WatchWithdrawn(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultWithdrawn) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVault.contract.WatchLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultWithdrawn)
				if err := _OriginalTokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawn is a log parse operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVault *OriginalTokenVaultFilterer) ParseWithdrawn(log types.Log) (*OriginalTokenVaultWithdrawn, error) {
	event := new(OriginalTokenVaultWithdrawn)
	if err := _OriginalTokenVault.contract.UnpackLog(event, "Withdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMetaData contains all meta data concerning the PeggedTokenBridge contract.
var PeggedTokenBridgeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"burnId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawAccount\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mintId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_withdrawAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b5060405162002d8b38038062002d8b83398101604081905262000034916200024f565b6200003f3362000074565b6000805460ff60a01b191690556200005733620000c4565b62000062336200018f565b6001600160a01b031660805262000281565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b03811660009081526001602052604090205460ff1615620001335760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526002602052604090205460ff1615620001fa5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016200012a565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5910162000184565b6000602082840312156200026257600080fd5b81516001600160a01b03811681146200027a57600080fd5b9392505050565b608051612ae7620002a46000396000818161051e01526114160152612ae76000f3fe608060405234801561001057600080fd5b506004361061025c5760003560e01c806382dc1ec411610145578063de790c7e116100bd578063eecdac881161008c578063f832138311610071578063f8321383146105d0578063f8734302146105f0578063f9a8ea081461060357600080fd5b8063eecdac88146105aa578063f2fde38b146105bd57600080fd5b8063de790c7e14610540578063e026049c14610553578063e3eece261461055b578063e43581b81461057e57600080fd5b8063adc0d57f11610114578063b5f2bc47116100f9578063b5f2bc47146104e6578063bf4816f014610506578063ccf2683b1461051957600080fd5b8063adc0d57f14610470578063b1c94d94146104dd57600080fd5b806382dc1ec41461041d5780638456cb59146104305780638da5cb5b146104385780639e25fc5c1461045d57600080fd5b806354eea796116101d85780636b2c0f55116101a7578063715018a61161018c578063715018a6146103d25780637f856013146103da57806380f51c12146103fa57600080fd5b80636b2c0f55146103b75780636ef8d66d146103ca57600080fd5b806354eea7961461036957806357d775f81461037c5780635c975abb1461038557806360216b001461039757600080fd5b80633f4ba83a1161022f57806347b16c6c1161021457806347b16c6c14610308578063497bf3b21461031b57806352532faa1461034957600080fd5b80633f4ba83a146102d457806346fbf68e146102dc57600080fd5b806301e647251461026157806317bdbae5146102995780633c4a25d0146102ae5780633d572107146102c1575b600080fd5b61028461026f36600461256e565b600a6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b6102ac6102a73660046125d3565b610616565b005b6102ac6102bc36600461265b565b6107b9565b6102ac6102cf36600461256e565b61081f565b6102ac6108b3565b6102846102ea36600461265b565b6001600160a01b031660009081526001602052604090205460ff1690565b6102ac6103163660046125d3565b61091c565b61033b61032936600461265b565b600c6020526000908152604090205481565b604051908152602001610290565b61033b61035736600461265b565b60086020526000908152604090205481565b6102ac61037736600461256e565b610ab3565b61033b60035481565b600054600160a01b900460ff16610284565b61033b6103a536600461265b565b60046020526000908152604090205481565b6102ac6103c536600461265b565b610b40565b6102ac610ba3565b6102ac610bac565b61033b6103e836600461265b565b600b6020526000908152604090205481565b61028461040836600461265b565b60016020526000908152604090205460ff1681565b6102ac61042b36600461265b565b610c10565b6102ac610c73565b6000546001600160a01b03165b6040516001600160a01b039091168152602001610290565b6102ac61046b36600461256e565b610cda565b6104b261047e36600461256e565b60076020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b039586168152949093166020850152918301526060820152608001610290565b61033b60095481565b61033b6104f436600461265b565b60056020526000908152604090205481565b6102ac6105143660046125d3565b610da7565b6104457f000000000000000000000000000000000000000000000000000000000000000081565b6102ac61054e36600461267d565b610f3e565b6102ac611227565b61028461056936600461265b565b60026020526000908152604090205460ff1681565b61028461058c36600461265b565b6001600160a01b031660009081526002602052604090205460ff1690565b6102ac6105b836600461265b565b611230565b6102ac6105cb36600461265b565b611293565b61033b6105de36600461265b565b60066020526000908152604090205481565b6102ac6105fe3660046126d9565b611372565b6102ac6106113660046125d3565b61177b565b3360009081526002602052604090205460ff166106735760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064015b60405180910390fd5b8281146106b45760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161066a565b60005b838110156107b2578282828181106106d1576106d16127c8565b90506020020135600860008787858181106106ee576106ee6127c8565b9050602002016020810190610703919061265b565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce858583818110610750576107506127c8565b9050602002016020810190610765919061265b565b848484818110610777576107776127c8565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a1806107aa816127f4565b9150506106b7565b5050505050565b6000546001600160a01b031633146108135760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161066a565b61081c81611912565b50565b3360009081526002602052604090205460ff166108775760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161066a565b60098190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526001602052604090205460ff166109125760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f7420706175736572000000000000000000000000604482015260640161066a565b61091a6119cf565b565b3360009081526002602052604090205460ff166109745760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161066a565b8281146109b55760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161066a565b60005b838110156107b2578282828181106109d2576109d26127c8565b90506020020135600560008787858181106109ef576109ef6127c8565b9050602002016020810190610a04919061265b565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89858583818110610a5157610a516127c8565b9050602002016020810190610a66919061265b565b848484818110610a7857610a786127c8565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610aab816127f4565b9150506109b8565b3360009081526002602052604090205460ff16610b0b5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161066a565b60038190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3906020016108a8565b6000546001600160a01b03163314610b9a5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161066a565b61081c81611a75565b61091a33611a75565b6000546001600160a01b03163314610c065760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161066a565b61091a6000611b2e565b6000546001600160a01b03163314610c6a5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161066a565b61081c81611b8b565b3360009081526001602052604090205460ff16610cd25760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f7420706175736572000000000000000000000000604482015260640161066a565b61091a611c49565b600054600160a01b900460ff1615610d275760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161066a565b6000610d3282611cd1565b6020810151815160408084015190516340c10f1960e01b81526001600160a01b039283166004820152602481019190915292935016906340c10f1990604401600060405180830381600087803b158015610d8b57600080fd5b505af1158015610d9f573d6000803e3d6000fd5b505050505050565b3360009081526002602052604090205460ff16610dff5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161066a565b828114610e405760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161066a565b60005b838110156107b257828282818110610e5d57610e5d6127c8565b90506020020135600b6000878785818110610e7a57610e7a6127c8565b9050602002016020810190610e8f919061265b565b6001600160a01b031681526020810191909152604001600020557f3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683858583818110610edc57610edc6127c8565b9050602002016020810190610ef1919061265b565b848484818110610f0357610f036127c8565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610f36816127f4565b915050610e43565b600054600160a01b900460ff1615610f8b5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161066a565b6001600160a01b0384166000908152600b60205260409020548311610ff25760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c00000000000000000000000000000000604482015260640161066a565b6001600160a01b0384166000908152600c6020526040902054158061102f57506001600160a01b0384166000908152600c60205260409020548311155b61107b5760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c6172676500000000000000000000000000000000604482015260640161066a565b6040516bffffffffffffffffffffffff1933606090811b8216602084015286811b821660348401526048830186905284901b16606882015277ffffffffffffffffffffffffffffffffffffffffffffffff1960c083811b8216607c84015246901b166084820152600090608c0160408051601f1981840301815291815281516020928301206000818152600a90935291205490915060ff16156111505760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b604482015260640161066a565b6000818152600a602052604090819020805460ff1916600117905551632770a7eb60e21b8152336004820152602481018590526001600160a01b03861690639dc29fac90604401600060405180830381600087803b1580156111b157600080fd5b505af11580156111c5573d6000803e3d6000fd5b5050604080518481526001600160a01b0389811660208301523382840152606082018990528716608082015290517f75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d4393509081900360a0019150a15050505050565b61091a33611ea3565b6000546001600160a01b0316331461128a5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161066a565b61081c81611ea3565b6000546001600160a01b031633146112ed5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161066a565b6001600160a01b0381166113695760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161066a565b61081c81611b2e565b600054600160a01b900460ff16156113bf5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161066a565b600046306040516020016113fc92919091825260601b6bffffffffffffffffffffffff1916602082015263135a5b9d60e21b603482015260380190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828b8b6040516020016114589392919061280f565b6040516020818303038152906040528989898989896040518863ffffffff1660e01b815260040161148f9796959493929190612979565b60006040518083038186803b1580156114a757600080fd5b505afa1580156114bb573d6000803e3d6000fd5b5050505060006115008a8a8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250611f5c92505050565b6020818101518251604080850151606080870151608088015160a0890151855197841b6bffffffffffffffffffffffff19908116898b015296841b871660348901526048880194909452911b909316606885015260c09290921b77ffffffffffffffffffffffffffffffffffffffffffffffff1916607c8401526084808401929092528051808403909201825260a490920182528051908301206000818152600a9093529120549192509060ff16156115eb5760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b604482015260640161066a565b6000818152600a602052604090819020805460ff1916600117905582519083015161161691906120be565b81516001600160a01b031660009081526008602052604090205480158015906116425750808360400151115b156116645761165f828460200151856000015186604001516121d6565b6116d4565b8251602084015160408086015190516340c10f1960e01b81526001600160a01b03928316600482015260248101919091529116906340c10f1990604401600060405180830381600087803b1580156116bb57600080fd5b505af11580156116cf573d6000803e3d6000fd5b505050505b7f5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a8284600001518560200151866040015187608001518860a00151896060015160405161176597969594939291909687526001600160a01b0395861660208801529385166040870152606086019290925267ffffffffffffffff16608085015260a08401521660c082015260e00190565b60405180910390a1505050505050505050505050565b3360009081526002602052604090205460ff166117d35760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161066a565b8281146118145760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161066a565b60005b838110156107b257828282818110611831576118316127c8565b90506020020135600c600087878581811061184e5761184e6127c8565b9050602002016020810190611863919061265b565b6001600160a01b031681526020810191909152604001600020557fa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da58585838181106118b0576118b06127c8565b90506020020160208101906118c5919061265b565b8484848181106118d7576118d76127c8565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061190a816127f4565b915050611817565b6001600160a01b03811660009081526002602052604090205460ff161561197b5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f720000000000604482015260640161066a565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b591016108a8565b600054600160a01b900460ff16611a285760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f7420706175736564000000000000000000000000604482015260640161066a565b6000805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526001602052604090205460ff16611add5760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f74207061757365720000000000000000000000604482015260640161066a565b6001600160a01b038116600081815260016020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e91016108a8565b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b03811660009081526001602052604090205460ff1615611bf45760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c72656164792070617573657200000000000000604482015260640161066a565b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891016108a8565b600054600160a01b900460ff1615611c965760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161066a565b6000805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611a583390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260076020908152604091829020825160808101845281546001600160a01b0390811682526001830154169281019290925260028101549282019290925260039091015460608201819052611d905760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f74206578697374000000000000604482015260640161066a565b6009548160600151611da29190612a15565b4211611df05760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b6564000000604482015260640161066a565b6000838152600760209081526040808320805473ffffffffffffffffffffffffffffffffffffffff199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d442693611e9593889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b6001600160a01b03811660009081526002602052604090205460ff16611f0b5760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f72000000000000000000604482015260640161066a565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b91016108a8565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b602083015151835110156120b657611fba836122f6565b90925090508160011415611fe957611fd9611fd484612330565b6123ed565b6001600160a01b03168452611fa3565b816002141561201157611ffe611fd484612330565b6001600160a01b03166020850152611fa3565b81600314156120355761202b61202684612330565b6123fe565b6040850152611fa3565b816004141561205d5761204a611fd484612330565b6001600160a01b03166060850152611fa3565b81600514156120835761206f83612435565b67ffffffffffffffff166080850152611fa3565b81600614156120a75761209d61209884612330565b6124b7565b60a0850152611fa3565b6120b183826124cf565b611fa3565b505050919050565b6003546120c9575050565b6001600160a01b038216600090815260056020526040902054806120ec57505050565b6001600160a01b038316600090815260046020526040812054600354909142916121168184612a2d565b6121209190612a4f565b6001600160a01b03871660009081526006602052604090205490915081111561214b57849250612158565b6121558584612a15565b92505b838311156121a85760405162461bcd60e51b815260206004820152601260248201527f766f6c756d652065786365656473206361700000000000000000000000000000604482015260640161066a565b506001600160a01b039094166000908152600460209081526040808320939093556006905220929092555050565b600084815260076020526040902060030154156122355760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c72656164792065786973747300604482015260640161066a565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b81526007909352918690209451855490851673ffffffffffffffffffffffffffffffffffffffff1991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6906122e89086815260200190565b60405180910390a150505050565b600080600061230484612435565b9050612311600882612a2d565b925080600716600581111561232857612328612a6e565b915050915091565b6060600061233d83612435565b905060008184600001516123519190612a15565b905083602001515181111561236557600080fd5b8167ffffffffffffffff81111561237e5761237e612a84565b6040519080825280601f01601f1916602001820160405280156123a8576020820181803683370190505b50602080860151865192955091818601919083010160005b858110156123e25781810151838201526123db602082612a15565b90506123c0565b505050935250919050565b60006123f882612546565b92915050565b600060208251111561240f57600080fd5b60208201519050815160206124249190612a9a565b61242f906008612a4f565b1c919050565b602080820151825181019091015160009182805b600a8110156124b15783811a9150612462816007612a4f565b82607f16901b85179450816080166000141561249f57612483816001612a15565b86518790612492908390612a15565b9052509395945050505050565b806124a9816127f4565b915050612449565b50600080fd5b600081516020146124c757600080fd5b506020015190565b60008160058111156124e3576124e3612a6e565b14156124f7576124f282612435565b505050565b600281600581111561250b5761250b612a6e565b141561025c57600061251c83612435565b905080836000018181516125309190612a15565b905250602083015151835111156124f257600080fd5b6000815160141461255657600080fd5b50602001516c01000000000000000000000000900490565b60006020828403121561258057600080fd5b5035919050565b60008083601f84011261259957600080fd5b50813567ffffffffffffffff8111156125b157600080fd5b6020830191508360208260051b85010111156125cc57600080fd5b9250929050565b600080600080604085870312156125e957600080fd5b843567ffffffffffffffff8082111561260157600080fd5b61260d88838901612587565b9096509450602087013591508082111561262657600080fd5b5061263387828801612587565b95989497509550505050565b80356001600160a01b038116811461265657600080fd5b919050565b60006020828403121561266d57600080fd5b6126768261263f565b9392505050565b6000806000806080858703121561269357600080fd5b61269c8561263f565b9350602085013592506126b16040860161263f565b9150606085013567ffffffffffffffff811681146126ce57600080fd5b939692955090935050565b6000806000806000806000806080898b0312156126f557600080fd5b883567ffffffffffffffff8082111561270d57600080fd5b818b0191508b601f83011261272157600080fd5b81358181111561273057600080fd5b8c602082850101111561274257600080fd5b60209283019a509850908a0135908082111561275d57600080fd5b6127698c838d01612587565b909850965060408b013591508082111561278257600080fd5b61278e8c838d01612587565b909650945060608b01359150808211156127a757600080fd5b506127b48b828c01612587565b999c989b5096995094979396929594505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600019821415612808576128086127de565b5060010190565b838152818360208301376000910160200190815292915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b81835260006020808501808196508560051b810191508460005b878110156128d65782840389528135601e1988360301811261288d57600080fd5b8701803567ffffffffffffffff8111156128a657600080fd5b8036038913156128b557600080fd5b6128c28682898501612829565b9a87019a955050509084019060010161286c565b5091979650505050505050565b8183526000602080850194508260005b8581101561291f576001600160a01b0361290c8361263f565b16875295820195908201906001016128f3565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff83111561295c57600080fd5b8260051b8083602087013760009401602001938452509192915050565b608081526000885180608084015260005b818110156129a7576020818c0181015160a086840101520161298a565b818111156129b957600060a083860101525b50601f01601f1916820182810360a090810160208501526129dd908201898b612852565b905082810360408401526129f28187896128e3565b90508281036060840152612a0781858761292a565b9a9950505050505050505050565b60008219821115612a2857612a286127de565b500190565b600082612a4a57634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615612a6957612a696127de565b500290565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b600082821015612aac57612aac6127de565b50039056fea26469706673582212203a3a93226f2ab7321df6287b9ecdf0aaba08910048c645eb13f75cf74a74107164736f6c63430008090033",
}

// PeggedTokenBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use PeggedTokenBridgeMetaData.ABI instead.
var PeggedTokenBridgeABI = PeggedTokenBridgeMetaData.ABI

// PeggedTokenBridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PeggedTokenBridgeMetaData.Bin instead.
var PeggedTokenBridgeBin = PeggedTokenBridgeMetaData.Bin

// DeployPeggedTokenBridge deploys a new Ethereum contract, binding an instance of PeggedTokenBridge to it.
func DeployPeggedTokenBridge(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *PeggedTokenBridge, error) {
	parsed, err := PeggedTokenBridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PeggedTokenBridgeBin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PeggedTokenBridge{PeggedTokenBridgeCaller: PeggedTokenBridgeCaller{contract: contract}, PeggedTokenBridgeTransactor: PeggedTokenBridgeTransactor{contract: contract}, PeggedTokenBridgeFilterer: PeggedTokenBridgeFilterer{contract: contract}}, nil
}

// PeggedTokenBridge is an auto generated Go binding around an Ethereum contract.
type PeggedTokenBridge struct {
	PeggedTokenBridgeCaller     // Read-only binding to the contract
	PeggedTokenBridgeTransactor // Write-only binding to the contract
	PeggedTokenBridgeFilterer   // Log filterer for contract events
}

// PeggedTokenBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PeggedTokenBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PeggedTokenBridgeSession struct {
	Contract     *PeggedTokenBridge // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PeggedTokenBridgeCallerSession struct {
	Contract *PeggedTokenBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// PeggedTokenBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PeggedTokenBridgeTransactorSession struct {
	Contract     *PeggedTokenBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type PeggedTokenBridgeRaw struct {
	Contract *PeggedTokenBridge // Generic contract binding to access the raw methods on
}

// PeggedTokenBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeCallerRaw struct {
	Contract *PeggedTokenBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// PeggedTokenBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeTransactorRaw struct {
	Contract *PeggedTokenBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPeggedTokenBridge creates a new instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridge(address common.Address, backend bind.ContractBackend) (*PeggedTokenBridge, error) {
	contract, err := bindPeggedTokenBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridge{PeggedTokenBridgeCaller: PeggedTokenBridgeCaller{contract: contract}, PeggedTokenBridgeTransactor: PeggedTokenBridgeTransactor{contract: contract}, PeggedTokenBridgeFilterer: PeggedTokenBridgeFilterer{contract: contract}}, nil
}

// NewPeggedTokenBridgeCaller creates a new read-only instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridgeCaller(address common.Address, caller bind.ContractCaller) (*PeggedTokenBridgeCaller, error) {
	contract, err := bindPeggedTokenBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeCaller{contract: contract}, nil
}

// NewPeggedTokenBridgeTransactor creates a new write-only instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*PeggedTokenBridgeTransactor, error) {
	contract, err := bindPeggedTokenBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeTransactor{contract: contract}, nil
}

// NewPeggedTokenBridgeFilterer creates a new log filterer instance of PeggedTokenBridge, bound to a specific deployed contract.
func NewPeggedTokenBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*PeggedTokenBridgeFilterer, error) {
	contract, err := bindPeggedTokenBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeFilterer{contract: contract}, nil
}

// bindPeggedTokenBridge binds a generic wrapper to an already deployed contract.
func bindPeggedTokenBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PeggedTokenBridgeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridge *PeggedTokenBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridge.Contract.PeggedTokenBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridge *PeggedTokenBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.PeggedTokenBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridge *PeggedTokenBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.PeggedTokenBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridge *PeggedTokenBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayPeriod(&_PeggedTokenBridge.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayPeriod(&_PeggedTokenBridge.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayThresholds(&_PeggedTokenBridge.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.DelayThresholds(&_PeggedTokenBridge.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridge.Contract.DelayedTransfers(&_PeggedTokenBridge.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridge.Contract.DelayedTransfers(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochLength(&_PeggedTokenBridge.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochLength(&_PeggedTokenBridge.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumeCaps(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumeCaps(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumes(&_PeggedTokenBridge.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.EpochVolumes(&_PeggedTokenBridge.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Governors(&_PeggedTokenBridge.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Governors(&_PeggedTokenBridge.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsGovernor(&_PeggedTokenBridge.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsGovernor(&_PeggedTokenBridge.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsPauser(&_PeggedTokenBridge.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.IsPauser(&_PeggedTokenBridge.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.LastOpTimestamps(&_PeggedTokenBridge.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.LastOpTimestamps(&_PeggedTokenBridge.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) MaxBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "maxBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MaxBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MaxBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) MinBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "minBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MinBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridge.Contract.MinBurn(&_PeggedTokenBridge.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Owner() (common.Address, error) {
	return _PeggedTokenBridge.Contract.Owner(&_PeggedTokenBridge.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Owner() (common.Address, error) {
	return _PeggedTokenBridge.Contract.Owner(&_PeggedTokenBridge.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Paused() (bool, error) {
	return _PeggedTokenBridge.Contract.Paused(&_PeggedTokenBridge.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Paused() (bool, error) {
	return _PeggedTokenBridge.Contract.Paused(&_PeggedTokenBridge.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Pausers(&_PeggedTokenBridge.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridge.Contract.Pausers(&_PeggedTokenBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridge.Contract.Records(&_PeggedTokenBridge.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridge.Contract.Records(&_PeggedTokenBridge.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCaller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridge.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridge.Contract.SigsVerifier(&_PeggedTokenBridge.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridge *PeggedTokenBridgeCallerSession) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridge.Contract.SigsVerifier(&_PeggedTokenBridge.CallOpts)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddPauser(&_PeggedTokenBridge.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.AddPauser(&_PeggedTokenBridge.TransactOpts, account)
}

// Burn is a paid mutator transaction binding the contract method 0xde790c7e.
//
// Solidity: function burn(address _token, uint256 _amount, address _withdrawAccount, uint64 _nonce) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Burn(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "burn", _token, _amount, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xde790c7e.
//
// Solidity: function burn(address _token, uint256 _amount, address _withdrawAccount, uint64 _nonce) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Burn(_token common.Address, _amount *big.Int, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Burn(&_PeggedTokenBridge.TransactOpts, _token, _amount, _withdrawAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xde790c7e.
//
// Solidity: function burn(address _token, uint256 _amount, address _withdrawAccount, uint64 _nonce) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Burn(_token common.Address, _amount *big.Int, _withdrawAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Burn(&_PeggedTokenBridge.TransactOpts, _token, _amount, _withdrawAccount, _nonce)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridge.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridge.TransactOpts, id)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Mint(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "mint", _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Mint(&_PeggedTokenBridge.TransactOpts, _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Mint(&_PeggedTokenBridge.TransactOpts, _request, _sigs, _signers, _powers)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Pause(&_PeggedTokenBridge.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Pause(&_PeggedTokenBridge.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemoveGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemoveGovernor(&_PeggedTokenBridge.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemovePauser(&_PeggedTokenBridge.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RemovePauser(&_PeggedTokenBridge.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenounceGovernor(&_PeggedTokenBridge.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenounceGovernor(&_PeggedTokenBridge.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RenounceOwnership() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenounceOwnership(&_PeggedTokenBridge.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenounceOwnership(&_PeggedTokenBridge.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenouncePauser(&_PeggedTokenBridge.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.RenouncePauser(&_PeggedTokenBridge.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayPeriod(&_PeggedTokenBridge.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayPeriod(&_PeggedTokenBridge.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayThresholds(&_PeggedTokenBridge.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetDelayThresholds(&_PeggedTokenBridge.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochLength(&_PeggedTokenBridge.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochLength(&_PeggedTokenBridge.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochVolumeCaps(&_PeggedTokenBridge.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetEpochVolumeCaps(&_PeggedTokenBridge.TransactOpts, _tokens, _caps)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetMaxBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setMaxBurn", _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMaxBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMaxBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) SetMinBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "setMinBurn", _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMinBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.SetMinBurn(&_PeggedTokenBridge.TransactOpts, _tokens, _amounts)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.TransferOwnership(&_PeggedTokenBridge.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.TransferOwnership(&_PeggedTokenBridge.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridge.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeSession) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Unpause(&_PeggedTokenBridge.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridge *PeggedTokenBridgeTransactorSession) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridge.Contract.Unpause(&_PeggedTokenBridge.TransactOpts)
}

// PeggedTokenBridgeBurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeBurnIterator struct {
	Event *PeggedTokenBridgeBurn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeBurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeBurn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeBurn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeBurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeBurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeBurn represents a Burn event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeBurn struct {
	BurnId          [32]byte
	Token           common.Address
	Account         common.Address
	Amount          *big.Int
	WithdrawAccount common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0x75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d43.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, address withdrawAccount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterBurn(opts *bind.FilterOpts) (*PeggedTokenBridgeBurnIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeBurnIterator{contract: _PeggedTokenBridge.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0x75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d43.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, address withdrawAccount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeBurn) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeBurn)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0x75f1bf55bb1de41b63a775dc7d4500f01114ee62b688a6b11d34f4692c1f3d43.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, address withdrawAccount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseBurn(log types.Log) (*PeggedTokenBridgeBurn, error) {
	event := new(PeggedTokenBridgeBurn)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayPeriodUpdatedIterator struct {
	Event *PeggedTokenBridgeDelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayPeriodUpdated represents a DelayPeriodUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayPeriodUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayPeriodUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayPeriodUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayPeriodUpdated(log types.Log) (*PeggedTokenBridgeDelayPeriodUpdated, error) {
	event := new(PeggedTokenBridgeDelayPeriodUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayThresholdUpdatedIterator struct {
	Event *PeggedTokenBridgeDelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayThresholdUpdated represents a DelayThresholdUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayThresholdUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayThresholdUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayThresholdUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayThresholdUpdated(log types.Log) (*PeggedTokenBridgeDelayThresholdUpdated, error) {
	event := new(PeggedTokenBridgeDelayThresholdUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferAddedIterator struct {
	Event *PeggedTokenBridgeDelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayedTransferAdded represents a DelayedTransferAdded event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayedTransferAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayedTransferAddedIterator{contract: _PeggedTokenBridge.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayedTransferAdded)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayedTransferAdded(log types.Log) (*PeggedTokenBridgeDelayedTransferAdded, error) {
	event := new(PeggedTokenBridgeDelayedTransferAdded)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeDelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferExecutedIterator struct {
	Event *PeggedTokenBridgeDelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeDelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeDelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeDelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeDelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeDelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeDelayedTransferExecuted represents a DelayedTransferExecuted event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeDelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*PeggedTokenBridgeDelayedTransferExecutedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeDelayedTransferExecutedIterator{contract: _PeggedTokenBridge.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeDelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeDelayedTransferExecuted)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseDelayedTransferExecuted(log types.Log) (*PeggedTokenBridgeDelayedTransferExecuted, error) {
	event := new(PeggedTokenBridgeDelayedTransferExecuted)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeEpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochLengthUpdatedIterator struct {
	Event *PeggedTokenBridgeEpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeEpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeEpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeEpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeEpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeEpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeEpochLengthUpdated represents a EpochLengthUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeEpochLengthUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeEpochLengthUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeEpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeEpochLengthUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseEpochLengthUpdated(log types.Log) (*PeggedTokenBridgeEpochLengthUpdated, error) {
	event := new(PeggedTokenBridgeEpochLengthUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeEpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochVolumeUpdatedIterator struct {
	Event *PeggedTokenBridgeEpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeEpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeEpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeEpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeEpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeEpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeEpochVolumeUpdated represents a EpochVolumeUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeEpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeEpochVolumeUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeEpochVolumeUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeEpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeEpochVolumeUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseEpochVolumeUpdated(log types.Log) (*PeggedTokenBridgeEpochVolumeUpdated, error) {
	event := new(PeggedTokenBridgeEpochVolumeUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeGovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorAddedIterator struct {
	Event *PeggedTokenBridgeGovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeGovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeGovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeGovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeGovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeGovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeGovernorAdded represents a GovernorAdded event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterGovernorAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeGovernorAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeGovernorAddedIterator{contract: _PeggedTokenBridge.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeGovernorAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeGovernorAdded)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseGovernorAdded(log types.Log) (*PeggedTokenBridgeGovernorAdded, error) {
	event := new(PeggedTokenBridgeGovernorAdded)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeGovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorRemovedIterator struct {
	Event *PeggedTokenBridgeGovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeGovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeGovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeGovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeGovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeGovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeGovernorRemoved represents a GovernorRemoved event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeGovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgeGovernorRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeGovernorRemovedIterator{contract: _PeggedTokenBridge.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeGovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeGovernorRemoved)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseGovernorRemoved(log types.Log) (*PeggedTokenBridgeGovernorRemoved, error) {
	event := new(PeggedTokenBridgeGovernorRemoved)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMaxBurnUpdatedIterator is returned from FilterMaxBurnUpdated and is used to iterate over the raw logs and unpacked data for MaxBurnUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMaxBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeMaxBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeMaxBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeMaxBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeMaxBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeMaxBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeMaxBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeMaxBurnUpdated represents a MaxBurnUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMaxBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxBurnUpdated is a free log retrieval operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterMaxBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeMaxBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeMaxBurnUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "MaxBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxBurnUpdated is a free log subscription operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchMaxBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeMaxBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeMaxBurnUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxBurnUpdated is a log parse operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseMaxBurnUpdated(log types.Log) (*PeggedTokenBridgeMaxBurnUpdated, error) {
	event := new(PeggedTokenBridgeMaxBurnUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMinBurnUpdatedIterator is returned from FilterMinBurnUpdated and is used to iterate over the raw logs and unpacked data for MinBurnUpdated events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMinBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeMinBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeMinBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeMinBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeMinBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeMinBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeMinBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeMinBurnUpdated represents a MinBurnUpdated event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMinBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinBurnUpdated is a free log retrieval operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterMinBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeMinBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeMinBurnUpdatedIterator{contract: _PeggedTokenBridge.contract, event: "MinBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMinBurnUpdated is a free log subscription operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchMinBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeMinBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeMinBurnUpdated)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinBurnUpdated is a log parse operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseMinBurnUpdated(log types.Log) (*PeggedTokenBridgeMinBurnUpdated, error) {
	event := new(PeggedTokenBridgeMinBurnUpdated)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeMintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMintIterator struct {
	Event *PeggedTokenBridgeMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeMint represents a Mint event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeMint struct {
	MintId     [32]byte
	Token      common.Address
	Account    common.Address
	Amount     *big.Int
	RefChainId uint64
	RefId      [32]byte
	Depositor  common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterMint(opts *bind.FilterOpts) (*PeggedTokenBridgeMintIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeMintIterator{contract: _PeggedTokenBridge.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchMint(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeMint) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeMint)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseMint(log types.Log) (*PeggedTokenBridgeMint, error) {
	event := new(PeggedTokenBridgeMint)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeOwnershipTransferredIterator struct {
	Event *PeggedTokenBridgeOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeOwnershipTransferred represents a OwnershipTransferred event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PeggedTokenBridgeOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeOwnershipTransferredIterator{contract: _PeggedTokenBridge.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeOwnershipTransferred)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseOwnershipTransferred(log types.Log) (*PeggedTokenBridgeOwnershipTransferred, error) {
	event := new(PeggedTokenBridgeOwnershipTransferred)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgePausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePausedIterator struct {
	Event *PeggedTokenBridgePaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgePausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgePaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgePaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgePausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgePausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgePaused represents a Paused event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterPaused(opts *bind.FilterOpts) (*PeggedTokenBridgePausedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgePausedIterator{contract: _PeggedTokenBridge.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgePaused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgePaused)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParsePaused(log types.Log) (*PeggedTokenBridgePaused, error) {
	event := new(PeggedTokenBridgePaused)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgePauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserAddedIterator struct {
	Event *PeggedTokenBridgePauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgePauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgePauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgePauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgePauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgePauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgePauserAdded represents a PauserAdded event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterPauserAdded(opts *bind.FilterOpts) (*PeggedTokenBridgePauserAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgePauserAddedIterator{contract: _PeggedTokenBridge.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgePauserAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgePauserAdded)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParsePauserAdded(log types.Log) (*PeggedTokenBridgePauserAdded, error) {
	event := new(PeggedTokenBridgePauserAdded)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgePauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserRemovedIterator struct {
	Event *PeggedTokenBridgePauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgePauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgePauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgePauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgePauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgePauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgePauserRemoved represents a PauserRemoved event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgePauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterPauserRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgePauserRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgePauserRemovedIterator{contract: _PeggedTokenBridge.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgePauserRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgePauserRemoved)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParsePauserRemoved(log types.Log) (*PeggedTokenBridgePauserRemoved, error) {
	event := new(PeggedTokenBridgePauserRemoved)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeUnpausedIterator struct {
	Event *PeggedTokenBridgeUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeUnpaused represents a Unpaused event raised by the PeggedTokenBridge contract.
type PeggedTokenBridgeUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) FilterUnpaused(opts *bind.FilterOpts) (*PeggedTokenBridgeUnpausedIterator, error) {

	logs, sub, err := _PeggedTokenBridge.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeUnpausedIterator{contract: _PeggedTokenBridge.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeUnpaused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridge.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeUnpaused)
				if err := _PeggedTokenBridge.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridge *PeggedTokenBridgeFilterer) ParseUnpaused(log types.Log) (*PeggedTokenBridgeUnpaused, error) {
	event := new(PeggedTokenBridgeUnpaused)
	if err := _PeggedTokenBridge.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
