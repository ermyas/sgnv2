// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package eth

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OriginalTokenVaultV2MetaData contains all meta data concerning the OriginalTokenVaultV2 contract.
var OriginalTokenVaultV2MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mintChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"depositNative\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeWrap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"setWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b50604051620037c2380380620037c2833981016040819052620000349162000255565b6001600055620000443362000079565b6001805460ff60a01b191690556200005c33620000cb565b620000673362000195565b6001600160a01b031660805262000287565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03811660009081526002602052604090205460ff16156200013a5760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526003602052604090205460ff1615620002005760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f720000000000604482015260640162000131565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b591016200018a565b6000602082840312156200026857600080fd5b81516001600160a01b03811681146200028057600080fd5b9392505050565b608051613518620002aa6000396000818161078201526117de01526135186000f3fe6080604052600436106102a35760003560e01c80636b2c0f551161016e578063adc0d57f116100cb578063e3eece261161007f578063eecdac8811610064578063eecdac8814610822578063f2fde38b14610842578063f83213831461086257600080fd5b8063e3eece26146107b9578063e43581b8146107e957600080fd5b8063b5f2bc47116100b0578063b5f2bc4714610743578063ccf2683b14610770578063e026049c146107a457600080fd5b8063adc0d57f146106b3578063b1c94d941461072d57600080fd5b80638456cb59116101225780639e25fc5c116101075780639e25fc5c146106535780639ff9001a14610673578063a21a92801461069357600080fd5b80638456cb59146106205780638da5cb5b1461063557600080fd5b8063715018a611610153578063715018a6146105bb57806380f51c12146105d057806382dc1ec41461060057600080fd5b80636b2c0f55146105865780636ef8d66d146105a657600080fd5b8063402d267d1161021c57806354eea796116101d05780635c975abb116101b55780635c975abb1461051a5780635ec2fa261461053957806360216b001461055957600080fd5b806354eea796146104e457806357d775f81461050457600080fd5b806346fbf68e1161020157806346fbf68e1461045e57806347b16c6c1461049757806352532faa146104b757600080fd5b8063402d267d146103f9578063457bfa2f1461042657600080fd5b8063303b6442116102735780633c4a25d0116102585780633c4a25d0146103a45780633d572107146103c45780633f4ba83a146103e457600080fd5b8063303b6442146103575780633c29f8391461037757600080fd5b8062a95fd7146102af57806301e64725146102d557806317bdbae514610315578063234636241461033757600080fd5b366102aa57005b600080fd5b6102c26102bd366004612f17565b61088f565b6040519081526020015b60405180910390f35b3480156102e157600080fd5b506103056102f0366004612f64565b600b6020526000908152604090205460ff1681565b60405190151581526020016102cc565b34801561032157600080fd5b50610335610330366004612fc9565b610af5565b005b34801561034357600080fd5b506102c2610352366004613035565b610c93565b34801561036357600080fd5b50610335610372366004612fc9565b610dde565b34801561038357600080fd5b506102c2610392366004613093565b600c6020526000908152604090205481565b3480156103b057600080fd5b506103356103bf366004613093565b610f75565b3480156103d057600080fd5b506103356103df366004612f64565b610fdb565b3480156103f057600080fd5b5061033561106f565b34801561040557600080fd5b506102c2610414366004613093565b600d6020526000908152604090205481565b34801561043257600080fd5b50600e54610446906001600160a01b031681565b6040516001600160a01b0390911681526020016102cc565b34801561046a57600080fd5b50610305610479366004613093565b6001600160a01b031660009081526002602052604090205460ff1690565b3480156104a357600080fd5b506103356104b2366004612fc9565b6110d8565b3480156104c357600080fd5b506102c26104d2366004613093565b60096020526000908152604090205481565b3480156104f057600080fd5b506103356104ff366004612f64565b61126f565b34801561051057600080fd5b506102c260045481565b34801561052657600080fd5b50600154600160a01b900460ff16610305565b34801561054557600080fd5b50610335610554366004612fc9565b6112fc565b34801561056557600080fd5b506102c2610574366004613093565b60056020526000908152604090205481565b34801561059257600080fd5b506103356105a1366004613093565b611493565b3480156105b257600080fd5b506103356114f6565b3480156105c757600080fd5b506103356114ff565b3480156105dc57600080fd5b506103056105eb366004613093565b60026020526000908152604090205460ff1681565b34801561060c57600080fd5b5061033561061b366004613093565b611563565b34801561062c57600080fd5b506103356115c6565b34801561064157600080fd5b506001546001600160a01b0316610446565b34801561065f57600080fd5b5061033561066e366004612f64565b61162d565b34801561067f57600080fd5b5061033561068e366004613093565b6116a2565b34801561069f57600080fd5b506102c26106ae3660046130ae565b61171e565b3480156106bf57600080fd5b506107026106ce366004612f64565b60086020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b0395861681529490931660208501529183015260608201526080016102cc565b34801561073957600080fd5b506102c2600a5481565b34801561074f57600080fd5b506102c261075e366004613093565b60066020526000908152604090205481565b34801561077c57600080fd5b506104467f000000000000000000000000000000000000000000000000000000000000000081565b3480156107b057600080fd5b50610335611ae8565b3480156107c557600080fd5b506103056107d4366004613093565b60036020526000908152604090205460ff1681565b3480156107f557600080fd5b50610305610804366004613093565b6001600160a01b031660009081526003602052604090205460ff1690565b34801561082e57600080fd5b5061033561083d366004613093565b611af1565b34801561084e57600080fd5b5061033561085d366004613093565b611b54565b34801561086e57600080fd5b506102c261087d366004613093565b60076020526000908152604090205481565b6000600260005414156108e95760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b6002600055600154600160a01b900460ff161561093b5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108e0565b84341461098a5760405162461bcd60e51b815260206004820152600f60248201527f416d6f756e74206d69736d61746368000000000000000000000000000000000060448201526064016108e0565b600e546001600160a01b03166109e25760405162461bcd60e51b815260206004820152601360248201527f4e61746976652077726170206e6f74207365740000000000000000000000000060448201526064016108e0565b600e546000906109fe906001600160a01b031687878787611c33565b9050600e60009054906101000a90046001600160a01b03166001600160a01b031663d0e30db0876040518263ffffffff1660e01b81526004016000604051808303818588803b158015610a5057600080fd5b505af1158015610a64573d6000803e3d6000fd5b5050600e54604080518681523360208201526001600160a01b0392831691810191909152606081018b905267ffffffffffffffff808b16608083015291891660a082015290871660c08201527f28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b935060e0019150610adf9050565b60405180910390a1600160005595945050505050565b3360009081526003602052604090205460ff16610b4d5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108e0565b828114610b8e5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108e0565b60005b83811015610c8c57828282818110610bab57610bab61319d565b9050602002013560096000878785818110610bc857610bc861319d565b9050602002016020810190610bdd9190613093565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce858583818110610c2a57610c2a61319d565b9050602002016020810190610c3f9190613093565b848484818110610c5157610c5161319d565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610c84816131c9565b915050610b91565b5050505050565b600060026000541415610ce85760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016108e0565b6002600055600154600160a01b900460ff1615610d3a5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108e0565b6000610d498787878787611c33565b9050610d606001600160a01b038816333089611e30565b604080518281523360208201526001600160a01b03898116828401526060820189905267ffffffffffffffff888116608084015290871660a0830152851660c082015290517f28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b9181900360e00190a160016000559695505050505050565b3360009081526003602052604090205460ff16610e365760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108e0565b828114610e775760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108e0565b60005b83811015610c8c57828282818110610e9457610e9461319d565b90506020020135600d6000878785818110610eb157610eb161319d565b9050602002016020810190610ec69190613093565b6001600160a01b031681526020810191909152604001600020557f0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72858583818110610f1357610f1361319d565b9050602002016020810190610f289190613093565b848484818110610f3a57610f3a61319d565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610f6d816131c9565b915050610e7a565b6001546001600160a01b03163314610fcf5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108e0565b610fd881611ece565b50565b3360009081526003602052604090205460ff166110335760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108e0565b600a8190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526002602052604090205460ff166110ce5760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108e0565b6110d6611f8b565b565b3360009081526003602052604090205460ff166111305760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108e0565b8281146111715760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108e0565b60005b83811015610c8c5782828281811061118e5761118e61319d565b90506020020135600660008787858181106111ab576111ab61319d565b90506020020160208101906111c09190613093565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e8985858381811061120d5761120d61319d565b90506020020160208101906112229190613093565b8484848181106112345761123461319d565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180611267816131c9565b915050611174565b3360009081526003602052604090205460ff166112c75760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108e0565b60048190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b390602001611064565b3360009081526003602052604090205460ff166113545760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108e0565b8281146113955760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108e0565b60005b83811015610c8c578282828181106113b2576113b261319d565b90506020020135600c60008787858181106113cf576113cf61319d565b90506020020160208101906113e49190613093565b6001600160a01b031681526020810191909152604001600020557f0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba68585838181106114315761143161319d565b90506020020160208101906114469190613093565b8484848181106114585761145861319d565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061148b816131c9565b915050611398565b6001546001600160a01b031633146114ed5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108e0565b610fd881612031565b6110d633612031565b6001546001600160a01b031633146115595760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108e0565b6110d660006120ea565b6001546001600160a01b031633146115bd5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108e0565b610fd88161213c565b3360009081526002602052604090205460ff166116255760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108e0565b6110d66121f9565b600154600160a01b900460ff161561167a5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108e0565b600061168582612281565b905061169e816000015182602001518360400151612446565b5050565b6001546001600160a01b031633146116fc5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108e0565b600e80546001600160a01b0319166001600160a01b0392909216919091179055565b600154600090600160a01b900460ff161561176e5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108e0565b600046306040516020016117c492919091825260601b6bffffffffffffffffffffffff191660208201527f57697468647261770000000000000000000000000000000000000000000000006034820152603c0190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828c8c604051602001611820939291906131e4565b6040516020818303038152906040528a8a8a8a8a8a6040518863ffffffff1660e01b81526004016118579796959493929190613315565b60006040518083038186803b15801561186f57600080fd5b505afa158015611883573d6000803e3d6000fd5b5050505060006118c88b8b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061257b92505050565b6020818101518251604080850151606080870151608088015160a089015185516bffffffffffffffffffffffff1998851b8916818b015296841b88166034880152604887019490945290821b8616606886015277ffffffffffffffffffffffffffffffffffffffffffffffff1960c09190911b16607c850152608484019190915230901b90921660a48201528151808203609801815260b890910182528051908301206000818152600b9093529120549192509060ff16156119bc5760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108e0565b6000818152600b602052604090819020805460ff191660011790558251908301516119e791906126dd565b81516001600160a01b03166000908152600960205260409020548015801590611a135750808360400151115b15611a3557611a30828460200151856000015186604001516127f5565b611a4c565b611a4c836020015184600001518560400151612446565b602080840151845160408087015160808089015160a0808b01516060808d015187518d81526001600160a01b039a8b169b81019b909b52978916968a01969096529488019390935267ffffffffffffffff16908601528401521660c08201527f296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb9060e00160405180910390a1509b9a5050505050505050505050565b6110d633612908565b6001546001600160a01b03163314611b4b5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108e0565b610fd881612908565b6001546001600160a01b03163314611bae5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108e0565b6001600160a01b038116611c2a5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016108e0565b610fd8816120ea565b6001600160a01b0385166000908152600c60205260408120548511611c9a5760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c0000000000000000000000000000000060448201526064016108e0565b6001600160a01b0386166000908152600d60205260409020541580611cd757506001600160a01b0386166000908152600d60205260409020548511155b611d235760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c617267650000000000000000000000000000000060448201526064016108e0565b6040516bffffffffffffffffffffffff1933606090811b8216602084015288811b821660348401526048830188905277ffffffffffffffffffffffffffffffffffffffffffffffff1960c088811b8216606886015287831b8416607086015286811b8216608486015246901b16608c84015230901b16609482015260009060a80160408051601f1981840301815291815281516020928301206000818152600b90935291205490915060ff1615611e0c5760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108e0565b6000818152600b60205260409020805460ff19166001179055905095945050505050565b6040516001600160a01b0380851660248301528316604482015260648101829052611ec89085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909316929092179091526129c1565b50505050565b6001600160a01b03811660009081526003602052604090205460ff1615611f375760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016108e0565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b59101611064565b600154600160a01b900460ff16611fe45760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f742070617573656400000000000000000000000060448201526064016108e0565b6001805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526002602052604090205460ff166120995760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f7420706175736572000000000000000000000060448201526064016108e0565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9101611064565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03811660009081526002602052604090205460ff16156121a55760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064016108e0565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89101611064565b600154600160a01b900460ff16156122465760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108e0565b6001805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586120143390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260086020908152604091829020825160808101845281546001600160a01b03908116825260018301541692810192909252600281015492820192909252600390910154606082018190526123405760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f7420657869737400000000000060448201526064016108e0565b600a54816060015161235291906133f5565b42116123a05760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b656400000060448201526064016108e0565b600083815260086020908152604080832080546001600160a01b03199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d44269361243893889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b600e546001600160a01b038381169116141561256257600e54604051632e1a7d4d60e01b8152600481018390526001600160a01b0390911690632e1a7d4d90602401600060405180830381600087803b1580156124a257600080fd5b505af11580156124b6573d6000803e3d6000fd5b505050506000836001600160a01b03168261c35090604051600060405180830381858888f193505050503d806000811461250c576040519150601f19603f3d011682016040523d82523d6000602084013e612511565b606091505b5050905080611ec85760405162461bcd60e51b815260206004820152601b60248201527f6661696c656420746f2073656e64206e617469766520746f6b656e000000000060448201526064016108e0565b6125766001600160a01b0383168483612aa6565b505050565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b602083015151835110156126d5576125d983612ad6565b90925090508160011415612608576125f86125f384612b10565b612bcd565b6001600160a01b031684526125c2565b81600214156126305761261d6125f384612b10565b6001600160a01b031660208501526125c2565b81600314156126545761264a61264584612b10565b612bde565b60408501526125c2565b816004141561267c576126696125f384612b10565b6001600160a01b031660608501526125c2565b81600514156126a25761268e83612c15565b67ffffffffffffffff1660808501526125c2565b81600614156126c6576126bc6126b784612b10565b612c97565b60a08501526125c2565b6126d08382612caf565b6125c2565b505050919050565b6004546126e8575050565b6001600160a01b0382166000908152600660205260409020548061270b57505050565b6001600160a01b03831660009081526005602052604081205460045490914291612735818461340d565b61273f919061342f565b6001600160a01b03871660009081526007602052604090205490915081111561276a57849250612777565b61277485846133f5565b92505b838311156127c75760405162461bcd60e51b815260206004820152601260248201527f766f6c756d65206578636565647320636170000000000000000000000000000060448201526064016108e0565b506001600160a01b039094166000908152600560209081526040808320939093556007905220929092555050565b600084815260086020526040902060030154156128545760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c7265616479206578697374730060448201526064016108e0565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b8152600890935291869020945185549085166001600160a01b031991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6906128fa9086815260200190565b60405180910390a150505050565b6001600160a01b03811660009081526003602052604090205460ff166129705760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f7200000000000000000060448201526064016108e0565b6001600160a01b038116600081815260036020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b9101611064565b6000612a16826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316612d219092919063ffffffff16565b8051909150156125765780806020019051810190612a34919061344e565b6125765760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016108e0565b6040516001600160a01b03831660248201526044810182905261257690849063a9059cbb60e01b90606401611e64565b6000806000612ae484612c15565b9050612af160088261340d565b9250806007166005811115612b0857612b08613470565b915050915091565b60606000612b1d83612c15565b90506000818460000151612b3191906133f5565b9050836020015151811115612b4557600080fd5b8167ffffffffffffffff811115612b5e57612b5e613486565b6040519080825280601f01601f191660200182016040528015612b88576020820181803683370190505b50602080860151865192955091818601919083010160005b85811015612bc2578181015183820152612bbb6020826133f5565b9050612ba0565b505050935250919050565b6000612bd882612d3a565b92915050565b6000602082511115612bef57600080fd5b6020820151905081516020612c04919061349c565b612c0f90600861342f565b1c919050565b602080820151825181019091015160009182805b600a811015612c915783811a9150612c4281600761342f565b82607f16901b851794508160801660001415612c7f57612c638160016133f5565b86518790612c729083906133f5565b9052509395945050505050565b80612c89816131c9565b915050612c29565b50600080fd5b60008151602014612ca757600080fd5b506020015190565b6000816005811115612cc357612cc3613470565b1415612cd25761257682612c15565b6002816005811115612ce657612ce6613470565b14156102aa576000612cf783612c15565b90508083600001818151612d0b91906133f5565b9052506020830151518351111561257657600080fd5b6060612d308484600085612d62565b90505b9392505050565b60008151601414612d4a57600080fd5b50602001516c01000000000000000000000000900490565b606082471015612dda5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016108e0565b6001600160a01b0385163b612e315760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016108e0565b600080866001600160a01b03168587604051612e4d91906134b3565b60006040518083038185875af1925050503d8060008114612e8a576040519150601f19603f3d011682016040523d82523d6000602084013e612e8f565b606091505b5091509150612e9f828286612eaa565b979650505050505050565b60608315612eb9575081612d33565b825115612ec95782518084602001fd5b8160405162461bcd60e51b81526004016108e091906134cf565b803567ffffffffffffffff81168114612efb57600080fd5b919050565b80356001600160a01b0381168114612efb57600080fd5b60008060008060808587031215612f2d57600080fd5b84359350612f3d60208601612ee3565b9250612f4b60408601612f00565b9150612f5960608601612ee3565b905092959194509250565b600060208284031215612f7657600080fd5b5035919050565b60008083601f840112612f8f57600080fd5b50813567ffffffffffffffff811115612fa757600080fd5b6020830191508360208260051b8501011115612fc257600080fd5b9250929050565b60008060008060408587031215612fdf57600080fd5b843567ffffffffffffffff80821115612ff757600080fd5b61300388838901612f7d565b9096509450602087013591508082111561301c57600080fd5b5061302987828801612f7d565b95989497509550505050565b600080600080600060a0868803121561304d57600080fd5b61305686612f00565b94506020860135935061306b60408701612ee3565b925061307960608701612f00565b915061308760808701612ee3565b90509295509295909350565b6000602082840312156130a557600080fd5b612d3382612f00565b6000806000806000806000806080898b0312156130ca57600080fd5b883567ffffffffffffffff808211156130e257600080fd5b818b0191508b601f8301126130f657600080fd5b81358181111561310557600080fd5b8c602082850101111561311757600080fd5b60209283019a509850908a0135908082111561313257600080fd5b61313e8c838d01612f7d565b909850965060408b013591508082111561315757600080fd5b6131638c838d01612f7d565b909650945060608b013591508082111561317c57600080fd5b506131898b828c01612f7d565b999c989b5096995094979396929594505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006000198214156131dd576131dd6131b3565b5060010190565b838152818360208301376000910160200190815292915050565b60005b83811015613219578181015183820152602001613201565b83811115611ec85750506000910152565b600081518084526132428160208601602086016131fe565b601f01601f19169290920160200192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8183526000602080850194508260005b858110156132bb576001600160a01b036132a883612f00565b168752958201959082019060010161328f565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8311156132f857600080fd5b8260051b8083602087013760009401602001938452509192915050565b608081526000613328608083018a61322a565b82810360208401528088825260208201905060208960051b8301018a60005b8b8110156133bb57848303601f190184528135368e9003601e1901811261336d57600080fd5b8d01803567ffffffffffffffff81111561338657600080fd5b8036038f131561339557600080fd5b6133a3858260208501613256565b60209687019690955093909301925050600101613347565b505084810360408601526133d081898b61327f565b9250505082810360608401526133e78185876132c6565b9a9950505050505050505050565b60008219821115613408576134086131b3565b500190565b60008261342a57634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615613449576134496131b3565b500290565b60006020828403121561346057600080fd5b81518015158114612d3357600080fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6000828210156134ae576134ae6131b3565b500390565b600082516134c58184602087016131fe565b9190910192915050565b602081526000612d33602083018461322a56fea26469706673582212202013c399b9bffd25e5ee77660d587512440a4b3074343c84c660eb267e6ac78564736f6c63430008090033",
}

// OriginalTokenVaultV2ABI is the input ABI used to generate the binding from.
// Deprecated: Use OriginalTokenVaultV2MetaData.ABI instead.
var OriginalTokenVaultV2ABI = OriginalTokenVaultV2MetaData.ABI

// OriginalTokenVaultV2Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OriginalTokenVaultV2MetaData.Bin instead.
var OriginalTokenVaultV2Bin = OriginalTokenVaultV2MetaData.Bin

// DeployOriginalTokenVaultV2 deploys a new Ethereum contract, binding an instance of OriginalTokenVaultV2 to it.
func DeployOriginalTokenVaultV2(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *OriginalTokenVaultV2, error) {
	parsed, err := OriginalTokenVaultV2MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OriginalTokenVaultV2Bin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &OriginalTokenVaultV2{OriginalTokenVaultV2Caller: OriginalTokenVaultV2Caller{contract: contract}, OriginalTokenVaultV2Transactor: OriginalTokenVaultV2Transactor{contract: contract}, OriginalTokenVaultV2Filterer: OriginalTokenVaultV2Filterer{contract: contract}}, nil
}

// OriginalTokenVaultV2 is an auto generated Go binding around an Ethereum contract.
type OriginalTokenVaultV2 struct {
	OriginalTokenVaultV2Caller     // Read-only binding to the contract
	OriginalTokenVaultV2Transactor // Write-only binding to the contract
	OriginalTokenVaultV2Filterer   // Log filterer for contract events
}

// OriginalTokenVaultV2Caller is an auto generated read-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultV2Transactor is an auto generated write-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultV2Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OriginalTokenVaultV2Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultV2Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OriginalTokenVaultV2Session struct {
	Contract     *OriginalTokenVaultV2 // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// OriginalTokenVaultV2CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OriginalTokenVaultV2CallerSession struct {
	Contract *OriginalTokenVaultV2Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// OriginalTokenVaultV2TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OriginalTokenVaultV2TransactorSession struct {
	Contract     *OriginalTokenVaultV2Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// OriginalTokenVaultV2Raw is an auto generated low-level Go binding around an Ethereum contract.
type OriginalTokenVaultV2Raw struct {
	Contract *OriginalTokenVaultV2 // Generic contract binding to access the raw methods on
}

// OriginalTokenVaultV2CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2CallerRaw struct {
	Contract *OriginalTokenVaultV2Caller // Generic read-only contract binding to access the raw methods on
}

// OriginalTokenVaultV2TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2TransactorRaw struct {
	Contract *OriginalTokenVaultV2Transactor // Generic write-only contract binding to access the raw methods on
}

// NewOriginalTokenVaultV2 creates a new instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2(address common.Address, backend bind.ContractBackend) (*OriginalTokenVaultV2, error) {
	contract, err := bindOriginalTokenVaultV2(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2{OriginalTokenVaultV2Caller: OriginalTokenVaultV2Caller{contract: contract}, OriginalTokenVaultV2Transactor: OriginalTokenVaultV2Transactor{contract: contract}, OriginalTokenVaultV2Filterer: OriginalTokenVaultV2Filterer{contract: contract}}, nil
}

// NewOriginalTokenVaultV2Caller creates a new read-only instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2Caller(address common.Address, caller bind.ContractCaller) (*OriginalTokenVaultV2Caller, error) {
	contract, err := bindOriginalTokenVaultV2(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2Caller{contract: contract}, nil
}

// NewOriginalTokenVaultV2Transactor creates a new write-only instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2Transactor(address common.Address, transactor bind.ContractTransactor) (*OriginalTokenVaultV2Transactor, error) {
	contract, err := bindOriginalTokenVaultV2(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2Transactor{contract: contract}, nil
}

// NewOriginalTokenVaultV2Filterer creates a new log filterer instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2Filterer(address common.Address, filterer bind.ContractFilterer) (*OriginalTokenVaultV2Filterer, error) {
	contract, err := bindOriginalTokenVaultV2(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2Filterer{contract: contract}, nil
}

// bindOriginalTokenVaultV2 binds a generic wrapper to an already deployed contract.
func bindOriginalTokenVaultV2(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OriginalTokenVaultV2ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVaultV2.Contract.OriginalTokenVaultV2Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.OriginalTokenVaultV2Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.OriginalTokenVaultV2Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVaultV2.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayPeriod(&_OriginalTokenVaultV2.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayPeriod(&_OriginalTokenVaultV2.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayThresholds(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayThresholds(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVaultV2.Contract.DelayedTransfers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVaultV2.Contract.DelayedTransfers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) EpochLength() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochLength(&_OriginalTokenVaultV2.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) EpochLength() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochLength(&_OriginalTokenVaultV2.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumeCaps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumeCaps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumes(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumes(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Governors(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Governors(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsGovernor(&_OriginalTokenVaultV2.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsGovernor(&_OriginalTokenVaultV2.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsPauser(&_OriginalTokenVaultV2.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsPauser(&_OriginalTokenVaultV2.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.LastOpTimestamps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.LastOpTimestamps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) MaxDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "maxDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MaxDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MaxDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) MinDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "minDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MinDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MinDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) NativeWrap(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "nativeWrap")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) NativeWrap() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.NativeWrap(&_OriginalTokenVaultV2.CallOpts)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) NativeWrap() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.NativeWrap(&_OriginalTokenVaultV2.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Owner() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.Owner(&_OriginalTokenVaultV2.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Owner() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.Owner(&_OriginalTokenVaultV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Paused() (bool, error) {
	return _OriginalTokenVaultV2.Contract.Paused(&_OriginalTokenVaultV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Paused() (bool, error) {
	return _OriginalTokenVaultV2.Contract.Paused(&_OriginalTokenVaultV2.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Pausers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Pausers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Records(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Records(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.SigsVerifier(&_OriginalTokenVaultV2.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.SigsVerifier(&_OriginalTokenVaultV2.CallOpts)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddPauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddPauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Deposit(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "deposit", _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Deposit(&_OriginalTokenVaultV2.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Deposit(&_OriginalTokenVaultV2.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) DepositNative(opts *bind.TransactOpts, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "depositNative", _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.DepositNative(&_OriginalTokenVaultV2.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.DepositNative(&_OriginalTokenVaultV2.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.ExecuteDelayedTransfer(&_OriginalTokenVaultV2.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.ExecuteDelayedTransfer(&_OriginalTokenVaultV2.TransactOpts, id)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Pause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Pause(&_OriginalTokenVaultV2.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Pause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Pause(&_OriginalTokenVaultV2.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemoveGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemoveGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemovePauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemovePauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenounceGovernor(&_OriginalTokenVaultV2.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenounceGovernor(&_OriginalTokenVaultV2.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RenounceOwnership() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenounceOwnership(&_OriginalTokenVaultV2.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenounceOwnership(&_OriginalTokenVaultV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenouncePauser(&_OriginalTokenVaultV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenouncePauser(&_OriginalTokenVaultV2.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayPeriod(&_OriginalTokenVaultV2.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayPeriod(&_OriginalTokenVaultV2.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayThresholds(&_OriginalTokenVaultV2.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayThresholds(&_OriginalTokenVaultV2.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochLength(&_OriginalTokenVaultV2.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochLength(&_OriginalTokenVaultV2.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochVolumeCaps(&_OriginalTokenVaultV2.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochVolumeCaps(&_OriginalTokenVaultV2.TransactOpts, _tokens, _caps)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetMaxDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setMaxDeposit", _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMaxDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMaxDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetMinDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setMinDeposit", _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMinDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMinDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetWrap(opts *bind.TransactOpts, _weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setWrap", _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetWrap(&_OriginalTokenVaultV2.TransactOpts, _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetWrap(&_OriginalTokenVaultV2.TransactOpts, _weth)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.TransferOwnership(&_OriginalTokenVaultV2.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.TransferOwnership(&_OriginalTokenVaultV2.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Unpause(&_OriginalTokenVaultV2.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Unpause(&_OriginalTokenVaultV2.TransactOpts)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Withdraw(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "withdraw", _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Withdraw(&_OriginalTokenVaultV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Withdraw(&_OriginalTokenVaultV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Receive() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Receive(&_OriginalTokenVaultV2.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Receive() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Receive(&_OriginalTokenVaultV2.TransactOpts)
}

// OriginalTokenVaultV2DelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayPeriodUpdatedIterator struct {
	Event *OriginalTokenVaultV2DelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayPeriodUpdated represents a DelayPeriodUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayPeriodUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayPeriodUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayPeriodUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayPeriodUpdated(log types.Log) (*OriginalTokenVaultV2DelayPeriodUpdated, error) {
	event := new(OriginalTokenVaultV2DelayPeriodUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayThresholdUpdatedIterator struct {
	Event *OriginalTokenVaultV2DelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayThresholdUpdated represents a DelayThresholdUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayThresholdUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayThresholdUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayThresholdUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayThresholdUpdated(log types.Log) (*OriginalTokenVaultV2DelayThresholdUpdated, error) {
	event := new(OriginalTokenVaultV2DelayThresholdUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferAddedIterator struct {
	Event *OriginalTokenVaultV2DelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayedTransferAdded represents a DelayedTransferAdded event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayedTransferAddedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayedTransferAddedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayedTransferAdded)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayedTransferAdded(log types.Log) (*OriginalTokenVaultV2DelayedTransferAdded, error) {
	event := new(OriginalTokenVaultV2DelayedTransferAdded)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferExecutedIterator struct {
	Event *OriginalTokenVaultV2DelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayedTransferExecuted represents a DelayedTransferExecuted event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayedTransferExecutedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayedTransferExecutedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayedTransferExecuted)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayedTransferExecuted(log types.Log) (*OriginalTokenVaultV2DelayedTransferExecuted, error) {
	event := new(OriginalTokenVaultV2DelayedTransferExecuted)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DepositedIterator is returned from FilterDeposited and is used to iterate over the raw logs and unpacked data for Deposited events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DepositedIterator struct {
	Event *OriginalTokenVaultV2Deposited // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DepositedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Deposited)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Deposited)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DepositedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DepositedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Deposited represents a Deposited event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Deposited struct {
	DepositId   [32]byte
	Depositor   common.Address
	Token       common.Address
	Amount      *big.Int
	MintChainId uint64
	MintAccount common.Address
	Nonce       uint64
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDeposited is a free log retrieval operation binding the contract event 0x28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount, uint64 nonce)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDeposited(opts *bind.FilterOpts) (*OriginalTokenVaultV2DepositedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DepositedIterator{contract: _OriginalTokenVaultV2.contract, event: "Deposited", logs: logs, sub: sub}, nil
}

// WatchDeposited is a free log subscription operation binding the contract event 0x28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount, uint64 nonce)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDeposited(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Deposited) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Deposited)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Deposited", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposited is a log parse operation binding the contract event 0x28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount, uint64 nonce)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDeposited(log types.Log) (*OriginalTokenVaultV2Deposited, error) {
	event := new(OriginalTokenVaultV2Deposited)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Deposited", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2EpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochLengthUpdatedIterator struct {
	Event *OriginalTokenVaultV2EpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2EpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2EpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2EpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2EpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2EpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2EpochLengthUpdated represents a EpochLengthUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2EpochLengthUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2EpochLengthUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2EpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2EpochLengthUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseEpochLengthUpdated(log types.Log) (*OriginalTokenVaultV2EpochLengthUpdated, error) {
	event := new(OriginalTokenVaultV2EpochLengthUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2EpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochVolumeUpdatedIterator struct {
	Event *OriginalTokenVaultV2EpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2EpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2EpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2EpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2EpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2EpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2EpochVolumeUpdated represents a EpochVolumeUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2EpochVolumeUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2EpochVolumeUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2EpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2EpochVolumeUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseEpochVolumeUpdated(log types.Log) (*OriginalTokenVaultV2EpochVolumeUpdated, error) {
	event := new(OriginalTokenVaultV2EpochVolumeUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2GovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorAddedIterator struct {
	Event *OriginalTokenVaultV2GovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2GovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2GovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2GovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2GovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2GovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2GovernorAdded represents a GovernorAdded event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterGovernorAdded(opts *bind.FilterOpts) (*OriginalTokenVaultV2GovernorAddedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2GovernorAddedIterator{contract: _OriginalTokenVaultV2.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2GovernorAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2GovernorAdded)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseGovernorAdded(log types.Log) (*OriginalTokenVaultV2GovernorAdded, error) {
	event := new(OriginalTokenVaultV2GovernorAdded)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2GovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorRemovedIterator struct {
	Event *OriginalTokenVaultV2GovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2GovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2GovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2GovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2GovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2GovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2GovernorRemoved represents a GovernorRemoved event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultV2GovernorRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2GovernorRemovedIterator{contract: _OriginalTokenVaultV2.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2GovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2GovernorRemoved)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseGovernorRemoved(log types.Log) (*OriginalTokenVaultV2GovernorRemoved, error) {
	event := new(OriginalTokenVaultV2GovernorRemoved)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2MaxDepositUpdatedIterator is returned from FilterMaxDepositUpdated and is used to iterate over the raw logs and unpacked data for MaxDepositUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MaxDepositUpdatedIterator struct {
	Event *OriginalTokenVaultV2MaxDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2MaxDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2MaxDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2MaxDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2MaxDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2MaxDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2MaxDepositUpdated represents a MaxDepositUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MaxDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxDepositUpdated is a free log retrieval operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterMaxDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2MaxDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2MaxDepositUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "MaxDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxDepositUpdated is a free log subscription operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchMaxDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2MaxDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2MaxDepositUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxDepositUpdated is a log parse operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseMaxDepositUpdated(log types.Log) (*OriginalTokenVaultV2MaxDepositUpdated, error) {
	event := new(OriginalTokenVaultV2MaxDepositUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2MinDepositUpdatedIterator is returned from FilterMinDepositUpdated and is used to iterate over the raw logs and unpacked data for MinDepositUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MinDepositUpdatedIterator struct {
	Event *OriginalTokenVaultV2MinDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2MinDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2MinDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2MinDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2MinDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2MinDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2MinDepositUpdated represents a MinDepositUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MinDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinDepositUpdated is a free log retrieval operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterMinDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2MinDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2MinDepositUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "MinDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMinDepositUpdated is a free log subscription operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchMinDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2MinDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2MinDepositUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinDepositUpdated is a log parse operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseMinDepositUpdated(log types.Log) (*OriginalTokenVaultV2MinDepositUpdated, error) {
	event := new(OriginalTokenVaultV2MinDepositUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2OwnershipTransferredIterator struct {
	Event *OriginalTokenVaultV2OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2OwnershipTransferred represents a OwnershipTransferred event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OriginalTokenVaultV2OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2OwnershipTransferredIterator{contract: _OriginalTokenVaultV2.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2OwnershipTransferred)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseOwnershipTransferred(log types.Log) (*OriginalTokenVaultV2OwnershipTransferred, error) {
	event := new(OriginalTokenVaultV2OwnershipTransferred)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2PausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PausedIterator struct {
	Event *OriginalTokenVaultV2Paused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2PausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Paused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Paused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2PausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2PausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Paused represents a Paused event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Paused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterPaused(opts *bind.FilterOpts) (*OriginalTokenVaultV2PausedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2PausedIterator{contract: _OriginalTokenVaultV2.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Paused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Paused)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParsePaused(log types.Log) (*OriginalTokenVaultV2Paused, error) {
	event := new(OriginalTokenVaultV2Paused)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2PauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserAddedIterator struct {
	Event *OriginalTokenVaultV2PauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2PauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2PauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2PauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2PauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2PauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2PauserAdded represents a PauserAdded event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterPauserAdded(opts *bind.FilterOpts) (*OriginalTokenVaultV2PauserAddedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2PauserAddedIterator{contract: _OriginalTokenVaultV2.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2PauserAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2PauserAdded)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParsePauserAdded(log types.Log) (*OriginalTokenVaultV2PauserAdded, error) {
	event := new(OriginalTokenVaultV2PauserAdded)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2PauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserRemovedIterator struct {
	Event *OriginalTokenVaultV2PauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2PauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2PauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2PauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2PauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2PauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2PauserRemoved represents a PauserRemoved event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterPauserRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultV2PauserRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2PauserRemovedIterator{contract: _OriginalTokenVaultV2.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2PauserRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2PauserRemoved)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParsePauserRemoved(log types.Log) (*OriginalTokenVaultV2PauserRemoved, error) {
	event := new(OriginalTokenVaultV2PauserRemoved)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2UnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2UnpausedIterator struct {
	Event *OriginalTokenVaultV2Unpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2UnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Unpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Unpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2UnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2UnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Unpaused represents a Unpaused event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Unpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterUnpaused(opts *bind.FilterOpts) (*OriginalTokenVaultV2UnpausedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2UnpausedIterator{contract: _OriginalTokenVaultV2.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Unpaused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Unpaused)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseUnpaused(log types.Log) (*OriginalTokenVaultV2Unpaused, error) {
	event := new(OriginalTokenVaultV2Unpaused)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2WithdrawnIterator is returned from FilterWithdrawn and is used to iterate over the raw logs and unpacked data for Withdrawn events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2WithdrawnIterator struct {
	Event *OriginalTokenVaultV2Withdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2WithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Withdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Withdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2WithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2WithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Withdrawn represents a Withdrawn event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Withdrawn struct {
	WithdrawId  [32]byte
	Receiver    common.Address
	Token       common.Address
	Amount      *big.Int
	RefChainId  uint64
	RefId       [32]byte
	BurnAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawn is a free log retrieval operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterWithdrawn(opts *bind.FilterOpts) (*OriginalTokenVaultV2WithdrawnIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2WithdrawnIterator{contract: _OriginalTokenVaultV2.contract, event: "Withdrawn", logs: logs, sub: sub}, nil
}

// WatchWithdrawn is a free log subscription operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchWithdrawn(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Withdrawn) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Withdrawn)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Withdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawn is a log parse operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseWithdrawn(log types.Log) (*OriginalTokenVaultV2Withdrawn, error) {
	event := new(OriginalTokenVaultV2Withdrawn)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Withdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MetaData contains all meta data concerning the PeggedTokenBridgeV2 contract.
var PeggedTokenBridgeV2MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"burnId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mintId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"SupplyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_toChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_toAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_toChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_toAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"decreaseSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"increaseSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"name\":\"setSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b506040516200318f3803806200318f83398101604081905262000034916200024f565b6200003f3362000074565b6000805460ff60a01b191690556200005733620000c4565b62000062336200018f565b6001600160a01b031660805262000281565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b03811660009081526001602052604090205460ff1615620001335760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526002602052604090205460ff1615620001fa5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016200012a565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5910162000184565b6000602082840312156200026257600080fd5b81516001600160a01b03811681146200027a57600080fd5b9392505050565b608051612eeb620002a46000396000818161061401526114d80152612eeb6000f3fe608060405234801561001057600080fd5b50600436106102d35760003560e01c806380f51c1211610186578063b5f2bc47116100e3578063e43581b811610097578063f832138311610071578063f8321383146106b3578063f8734302146106d3578063f9a8ea08146106e657600080fd5b8063e43581b814610661578063eecdac881461068d578063f2fde38b146106a057600080fd5b8063ccf2683b116100c8578063ccf2683b1461060f578063e026049c14610636578063e3eece261461063e57600080fd5b8063b5f2bc47146105dc578063bf4816f0146105fc57600080fd5b80639e422c331161013a578063adc0d57f1161011f578063adc0d57f14610553578063b1c94d94146105c0578063b4d8cedc146105c957600080fd5b80639e422c331461052d578063a00293011461054057600080fd5b80638456cb591161016b5780638456cb59146104ed5780638da5cb5b146104f55780639e25fc5c1461051a57600080fd5b806380f51c12146104b757806382dc1ec4146104da57600080fd5b806352532faa116102345780636b2c0f55116101e8578063715018a6116101cd578063715018a61461047c57806379fcd8ee146104845780637f8560131461049757600080fd5b80636b2c0f55146104615780636ef8d66d1461047457600080fd5b806357d775f81161021957806357d775f8146104265780635c975abb1461042f57806360216b001461044157600080fd5b806352532faa146103f357806354eea7961461041357600080fd5b80633d5721071161028b57806346fbf68e1161027057806346fbf68e1461039457806347b16c6c146103c0578063497bf3b2146103d357600080fd5b80633d572107146103795780633f4ba83a1461038c57600080fd5b806317bdbae5116102bc57806317bdbae514610325578063274cee31146103385780633c4a25d01461036657600080fd5b806301e64725146102d857806315d0975c14610310575b600080fd5b6102fb6102e6366004612911565b600a6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b61032361031e366004612946565b6106f9565b005b6103236103333660046129bc565b6107c9565b610358610346366004612a28565b600b6020526000908152604090205481565b604051908152602001610307565b610323610374366004612a28565b610967565b610323610387366004612911565b6109bb565b610323610a4f565b6102fb6103a2366004612a28565b6001600160a01b031660009081526001602052604090205460ff1690565b6103236103ce3660046129bc565b610ab8565b6103586103e1366004612a28565b600d6020526000908152604090205481565b610358610401366004612a28565b60086020526000908152604090205481565b610323610421366004612911565b610c4f565b61035860035481565b600054600160a01b900460ff166102fb565b61035861044f366004612a28565b60046020526000908152604090205481565b61032361046f366004612a28565b610cdc565b610323610d2d565b610323610d36565b610323610492366004612946565b610d88565b6103586104a5366004612a28565b600c6020526000908152604090205481565b6102fb6104c5366004612a28565b60016020526000908152604090205460ff1681565b6103236104e8366004612a28565b610df8565b610323610e49565b6000546001600160a01b03165b6040516001600160a01b039091168152602001610307565b610323610528366004612911565b610eb0565b61035861053b366004612a62565b610f7d565b61035861054e366004612a62565b611049565b610595610561366004612911565b60076020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b039586168152949093166020850152918301526060820152608001610307565b61035860095481565b6103236105d7366004612946565b6110dc565b6103586105ea366004612a28565b60056020526000908152604090205481565b61032361060a3660046129bc565b611175565b6105027f000000000000000000000000000000000000000000000000000000000000000081565b61032361130c565b6102fb61064c366004612a28565b60026020526000908152604090205460ff1681565b6102fb61066f366004612a28565b6001600160a01b031660009081526002602052604090205460ff1690565b61032361069b366004612a28565b611315565b6103236106ae366004612a28565b611366565b6103586106c1366004612a28565b60066020526000908152604090205481565b6103586106e1366004612ac0565b611433565b6103236106f43660046129bc565b61187e565b6000546001600160a01b031633146107465760405162461bcd60e51b81526020600482018190526024820152600080516020612e9683398151915260448201526064015b60405180910390fd5b6001600160a01b0382166000908152600b60205260408120805483929061076e908490612bc5565b90915550506001600160a01b0382166000818152600b6020908152604091829020548251938452908301527feb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e949991015b60405180910390a15050565b3360009081526002602052604090205460ff166108215760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161073d565b8281146108625760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161073d565b60005b838110156109605782828281811061087f5761087f612bdc565b905060200201356008600087878581811061089c5761089c612bdc565b90506020020160208101906108b19190612a28565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce8585838181106108fe576108fe612bdc565b90506020020160208101906109139190612a28565b84848481811061092557610925612bdc565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061095881612bf2565b915050610865565b5050505050565b6000546001600160a01b031633146109af5760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b6109b881611a15565b50565b3360009081526002602052604090205460ff16610a135760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161073d565b60098190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526001602052604090205460ff16610aae5760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f7420706175736572000000000000000000000000604482015260640161073d565b610ab6611ad2565b565b3360009081526002602052604090205460ff16610b105760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161073d565b828114610b515760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161073d565b60005b8381101561096057828282818110610b6e57610b6e612bdc565b9050602002013560056000878785818110610b8b57610b8b612bdc565b9050602002016020810190610ba09190612a28565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89858583818110610bed57610bed612bdc565b9050602002016020810190610c029190612a28565b848484818110610c1457610c14612bdc565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610c4781612bf2565b915050610b54565b3360009081526002602052604090205460ff16610ca75760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161073d565b60038190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b390602001610a44565b6000546001600160a01b03163314610d245760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b6109b881611b78565b610ab633611b78565b6000546001600160a01b03163314610d7e5760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b610ab66000611c31565b6000546001600160a01b03163314610dd05760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b6001600160a01b0382166000908152600b60205260408120805483929061076e908490612c0d565b6000546001600160a01b03163314610e405760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b6109b881611c8e565b3360009081526001602052604090205460ff16610ea85760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f7420706175736572000000000000000000000000604482015260640161073d565b610ab6611d4c565b600054600160a01b900460ff1615610efd5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161073d565b6000610f0882611dd4565b6020810151815160408084015190516340c10f1960e01b81526001600160a01b039283166004820152602481019190915292935016906340c10f1990604401600060405180830381600087803b158015610f6157600080fd5b505af1158015610f75573d6000803e3d6000fd5b505050505050565b60008054600160a01b900460ff1615610fcb5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161073d565b6000610fda8787878787611fa6565b60405163079cc67960e41b8152336004820152602481018890529091506001600160a01b038816906379cc6790906044015b600060405180830381600087803b15801561102657600080fd5b505af115801561103a573d6000803e3d6000fd5b50929998505050505050505050565b60008054600160a01b900460ff16156110975760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161073d565b60006110a68787878787611fa6565b604051632770a7eb60e21b8152336004820152602481018890529091506001600160a01b03881690639dc29fac9060440161100c565b6000546001600160a01b031633146111245760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b6001600160a01b0382166000818152600b6020908152604091829020849055815192835282018390527feb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e949991016107bd565b3360009081526002602052604090205460ff166111cd5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161073d565b82811461120e5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161073d565b60005b838110156109605782828281811061122b5761122b612bdc565b90506020020135600c600087878581811061124857611248612bdc565b905060200201602081019061125d9190612a28565b6001600160a01b031681526020810191909152604001600020557f3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d066838585838181106112aa576112aa612bdc565b90506020020160208101906112bf9190612a28565b8484848181106112d1576112d1612bdc565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061130481612bf2565b915050611211565b610ab633612246565b6000546001600160a01b0316331461135d5760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b6109b881612246565b6000546001600160a01b031633146113ae5760405162461bcd60e51b81526020600482018190526024820152600080516020612e96833981519152604482015260640161073d565b6001600160a01b03811661142a5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161073d565b6109b881611c31565b60008054600160a01b900460ff16156114815760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161073d565b600046306040516020016114be92919091825260601b6bffffffffffffffffffffffff1916602082015263135a5b9d60e21b603482015260380190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828c8c60405160200161151a93929190612c25565b6040516020818303038152906040528a8a8a8a8a8a6040518863ffffffff1660e01b81526004016115519796959493929190612d8c565b60006040518083038186803b15801561156957600080fd5b505afa15801561157d573d6000803e3d6000fd5b5050505060006115c28b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506122ff92505050565b6020818101518251604080850151606080870151608088015160a089015185516bffffffffffffffffffffffff1998851b8916818b015296841b88166034880152604887019490945290821b8616606886015277ffffffffffffffffffffffffffffffffffffffffffffffff1960c09190911b16607c850152608484019190915230901b90921660a48201528151808203609801815260b890910182528051908301206000818152600a9093529120549192509060ff16156116b65760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b604482015260640161073d565b6000818152600a602052604090819020805460ff191660011790558251908301516116e19190612461565b81516001600160a01b0316600090815260086020526040902054801580159061170d5750808360400151115b1561172f5761172a82846020015185600001518660400151612579565b61179f565b8251602084015160408086015190516340c10f1960e01b81526001600160a01b03928316600482015260248101919091529116906340c10f1990604401600060405180830381600087803b15801561178657600080fd5b505af115801561179a573d6000803e3d6000fd5b505050505b60408084015184516001600160a01b03166000908152600b6020529182208054919290916117ce908490612c0d565b925050819055507f5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a8284600001518560200151866040015187608001518860a00151896060015160405161186697969594939291909687526001600160a01b0395861660208801529385166040870152606086019290925267ffffffffffffffff16608085015260a08401521660c082015260e00190565b60405180910390a1509b9a5050505050505050505050565b3360009081526002602052604090205460ff166118d65760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161073d565b8281146119175760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161073d565b60005b838110156109605782828281811061193457611934612bdc565b90506020020135600d600087878581811061195157611951612bdc565b90506020020160208101906119669190612a28565b6001600160a01b031681526020810191909152604001600020557fa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da58585838181106119b3576119b3612bdc565b90506020020160208101906119c89190612a28565b8484848181106119da576119da612bdc565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180611a0d81612bf2565b91505061191a565b6001600160a01b03811660009081526002602052604090205460ff1615611a7e5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f720000000000604482015260640161073d565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b59101610a44565b600054600160a01b900460ff16611b2b5760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f7420706175736564000000000000000000000000604482015260640161073d565b6000805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526001602052604090205460ff16611be05760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f74207061757365720000000000000000000000604482015260640161073d565b6001600160a01b038116600081815260016020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9101610a44565b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b03811660009081526001602052604090205460ff1615611cf75760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c72656164792070617573657200000000000000604482015260640161073d565b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89101610a44565b600054600160a01b900460ff1615611d995760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161073d565b6000805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611b5b3390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260076020908152604091829020825160808101845281546001600160a01b0390811682526001830154169281019290925260028101549282019290925260039091015460608201819052611e935760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f74206578697374000000000000604482015260640161073d565b6009548160600151611ea59190612c0d565b4211611ef35760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b6564000000604482015260640161073d565b6000838152600760209081526040808320805473ffffffffffffffffffffffffffffffffffffffff199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d442693611f9893889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b6001600160a01b0385166000908152600c6020526040812054851161200d5760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c00000000000000000000000000000000604482015260640161073d565b6001600160a01b0386166000908152600d6020526040902054158061204a57506001600160a01b0386166000908152600d60205260409020548511155b6120965760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c6172676500000000000000000000000000000000604482015260640161073d565b6001600160a01b0386166000908152600b6020526040812080548792906120be908490612bc5565b90915550506040516bffffffffffffffffffffffff1933606090811b8216602084015288811b821660348401526048830188905277ffffffffffffffffffffffffffffffffffffffffffffffff1960c088811b8216606886015287831b8416607086015286811b8216608486015246901b16608c84015230901b16609482015260009060a80160408051601f1981840301815291815281516020928301206000818152600a90935291205490915060ff16156121ac5760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b604482015260640161073d565b6000818152600a6020908152604091829020805460ff1916600117905581518381526001600160a01b038a81169282019290925233928101929092526060820188905267ffffffffffffffff878116608084015290861660a0830152841660c08201527f6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a39060e00160405180910390a19695505050505050565b6001600160a01b03811660009081526002602052604090205460ff166122ae5760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f72000000000000000000604482015260640161073d565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b9101610a44565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b602083015151835110156124595761235d83612699565b9092509050816001141561238c5761237c612377846126d3565b612790565b6001600160a01b03168452612346565b81600214156123b4576123a1612377846126d3565b6001600160a01b03166020850152612346565b81600314156123d8576123ce6123c9846126d3565b6127a1565b6040850152612346565b8160041415612400576123ed612377846126d3565b6001600160a01b03166060850152612346565b816005141561242657612412836127d8565b67ffffffffffffffff166080850152612346565b816006141561244a5761244061243b846126d3565b61285a565b60a0850152612346565b6124548382612872565b612346565b505050919050565b60035461246c575050565b6001600160a01b0382166000908152600560205260409020548061248f57505050565b6001600160a01b038316600090815260046020526040812054600354909142916124b98184612e28565b6124c39190612e4a565b6001600160a01b0387166000908152600660205260409020549091508111156124ee578492506124fb565b6124f88584612c0d565b92505b8383111561254b5760405162461bcd60e51b815260206004820152601260248201527f766f6c756d652065786365656473206361700000000000000000000000000000604482015260640161073d565b506001600160a01b039094166000908152600460209081526040808320939093556006905220929092555050565b600084815260076020526040902060030154156125d85760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c72656164792065786973747300604482015260640161073d565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b81526007909352918690209451855490851673ffffffffffffffffffffffffffffffffffffffff1991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce69061268b9086815260200190565b60405180910390a150505050565b60008060006126a7846127d8565b90506126b4600882612e28565b92508060071660058111156126cb576126cb612e69565b915050915091565b606060006126e0836127d8565b905060008184600001516126f49190612c0d565b905083602001515181111561270857600080fd5b8167ffffffffffffffff81111561272157612721612e7f565b6040519080825280601f01601f19166020018201604052801561274b576020820181803683370190505b50602080860151865192955091818601919083010160005b8581101561278557818101518382015261277e602082612c0d565b9050612763565b505050935250919050565b600061279b826128e9565b92915050565b60006020825111156127b257600080fd5b60208201519050815160206127c79190612bc5565b6127d2906008612e4a565b1c919050565b602080820151825181019091015160009182805b600a8110156128545783811a9150612805816007612e4a565b82607f16901b85179450816080166000141561284257612826816001612c0d565b86518790612835908390612c0d565b9052509395945050505050565b8061284c81612bf2565b9150506127ec565b50600080fd5b6000815160201461286a57600080fd5b506020015190565b600081600581111561288657612886612e69565b141561289a57612895826127d8565b505050565b60028160058111156128ae576128ae612e69565b14156102d35760006128bf836127d8565b905080836000018181516128d39190612c0d565b9052506020830151518351111561289557600080fd5b600081516014146128f957600080fd5b50602001516c01000000000000000000000000900490565b60006020828403121561292357600080fd5b5035919050565b80356001600160a01b038116811461294157600080fd5b919050565b6000806040838503121561295957600080fd5b6129628361292a565b946020939093013593505050565b60008083601f84011261298257600080fd5b50813567ffffffffffffffff81111561299a57600080fd5b6020830191508360208260051b85010111156129b557600080fd5b9250929050565b600080600080604085870312156129d257600080fd5b843567ffffffffffffffff808211156129ea57600080fd5b6129f688838901612970565b90965094506020870135915080821115612a0f57600080fd5b50612a1c87828801612970565b95989497509550505050565b600060208284031215612a3a57600080fd5b612a438261292a565b9392505050565b803567ffffffffffffffff8116811461294157600080fd5b600080600080600060a08688031215612a7a57600080fd5b612a838661292a565b945060208601359350612a9860408701612a4a565b9250612aa66060870161292a565b9150612ab460808701612a4a565b90509295509295909350565b6000806000806000806000806080898b031215612adc57600080fd5b883567ffffffffffffffff80821115612af457600080fd5b818b0191508b601f830112612b0857600080fd5b813581811115612b1757600080fd5b8c6020828501011115612b2957600080fd5b60209283019a509850908a01359080821115612b4457600080fd5b612b508c838d01612970565b909850965060408b0135915080821115612b6957600080fd5b612b758c838d01612970565b909650945060608b0135915080821115612b8e57600080fd5b50612b9b8b828c01612970565b999c989b5096995094979396929594505050565b634e487b7160e01b600052601160045260246000fd5b600082821015612bd757612bd7612baf565b500390565b634e487b7160e01b600052603260045260246000fd5b6000600019821415612c0657612c06612baf565b5060010190565b60008219821115612c2057612c20612baf565b500190565b838152818360208301376000910160200190815292915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b818352600060208085019450848460051b86018460005b87811015612ce95783830389528135601e19883603018112612ca057600080fd5b8701803567ffffffffffffffff811115612cb957600080fd5b803603891315612cc857600080fd5b612cd58582898501612c3f565b9a87019a9450505090840190600101612c7f565b5090979650505050505050565b8183526000602080850194508260005b85811015612d32576001600160a01b03612d1f8361292a565b1687529582019590820190600101612d06565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115612d6f57600080fd5b8260051b8083602087013760009401602001938452509192915050565b608081526000885180608084015260005b81811015612dba576020818c0181015160a0868401015201612d9d565b81811115612dcc57600060a083860101525b50601f01601f1916820182810360a09081016020850152612df0908201898b612c68565b90508281036040840152612e05818789612cf6565b90508281036060840152612e1a818587612d3d565b9a9950505050505050505050565b600082612e4557634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615612e6457612e64612baf565b500290565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fdfe4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572a2646970667358221220586676af0401c5af9b78a639c4629d81247376244055c827a67d4a63f350ad0564736f6c63430008090033",
}

// PeggedTokenBridgeV2ABI is the input ABI used to generate the binding from.
// Deprecated: Use PeggedTokenBridgeV2MetaData.ABI instead.
var PeggedTokenBridgeV2ABI = PeggedTokenBridgeV2MetaData.ABI

// PeggedTokenBridgeV2Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PeggedTokenBridgeV2MetaData.Bin instead.
var PeggedTokenBridgeV2Bin = PeggedTokenBridgeV2MetaData.Bin

// DeployPeggedTokenBridgeV2 deploys a new Ethereum contract, binding an instance of PeggedTokenBridgeV2 to it.
func DeployPeggedTokenBridgeV2(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *PeggedTokenBridgeV2, error) {
	parsed, err := PeggedTokenBridgeV2MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PeggedTokenBridgeV2Bin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PeggedTokenBridgeV2{PeggedTokenBridgeV2Caller: PeggedTokenBridgeV2Caller{contract: contract}, PeggedTokenBridgeV2Transactor: PeggedTokenBridgeV2Transactor{contract: contract}, PeggedTokenBridgeV2Filterer: PeggedTokenBridgeV2Filterer{contract: contract}}, nil
}

// PeggedTokenBridgeV2 is an auto generated Go binding around an Ethereum contract.
type PeggedTokenBridgeV2 struct {
	PeggedTokenBridgeV2Caller     // Read-only binding to the contract
	PeggedTokenBridgeV2Transactor // Write-only binding to the contract
	PeggedTokenBridgeV2Filterer   // Log filterer for contract events
}

// PeggedTokenBridgeV2Caller is an auto generated read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeV2Transactor is an auto generated write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeV2Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PeggedTokenBridgeV2Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeV2Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PeggedTokenBridgeV2Session struct {
	Contract     *PeggedTokenBridgeV2 // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeV2CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PeggedTokenBridgeV2CallerSession struct {
	Contract *PeggedTokenBridgeV2Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// PeggedTokenBridgeV2TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PeggedTokenBridgeV2TransactorSession struct {
	Contract     *PeggedTokenBridgeV2Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeV2Raw is an auto generated low-level Go binding around an Ethereum contract.
type PeggedTokenBridgeV2Raw struct {
	Contract *PeggedTokenBridgeV2 // Generic contract binding to access the raw methods on
}

// PeggedTokenBridgeV2CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2CallerRaw struct {
	Contract *PeggedTokenBridgeV2Caller // Generic read-only contract binding to access the raw methods on
}

// PeggedTokenBridgeV2TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2TransactorRaw struct {
	Contract *PeggedTokenBridgeV2Transactor // Generic write-only contract binding to access the raw methods on
}

// NewPeggedTokenBridgeV2 creates a new instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2(address common.Address, backend bind.ContractBackend) (*PeggedTokenBridgeV2, error) {
	contract, err := bindPeggedTokenBridgeV2(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2{PeggedTokenBridgeV2Caller: PeggedTokenBridgeV2Caller{contract: contract}, PeggedTokenBridgeV2Transactor: PeggedTokenBridgeV2Transactor{contract: contract}, PeggedTokenBridgeV2Filterer: PeggedTokenBridgeV2Filterer{contract: contract}}, nil
}

// NewPeggedTokenBridgeV2Caller creates a new read-only instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2Caller(address common.Address, caller bind.ContractCaller) (*PeggedTokenBridgeV2Caller, error) {
	contract, err := bindPeggedTokenBridgeV2(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2Caller{contract: contract}, nil
}

// NewPeggedTokenBridgeV2Transactor creates a new write-only instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2Transactor(address common.Address, transactor bind.ContractTransactor) (*PeggedTokenBridgeV2Transactor, error) {
	contract, err := bindPeggedTokenBridgeV2(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2Transactor{contract: contract}, nil
}

// NewPeggedTokenBridgeV2Filterer creates a new log filterer instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2Filterer(address common.Address, filterer bind.ContractFilterer) (*PeggedTokenBridgeV2Filterer, error) {
	contract, err := bindPeggedTokenBridgeV2(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2Filterer{contract: contract}, nil
}

// bindPeggedTokenBridgeV2 binds a generic wrapper to an already deployed contract.
func bindPeggedTokenBridgeV2(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PeggedTokenBridgeV2ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridgeV2.Contract.PeggedTokenBridgeV2Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.PeggedTokenBridgeV2Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.PeggedTokenBridgeV2Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridgeV2.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayPeriod(&_PeggedTokenBridgeV2.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayPeriod(&_PeggedTokenBridgeV2.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayThresholds(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayThresholds(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridgeV2.Contract.DelayedTransfers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridgeV2.Contract.DelayedTransfers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochLength(&_PeggedTokenBridgeV2.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochLength(&_PeggedTokenBridgeV2.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumeCaps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumeCaps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumes(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumes(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Governors(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Governors(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsGovernor(&_PeggedTokenBridgeV2.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsGovernor(&_PeggedTokenBridgeV2.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsPauser(&_PeggedTokenBridgeV2.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsPauser(&_PeggedTokenBridgeV2.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.LastOpTimestamps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.LastOpTimestamps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) MaxBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "maxBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MaxBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MaxBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) MinBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "minBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MinBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MinBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Owner() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.Owner(&_PeggedTokenBridgeV2.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Owner() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.Owner(&_PeggedTokenBridgeV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Paused() (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Paused(&_PeggedTokenBridgeV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Paused() (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Paused(&_PeggedTokenBridgeV2.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Pausers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Pausers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Records(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Records(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.SigsVerifier(&_PeggedTokenBridgeV2.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.SigsVerifier(&_PeggedTokenBridgeV2.CallOpts)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Supplies(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "supplies", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.Supplies(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.Supplies(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddPauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddPauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Burn(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "burn", _token, _amount, _toChainId, _toAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Burn(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Burn(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x9e422c33.
//
// Solidity: function burnFrom(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) BurnFrom(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "burnFrom", _token, _amount, _toChainId, _toAccount, _nonce)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x9e422c33.
//
// Solidity: function burnFrom(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) BurnFrom(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.BurnFrom(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x9e422c33.
//
// Solidity: function burnFrom(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) BurnFrom(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.BurnFrom(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// DecreaseSupply is a paid mutator transaction binding the contract method 0x15d0975c.
//
// Solidity: function decreaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) DecreaseSupply(opts *bind.TransactOpts, _token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "decreaseSupply", _token, _delta)
}

// DecreaseSupply is a paid mutator transaction binding the contract method 0x15d0975c.
//
// Solidity: function decreaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DecreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.DecreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// DecreaseSupply is a paid mutator transaction binding the contract method 0x15d0975c.
//
// Solidity: function decreaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) DecreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.DecreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridgeV2.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridgeV2.TransactOpts, id)
}

// IncreaseSupply is a paid mutator transaction binding the contract method 0x79fcd8ee.
//
// Solidity: function increaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) IncreaseSupply(opts *bind.TransactOpts, _token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "increaseSupply", _token, _delta)
}

// IncreaseSupply is a paid mutator transaction binding the contract method 0x79fcd8ee.
//
// Solidity: function increaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) IncreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.IncreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// IncreaseSupply is a paid mutator transaction binding the contract method 0x79fcd8ee.
//
// Solidity: function increaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) IncreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.IncreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Mint(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "mint", _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Mint(&_PeggedTokenBridgeV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Mint(&_PeggedTokenBridgeV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Pause(&_PeggedTokenBridgeV2.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Pause(&_PeggedTokenBridgeV2.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemoveGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemoveGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemovePauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemovePauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenounceGovernor(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenounceGovernor(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RenounceOwnership() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenounceOwnership(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenounceOwnership(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenouncePauser(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenouncePauser(&_PeggedTokenBridgeV2.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayPeriod(&_PeggedTokenBridgeV2.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayPeriod(&_PeggedTokenBridgeV2.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayThresholds(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayThresholds(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochLength(&_PeggedTokenBridgeV2.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochLength(&_PeggedTokenBridgeV2.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochVolumeCaps(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochVolumeCaps(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _caps)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetMaxBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setMaxBurn", _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMaxBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMaxBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetMinBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setMinBurn", _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMinBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMinBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetSupply is a paid mutator transaction binding the contract method 0xb4d8cedc.
//
// Solidity: function setSupply(address _token, uint256 _supply) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetSupply(opts *bind.TransactOpts, _token common.Address, _supply *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setSupply", _token, _supply)
}

// SetSupply is a paid mutator transaction binding the contract method 0xb4d8cedc.
//
// Solidity: function setSupply(address _token, uint256 _supply) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetSupply(_token common.Address, _supply *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _supply)
}

// SetSupply is a paid mutator transaction binding the contract method 0xb4d8cedc.
//
// Solidity: function setSupply(address _token, uint256 _supply) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetSupply(_token common.Address, _supply *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _supply)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.TransferOwnership(&_PeggedTokenBridgeV2.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.TransferOwnership(&_PeggedTokenBridgeV2.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Unpause(&_PeggedTokenBridgeV2.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Unpause(&_PeggedTokenBridgeV2.TransactOpts)
}

// PeggedTokenBridgeV2BurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2BurnIterator struct {
	Event *PeggedTokenBridgeV2Burn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2BurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Burn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Burn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2BurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2BurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Burn represents a Burn event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Burn struct {
	BurnId    [32]byte
	Token     common.Address
	Account   common.Address
	Amount    *big.Int
	ToChainId uint64
	ToAccount common.Address
	Nonce     uint64
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0x6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a3.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, uint64 toChainId, address toAccount, uint64 nonce)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterBurn(opts *bind.FilterOpts) (*PeggedTokenBridgeV2BurnIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2BurnIterator{contract: _PeggedTokenBridgeV2.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0x6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a3.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, uint64 toChainId, address toAccount, uint64 nonce)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Burn) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Burn)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0x6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a3.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, uint64 toChainId, address toAccount, uint64 nonce)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseBurn(log types.Log) (*PeggedTokenBridgeV2Burn, error) {
	event := new(PeggedTokenBridgeV2Burn)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayPeriodUpdatedIterator struct {
	Event *PeggedTokenBridgeV2DelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayPeriodUpdated represents a DelayPeriodUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayPeriodUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayPeriodUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayPeriodUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayPeriodUpdated(log types.Log) (*PeggedTokenBridgeV2DelayPeriodUpdated, error) {
	event := new(PeggedTokenBridgeV2DelayPeriodUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayThresholdUpdatedIterator struct {
	Event *PeggedTokenBridgeV2DelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayThresholdUpdated represents a DelayThresholdUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayThresholdUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayThresholdUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayThresholdUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayThresholdUpdated(log types.Log) (*PeggedTokenBridgeV2DelayThresholdUpdated, error) {
	event := new(PeggedTokenBridgeV2DelayThresholdUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferAddedIterator struct {
	Event *PeggedTokenBridgeV2DelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayedTransferAdded represents a DelayedTransferAdded event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayedTransferAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayedTransferAddedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayedTransferAdded)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayedTransferAdded(log types.Log) (*PeggedTokenBridgeV2DelayedTransferAdded, error) {
	event := new(PeggedTokenBridgeV2DelayedTransferAdded)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferExecutedIterator struct {
	Event *PeggedTokenBridgeV2DelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayedTransferExecuted represents a DelayedTransferExecuted event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayedTransferExecutedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayedTransferExecutedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayedTransferExecuted)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayedTransferExecuted(log types.Log) (*PeggedTokenBridgeV2DelayedTransferExecuted, error) {
	event := new(PeggedTokenBridgeV2DelayedTransferExecuted)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2EpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochLengthUpdatedIterator struct {
	Event *PeggedTokenBridgeV2EpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2EpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2EpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2EpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2EpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2EpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2EpochLengthUpdated represents a EpochLengthUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2EpochLengthUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2EpochLengthUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2EpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2EpochLengthUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseEpochLengthUpdated(log types.Log) (*PeggedTokenBridgeV2EpochLengthUpdated, error) {
	event := new(PeggedTokenBridgeV2EpochLengthUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2EpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochVolumeUpdatedIterator struct {
	Event *PeggedTokenBridgeV2EpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2EpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2EpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2EpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2EpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2EpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2EpochVolumeUpdated represents a EpochVolumeUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2EpochVolumeUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2EpochVolumeUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2EpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2EpochVolumeUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseEpochVolumeUpdated(log types.Log) (*PeggedTokenBridgeV2EpochVolumeUpdated, error) {
	event := new(PeggedTokenBridgeV2EpochVolumeUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2GovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorAddedIterator struct {
	Event *PeggedTokenBridgeV2GovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2GovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2GovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2GovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2GovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2GovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2GovernorAdded represents a GovernorAdded event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterGovernorAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeV2GovernorAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2GovernorAddedIterator{contract: _PeggedTokenBridgeV2.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2GovernorAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2GovernorAdded)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseGovernorAdded(log types.Log) (*PeggedTokenBridgeV2GovernorAdded, error) {
	event := new(PeggedTokenBridgeV2GovernorAdded)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2GovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorRemovedIterator struct {
	Event *PeggedTokenBridgeV2GovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2GovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2GovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2GovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2GovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2GovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2GovernorRemoved represents a GovernorRemoved event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgeV2GovernorRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2GovernorRemovedIterator{contract: _PeggedTokenBridgeV2.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2GovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2GovernorRemoved)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseGovernorRemoved(log types.Log) (*PeggedTokenBridgeV2GovernorRemoved, error) {
	event := new(PeggedTokenBridgeV2GovernorRemoved)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MaxBurnUpdatedIterator is returned from FilterMaxBurnUpdated and is used to iterate over the raw logs and unpacked data for MaxBurnUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MaxBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeV2MaxBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2MaxBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2MaxBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2MaxBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2MaxBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2MaxBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2MaxBurnUpdated represents a MaxBurnUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MaxBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxBurnUpdated is a free log retrieval operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterMaxBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2MaxBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2MaxBurnUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "MaxBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxBurnUpdated is a free log subscription operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchMaxBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2MaxBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2MaxBurnUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxBurnUpdated is a log parse operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseMaxBurnUpdated(log types.Log) (*PeggedTokenBridgeV2MaxBurnUpdated, error) {
	event := new(PeggedTokenBridgeV2MaxBurnUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MinBurnUpdatedIterator is returned from FilterMinBurnUpdated and is used to iterate over the raw logs and unpacked data for MinBurnUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MinBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeV2MinBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2MinBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2MinBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2MinBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2MinBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2MinBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2MinBurnUpdated represents a MinBurnUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MinBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinBurnUpdated is a free log retrieval operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterMinBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2MinBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2MinBurnUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "MinBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMinBurnUpdated is a free log subscription operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchMinBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2MinBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2MinBurnUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinBurnUpdated is a log parse operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseMinBurnUpdated(log types.Log) (*PeggedTokenBridgeV2MinBurnUpdated, error) {
	event := new(PeggedTokenBridgeV2MinBurnUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MintIterator struct {
	Event *PeggedTokenBridgeV2Mint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2MintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Mint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Mint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2MintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2MintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Mint represents a Mint event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Mint struct {
	MintId     [32]byte
	Token      common.Address
	Account    common.Address
	Amount     *big.Int
	RefChainId uint64
	RefId      [32]byte
	Depositor  common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterMint(opts *bind.FilterOpts) (*PeggedTokenBridgeV2MintIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2MintIterator{contract: _PeggedTokenBridgeV2.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchMint(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Mint) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Mint)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseMint(log types.Log) (*PeggedTokenBridgeV2Mint, error) {
	event := new(PeggedTokenBridgeV2Mint)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2OwnershipTransferredIterator struct {
	Event *PeggedTokenBridgeV2OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2OwnershipTransferred represents a OwnershipTransferred event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PeggedTokenBridgeV2OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2OwnershipTransferredIterator{contract: _PeggedTokenBridgeV2.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2OwnershipTransferred)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseOwnershipTransferred(log types.Log) (*PeggedTokenBridgeV2OwnershipTransferred, error) {
	event := new(PeggedTokenBridgeV2OwnershipTransferred)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2PausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PausedIterator struct {
	Event *PeggedTokenBridgeV2Paused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2PausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Paused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Paused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2PausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2PausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Paused represents a Paused event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Paused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterPaused(opts *bind.FilterOpts) (*PeggedTokenBridgeV2PausedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2PausedIterator{contract: _PeggedTokenBridgeV2.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Paused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Paused)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParsePaused(log types.Log) (*PeggedTokenBridgeV2Paused, error) {
	event := new(PeggedTokenBridgeV2Paused)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2PauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserAddedIterator struct {
	Event *PeggedTokenBridgeV2PauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2PauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2PauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2PauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2PauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2PauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2PauserAdded represents a PauserAdded event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterPauserAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeV2PauserAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2PauserAddedIterator{contract: _PeggedTokenBridgeV2.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2PauserAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2PauserAdded)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParsePauserAdded(log types.Log) (*PeggedTokenBridgeV2PauserAdded, error) {
	event := new(PeggedTokenBridgeV2PauserAdded)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2PauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserRemovedIterator struct {
	Event *PeggedTokenBridgeV2PauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2PauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2PauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2PauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2PauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2PauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2PauserRemoved represents a PauserRemoved event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterPauserRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgeV2PauserRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2PauserRemovedIterator{contract: _PeggedTokenBridgeV2.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2PauserRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2PauserRemoved)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParsePauserRemoved(log types.Log) (*PeggedTokenBridgeV2PauserRemoved, error) {
	event := new(PeggedTokenBridgeV2PauserRemoved)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2SupplyUpdatedIterator is returned from FilterSupplyUpdated and is used to iterate over the raw logs and unpacked data for SupplyUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2SupplyUpdatedIterator struct {
	Event *PeggedTokenBridgeV2SupplyUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2SupplyUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2SupplyUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2SupplyUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2SupplyUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2SupplyUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2SupplyUpdated represents a SupplyUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2SupplyUpdated struct {
	Token  common.Address
	Supply *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterSupplyUpdated is a free log retrieval operation binding the contract event 0xeb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e9499.
//
// Solidity: event SupplyUpdated(address token, uint256 supply)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterSupplyUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2SupplyUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "SupplyUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2SupplyUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "SupplyUpdated", logs: logs, sub: sub}, nil
}

// WatchSupplyUpdated is a free log subscription operation binding the contract event 0xeb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e9499.
//
// Solidity: event SupplyUpdated(address token, uint256 supply)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchSupplyUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2SupplyUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "SupplyUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2SupplyUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "SupplyUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSupplyUpdated is a log parse operation binding the contract event 0xeb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e9499.
//
// Solidity: event SupplyUpdated(address token, uint256 supply)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseSupplyUpdated(log types.Log) (*PeggedTokenBridgeV2SupplyUpdated, error) {
	event := new(PeggedTokenBridgeV2SupplyUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "SupplyUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2UnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2UnpausedIterator struct {
	Event *PeggedTokenBridgeV2Unpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2UnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Unpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Unpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2UnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2UnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Unpaused represents a Unpaused event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Unpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterUnpaused(opts *bind.FilterOpts) (*PeggedTokenBridgeV2UnpausedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2UnpausedIterator{contract: _PeggedTokenBridgeV2.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Unpaused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Unpaused)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseUnpaused(log types.Log) (*PeggedTokenBridgeV2Unpaused, error) {
	event := new(PeggedTokenBridgeV2Unpaused)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
