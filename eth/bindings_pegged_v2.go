// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package eth

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// OriginalTokenVaultV2MetaData contains all meta data concerning the OriginalTokenVaultV2 contract.
var OriginalTokenVaultV2MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"depositId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"mintChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinDepositUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAccount\",\"type\":\"address\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_mintChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_mintAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"depositNative\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeWrap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"name\":\"setWrap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b506040516200378838038062003788833981016040819052620000349162000255565b6001600055620000443362000079565b6001805460ff60a01b191690556200005c33620000cb565b620000673362000195565b6001600160a01b031660805262000287565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6001600160a01b03811660009081526002602052604090205460ff16156200013a5760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526003602052604090205460ff1615620002005760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f720000000000604482015260640162000131565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b591016200018a565b6000602082840312156200026857600080fd5b81516001600160a01b03811681146200028057600080fd5b9392505050565b6080516134de620002aa60003960008181610752015261178601526134de6000f3fe6080604052600436106102885760003560e01c80636b2c0f5511610153578063adc0d57f116100cb578063e3eece261161007f578063eecdac8811610064578063eecdac88146107f2578063f2fde38b14610812578063f83213831461083257600080fd5b8063e3eece2614610789578063e43581b8146107b957600080fd5b8063b5f2bc47116100b0578063b5f2bc4714610713578063ccf2683b14610740578063e026049c1461077457600080fd5b8063adc0d57f14610683578063b1c94d94146106fd57600080fd5b80638456cb59116101225780639e25fc5c116101075780639e25fc5c146106235780639ff9001a14610643578063a21a92801461066357600080fd5b80638456cb59146105f05780638da5cb5b1461060557600080fd5b80636b2c0f551461056b5780636ef8d66d1461058b57806380f51c12146105a057806382dc1ec4146105d057600080fd5b8063402d267d1161020157806354eea796116101b55780635c975abb1161019a5780635c975abb146104ff5780635ec2fa261461051e57806360216b001461053e57600080fd5b806354eea796146104c957806357d775f8146104e957600080fd5b806346fbf68e116101e657806346fbf68e1461044357806347b16c6c1461047c57806352532faa1461049c57600080fd5b8063402d267d146103de578063457bfa2f1461040b57600080fd5b8063303b6442116102585780633c4a25d01161023d5780633c4a25d0146103895780633d572107146103a95780633f4ba83a146103c957600080fd5b8063303b64421461033c5780633c29f8391461035c57600080fd5b8062a95fd71461029457806301e64725146102ba57806317bdbae5146102fa578063234636241461031c57600080fd5b3661028f57005b600080fd5b6102a76102a2366004612edd565b61085f565b6040519081526020015b60405180910390f35b3480156102c657600080fd5b506102ea6102d5366004612f2a565b600b6020526000908152604090205460ff1681565b60405190151581526020016102b1565b34801561030657600080fd5b5061031a610315366004612f8f565b610ac5565b005b34801561032857600080fd5b506102a7610337366004612ffb565b610c63565b34801561034857600080fd5b5061031a610357366004612f8f565b610dae565b34801561036857600080fd5b506102a7610377366004613059565b600c6020526000908152604090205481565b34801561039557600080fd5b5061031a6103a4366004613059565b610f45565b3480156103b557600080fd5b5061031a6103c4366004612f2a565b610fba565b3480156103d557600080fd5b5061031a61104e565b3480156103ea57600080fd5b506102a76103f9366004613059565b600d6020526000908152604090205481565b34801561041757600080fd5b50600e5461042b906001600160a01b031681565b6040516001600160a01b0390911681526020016102b1565b34801561044f57600080fd5b506102ea61045e366004613059565b6001600160a01b031660009081526002602052604090205460ff1690565b34801561048857600080fd5b5061031a610497366004612f8f565b6110b7565b3480156104a857600080fd5b506102a76104b7366004613059565b60096020526000908152604090205481565b3480156104d557600080fd5b5061031a6104e4366004612f2a565b61124e565b3480156104f557600080fd5b506102a760045481565b34801561050b57600080fd5b50600154600160a01b900460ff166102ea565b34801561052a57600080fd5b5061031a610539366004612f8f565b6112db565b34801561054a57600080fd5b506102a7610559366004613059565b60056020526000908152604090205481565b34801561057757600080fd5b5061031a610586366004613059565b611472565b34801561059757600080fd5b5061031a6114e4565b3480156105ac57600080fd5b506102ea6105bb366004613059565b60026020526000908152604090205460ff1681565b3480156105dc57600080fd5b5061031a6105eb366004613059565b6114ed565b3480156105fc57600080fd5b5061031a61155f565b34801561061157600080fd5b506001546001600160a01b031661042b565b34801561062f57600080fd5b5061031a61063e366004612f2a565b6115c6565b34801561064f57600080fd5b5061031a61065e366004613059565b61163b565b34801561066f57600080fd5b506102a761067e366004613074565b6116c6565b34801561068f57600080fd5b506106d261069e366004612f2a565b60086020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b0395861681529490931660208501529183015260608201526080016102b1565b34801561070957600080fd5b506102a7600a5481565b34801561071f57600080fd5b506102a761072e366004613059565b60066020526000908152604090205481565b34801561074c57600080fd5b5061042b7f000000000000000000000000000000000000000000000000000000000000000081565b34801561078057600080fd5b5061031a611a90565b34801561079557600080fd5b506102ea6107a4366004613059565b60036020526000908152604090205460ff1681565b3480156107c557600080fd5b506102ea6107d4366004613059565b6001600160a01b031660009081526003602052604090205460ff1690565b3480156107fe57600080fd5b5061031a61080d366004613059565b611a99565b34801561081e57600080fd5b5061031a61082d366004613059565b611b0b565b34801561083e57600080fd5b506102a761084d366004613059565b60076020526000908152604090205481565b6000600260005414156108b95760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064015b60405180910390fd5b6002600055600154600160a01b900460ff161561090b5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108b0565b84341461095a5760405162461bcd60e51b815260206004820152600f60248201527f416d6f756e74206d69736d61746368000000000000000000000000000000000060448201526064016108b0565b600e546001600160a01b03166109b25760405162461bcd60e51b815260206004820152601360248201527f4e61746976652077726170206e6f74207365740000000000000000000000000060448201526064016108b0565b600e546000906109ce906001600160a01b031687878787611bf9565b9050600e60009054906101000a90046001600160a01b03166001600160a01b031663d0e30db0876040518263ffffffff1660e01b81526004016000604051808303818588803b158015610a2057600080fd5b505af1158015610a34573d6000803e3d6000fd5b5050600e54604080518681523360208201526001600160a01b0392831691810191909152606081018b905267ffffffffffffffff808b16608083015291891660a082015290871660c08201527f28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b935060e0019150610aaf9050565b60405180910390a1600160005595945050505050565b3360009081526003602052604090205460ff16610b1d5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108b0565b828114610b5e5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108b0565b60005b83811015610c5c57828282818110610b7b57610b7b613163565b9050602002013560096000878785818110610b9857610b98613163565b9050602002016020810190610bad9190613059565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce858583818110610bfa57610bfa613163565b9050602002016020810190610c0f9190613059565b848484818110610c2157610c21613163565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610c548161318f565b915050610b61565b5050505050565b600060026000541415610cb85760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0060448201526064016108b0565b6002600055600154600160a01b900460ff1615610d0a5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108b0565b6000610d198787878787611bf9565b9050610d306001600160a01b038816333089611df6565b604080518281523360208201526001600160a01b03898116828401526060820189905267ffffffffffffffff888116608084015290871660a0830152851660c082015290517f28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b9181900360e00190a160016000559695505050505050565b3360009081526003602052604090205460ff16610e065760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108b0565b828114610e475760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108b0565b60005b83811015610c5c57828282818110610e6457610e64613163565b90506020020135600d6000878785818110610e8157610e81613163565b9050602002016020810190610e969190613059565b6001600160a01b031681526020810191909152604001600020557f0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72858583818110610ee357610ee3613163565b9050602002016020810190610ef89190613059565b848484818110610f0a57610f0a613163565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610f3d8161318f565b915050610e4a565b33610f586001546001600160a01b031690565b6001600160a01b031614610fae5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108b0565b610fb781611e94565b50565b3360009081526003602052604090205460ff166110125760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108b0565b600a8190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526002602052604090205460ff166110ad5760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108b0565b6110b5611f51565b565b3360009081526003602052604090205460ff1661110f5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108b0565b8281146111505760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108b0565b60005b83811015610c5c5782828281811061116d5761116d613163565b905060200201356006600087878581811061118a5761118a613163565b905060200201602081019061119f9190613059565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e898585838181106111ec576111ec613163565b90506020020160208101906112019190613059565b84848481811061121357611213613163565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a1806112468161318f565b915050611153565b3360009081526003602052604090205460ff166112a65760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108b0565b60048190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b390602001611043565b3360009081526003602052604090205460ff166113335760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b60448201526064016108b0565b8281146113745760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b60448201526064016108b0565b60005b83811015610c5c5782828281811061139157611391613163565b90506020020135600c60008787858181106113ae576113ae613163565b90506020020160208101906113c39190613059565b6001600160a01b031681526020810191909152604001600020557f0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba685858381811061141057611410613163565b90506020020160208101906114259190613059565b84848481811061143757611437613163565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061146a8161318f565b915050611377565b336114856001546001600160a01b031690565b6001600160a01b0316146114db5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108b0565b610fb781611ff7565b6110b533611ff7565b336115006001546001600160a01b031690565b6001600160a01b0316146115565760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108b0565b610fb7816120b0565b3360009081526002602052604090205460ff166115be5760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f742070617573657200000000000000000000000060448201526064016108b0565b6110b561216d565b600154600160a01b900460ff16156116135760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108b0565b600061161e826121f5565b90506116378160000151826020015183604001516123ba565b5050565b3361164e6001546001600160a01b031690565b6001600160a01b0316146116a45760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108b0565b600e80546001600160a01b0319166001600160a01b0392909216919091179055565b600154600090600160a01b900460ff16156117165760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108b0565b6000463060405160200161176c92919091825260601b6bffffffffffffffffffffffff191660208201527f57697468647261770000000000000000000000000000000000000000000000006034820152603c0190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828c8c6040516020016117c8939291906131aa565b6040516020818303038152906040528a8a8a8a8a8a6040518863ffffffff1660e01b81526004016117ff97969594939291906132db565b60006040518083038186803b15801561181757600080fd5b505afa15801561182b573d6000803e3d6000fd5b5050505060006118708b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506124ef92505050565b6020818101518251604080850151606080870151608088015160a089015185516bffffffffffffffffffffffff1998851b8916818b015296841b88166034880152604887019490945290821b8616606886015277ffffffffffffffffffffffffffffffffffffffffffffffff1960c09190911b16607c850152608484019190915230901b90921660a48201528151808203609801815260b890910182528051908301206000818152600b9093529120549192509060ff16156119645760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108b0565b6000818152600b602052604090819020805460ff1916600117905582519083015161198f9190612651565b81516001600160a01b031660009081526009602052604090205480158015906119bb5750808360400151115b156119dd576119d882846020015185600001518660400151612769565b6119f4565b6119f48360200151846000015185604001516123ba565b602080840151845160408087015160808089015160a0808b01516060808d015187518d81526001600160a01b039a8b169b81019b909b52978916968a01969096529488019390935267ffffffffffffffff16908601528401521660c08201527f296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb9060e00160405180910390a1509b9a5050505050505050505050565b6110b53361287c565b33611aac6001546001600160a01b031690565b6001600160a01b031614611b025760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108b0565b610fb78161287c565b33611b1e6001546001600160a01b031690565b6001600160a01b031614611b745760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064016108b0565b6001600160a01b038116611bf05760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f646472657373000000000000000000000000000000000000000000000000000060648201526084016108b0565b610fb781612935565b6001600160a01b0385166000908152600c60205260408120548511611c605760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c0000000000000000000000000000000060448201526064016108b0565b6001600160a01b0386166000908152600d60205260409020541580611c9d57506001600160a01b0386166000908152600d60205260409020548511155b611ce95760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c617267650000000000000000000000000000000060448201526064016108b0565b6040516bffffffffffffffffffffffff1933606090811b8216602084015288811b821660348401526048830188905277ffffffffffffffffffffffffffffffffffffffffffffffff1960c088811b8216606886015287831b8416607086015286811b8216608486015246901b16608c84015230901b16609482015260009060a80160408051601f1981840301815291815281516020928301206000818152600b90935291205490915060ff1615611dd25760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b60448201526064016108b0565b6000818152600b60205260409020805460ff19166001179055905095945050505050565b6040516001600160a01b0380851660248301528316604482015260648101829052611e8e9085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612987565b50505050565b6001600160a01b03811660009081526003602052604090205460ff1615611efd5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016108b0565b6001600160a01b038116600081815260036020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b59101611043565b600154600160a01b900460ff16611faa5760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f742070617573656400000000000000000000000060448201526064016108b0565b6001805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526002602052604090205460ff1661205f5760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f7420706175736572000000000000000000000060448201526064016108b0565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9101611043565b6001600160a01b03811660009081526002602052604090205460ff16156121195760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064016108b0565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89101611043565b600154600160a01b900460ff16156121ba5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b60448201526064016108b0565b6001805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611fda3390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260086020908152604091829020825160808101845281546001600160a01b03908116825260018301541692810192909252600281015492820192909252600390910154606082018190526122b45760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f7420657869737400000000000060448201526064016108b0565b600a5481606001516122c691906133bb565b42116123145760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b656400000060448201526064016108b0565b600083815260086020908152604080832080546001600160a01b03199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426936123ac93889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b600e546001600160a01b03838116911614156124d657600e54604051632e1a7d4d60e01b8152600481018390526001600160a01b0390911690632e1a7d4d90602401600060405180830381600087803b15801561241657600080fd5b505af115801561242a573d6000803e3d6000fd5b505050506000836001600160a01b03168261c35090604051600060405180830381858888f193505050503d8060008114612480576040519150601f19603f3d011682016040523d82523d6000602084013e612485565b606091505b5050905080611e8e5760405162461bcd60e51b815260206004820152601b60248201527f6661696c656420746f2073656e64206e617469766520746f6b656e000000000060448201526064016108b0565b6124ea6001600160a01b0383168483612a6c565b505050565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b602083015151835110156126495761254d83612a9c565b9092509050816001141561257c5761256c61256784612ad6565b612b93565b6001600160a01b03168452612536565b81600214156125a45761259161256784612ad6565b6001600160a01b03166020850152612536565b81600314156125c8576125be6125b984612ad6565b612ba4565b6040850152612536565b81600414156125f0576125dd61256784612ad6565b6001600160a01b03166060850152612536565b81600514156126165761260283612bdb565b67ffffffffffffffff166080850152612536565b816006141561263a5761263061262b84612ad6565b612c5d565b60a0850152612536565b6126448382612c75565b612536565b505050919050565b60045461265c575050565b6001600160a01b0382166000908152600660205260409020548061267f57505050565b6001600160a01b038316600090815260056020526040812054600454909142916126a981846133d3565b6126b391906133f5565b6001600160a01b0387166000908152600760205260409020549091508111156126de578492506126eb565b6126e885846133bb565b92505b8383111561273b5760405162461bcd60e51b815260206004820152601260248201527f766f6c756d65206578636565647320636170000000000000000000000000000060448201526064016108b0565b506001600160a01b039094166000908152600560209081526040808320939093556007905220929092555050565b600084815260086020526040902060030154156127c85760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c7265616479206578697374730060448201526064016108b0565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b8152600890935291869020945185549085166001600160a01b031991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce69061286e9086815260200190565b60405180910390a150505050565b6001600160a01b03811660009081526003602052604090205460ff166128e45760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f7200000000000000000060448201526064016108b0565b6001600160a01b038116600081815260036020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b9101611043565b600180546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60006129dc826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316612ce79092919063ffffffff16565b8051909150156124ea57808060200190518101906129fa9190613414565b6124ea5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f7420737563636565640000000000000000000000000000000000000000000060648201526084016108b0565b6040516001600160a01b0383166024820152604481018290526124ea90849063a9059cbb60e01b90606401611e2a565b6000806000612aaa84612bdb565b9050612ab76008826133d3565b9250806007166005811115612ace57612ace613436565b915050915091565b60606000612ae383612bdb565b90506000818460000151612af791906133bb565b9050836020015151811115612b0b57600080fd5b8167ffffffffffffffff811115612b2457612b2461344c565b6040519080825280601f01601f191660200182016040528015612b4e576020820181803683370190505b50602080860151865192955091818601919083010160005b85811015612b88578181015183820152612b816020826133bb565b9050612b66565b505050935250919050565b6000612b9e82612d00565b92915050565b6000602082511115612bb557600080fd5b6020820151905081516020612bca9190613462565b612bd59060086133f5565b1c919050565b602080820151825181019091015160009182805b600a811015612c575783811a9150612c088160076133f5565b82607f16901b851794508160801660001415612c4557612c298160016133bb565b86518790612c389083906133bb565b9052509395945050505050565b80612c4f8161318f565b915050612bef565b50600080fd5b60008151602014612c6d57600080fd5b506020015190565b6000816005811115612c8957612c89613436565b1415612c98576124ea82612bdb565b6002816005811115612cac57612cac613436565b141561028f576000612cbd83612bdb565b90508083600001818151612cd191906133bb565b905250602083015151835111156124ea57600080fd5b6060612cf68484600085612d28565b90505b9392505050565b60008151601414612d1057600080fd5b50602001516c01000000000000000000000000900490565b606082471015612da05760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c000000000000000000000000000000000000000000000000000060648201526084016108b0565b6001600160a01b0385163b612df75760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016108b0565b600080866001600160a01b03168587604051612e139190613479565b60006040518083038185875af1925050503d8060008114612e50576040519150601f19603f3d011682016040523d82523d6000602084013e612e55565b606091505b5091509150612e65828286612e70565b979650505050505050565b60608315612e7f575081612cf9565b825115612e8f5782518084602001fd5b8160405162461bcd60e51b81526004016108b09190613495565b803567ffffffffffffffff81168114612ec157600080fd5b919050565b80356001600160a01b0381168114612ec157600080fd5b60008060008060808587031215612ef357600080fd5b84359350612f0360208601612ea9565b9250612f1160408601612ec6565b9150612f1f60608601612ea9565b905092959194509250565b600060208284031215612f3c57600080fd5b5035919050565b60008083601f840112612f5557600080fd5b50813567ffffffffffffffff811115612f6d57600080fd5b6020830191508360208260051b8501011115612f8857600080fd5b9250929050565b60008060008060408587031215612fa557600080fd5b843567ffffffffffffffff80821115612fbd57600080fd5b612fc988838901612f43565b90965094506020870135915080821115612fe257600080fd5b50612fef87828801612f43565b95989497509550505050565b600080600080600060a0868803121561301357600080fd5b61301c86612ec6565b94506020860135935061303160408701612ea9565b925061303f60608701612ec6565b915061304d60808701612ea9565b90509295509295909350565b60006020828403121561306b57600080fd5b612cf982612ec6565b6000806000806000806000806080898b03121561309057600080fd5b883567ffffffffffffffff808211156130a857600080fd5b818b0191508b601f8301126130bc57600080fd5b8135818111156130cb57600080fd5b8c60208285010111156130dd57600080fd5b60209283019a509850908a013590808211156130f857600080fd5b6131048c838d01612f43565b909850965060408b013591508082111561311d57600080fd5b6131298c838d01612f43565b909650945060608b013591508082111561314257600080fd5b5061314f8b828c01612f43565b999c989b5096995094979396929594505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006000198214156131a3576131a3613179565b5060010190565b838152818360208301376000910160200190815292915050565b60005b838110156131df5781810151838201526020016131c7565b83811115611e8e5750506000910152565b600081518084526132088160208601602086016131c4565b601f01601f19169290920160200192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b8183526000602080850194508260005b85811015613281576001600160a01b0361326e83612ec6565b1687529582019590820190600101613255565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8311156132be57600080fd5b8260051b8083602087013760009401602001938452509192915050565b6080815260006132ee608083018a6131f0565b82810360208401528088825260208201905060208960051b8301018a60005b8b81101561338157848303601f190184528135368e9003601e1901811261333357600080fd5b8d01803567ffffffffffffffff81111561334c57600080fd5b8036038f131561335b57600080fd5b61336985826020850161321c565b6020968701969095509390930192505060010161330d565b5050848103604086015261339681898b613245565b9250505082810360608401526133ad81858761328c565b9a9950505050505050505050565b600082198211156133ce576133ce613179565b500190565b6000826133f057634e487b7160e01b600052601260045260246000fd5b500490565b600081600019048311821515161561340f5761340f613179565b500290565b60006020828403121561342657600080fd5b81518015158114612cf957600080fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b60008282101561347457613474613179565b500390565b6000825161348b8184602087016131c4565b9190910192915050565b602081526000612cf960208301846131f056fea264697066735822122043b27dfc8a85059bd5b829248e8eed737563e7685c7778aea31aeeae1fcb132964736f6c63430008090033",
}

// OriginalTokenVaultV2ABI is the input ABI used to generate the binding from.
// Deprecated: Use OriginalTokenVaultV2MetaData.ABI instead.
var OriginalTokenVaultV2ABI = OriginalTokenVaultV2MetaData.ABI

// OriginalTokenVaultV2Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OriginalTokenVaultV2MetaData.Bin instead.
var OriginalTokenVaultV2Bin = OriginalTokenVaultV2MetaData.Bin

// DeployOriginalTokenVaultV2 deploys a new Ethereum contract, binding an instance of OriginalTokenVaultV2 to it.
func DeployOriginalTokenVaultV2(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *OriginalTokenVaultV2, error) {
	parsed, err := OriginalTokenVaultV2MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OriginalTokenVaultV2Bin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &OriginalTokenVaultV2{OriginalTokenVaultV2Caller: OriginalTokenVaultV2Caller{contract: contract}, OriginalTokenVaultV2Transactor: OriginalTokenVaultV2Transactor{contract: contract}, OriginalTokenVaultV2Filterer: OriginalTokenVaultV2Filterer{contract: contract}}, nil
}

// OriginalTokenVaultV2 is an auto generated Go binding around an Ethereum contract.
type OriginalTokenVaultV2 struct {
	OriginalTokenVaultV2Caller     // Read-only binding to the contract
	OriginalTokenVaultV2Transactor // Write-only binding to the contract
	OriginalTokenVaultV2Filterer   // Log filterer for contract events
}

// OriginalTokenVaultV2Caller is an auto generated read-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultV2Transactor is an auto generated write-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultV2Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OriginalTokenVaultV2Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OriginalTokenVaultV2Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OriginalTokenVaultV2Session struct {
	Contract     *OriginalTokenVaultV2 // Generic contract binding to set the session for
	CallOpts     bind.CallOpts         // Call options to use throughout this session
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// OriginalTokenVaultV2CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OriginalTokenVaultV2CallerSession struct {
	Contract *OriginalTokenVaultV2Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts               // Call options to use throughout this session
}

// OriginalTokenVaultV2TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OriginalTokenVaultV2TransactorSession struct {
	Contract     *OriginalTokenVaultV2Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts               // Transaction auth options to use throughout this session
}

// OriginalTokenVaultV2Raw is an auto generated low-level Go binding around an Ethereum contract.
type OriginalTokenVaultV2Raw struct {
	Contract *OriginalTokenVaultV2 // Generic contract binding to access the raw methods on
}

// OriginalTokenVaultV2CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2CallerRaw struct {
	Contract *OriginalTokenVaultV2Caller // Generic read-only contract binding to access the raw methods on
}

// OriginalTokenVaultV2TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OriginalTokenVaultV2TransactorRaw struct {
	Contract *OriginalTokenVaultV2Transactor // Generic write-only contract binding to access the raw methods on
}

// NewOriginalTokenVaultV2 creates a new instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2(address common.Address, backend bind.ContractBackend) (*OriginalTokenVaultV2, error) {
	contract, err := bindOriginalTokenVaultV2(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2{OriginalTokenVaultV2Caller: OriginalTokenVaultV2Caller{contract: contract}, OriginalTokenVaultV2Transactor: OriginalTokenVaultV2Transactor{contract: contract}, OriginalTokenVaultV2Filterer: OriginalTokenVaultV2Filterer{contract: contract}}, nil
}

// NewOriginalTokenVaultV2Caller creates a new read-only instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2Caller(address common.Address, caller bind.ContractCaller) (*OriginalTokenVaultV2Caller, error) {
	contract, err := bindOriginalTokenVaultV2(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2Caller{contract: contract}, nil
}

// NewOriginalTokenVaultV2Transactor creates a new write-only instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2Transactor(address common.Address, transactor bind.ContractTransactor) (*OriginalTokenVaultV2Transactor, error) {
	contract, err := bindOriginalTokenVaultV2(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2Transactor{contract: contract}, nil
}

// NewOriginalTokenVaultV2Filterer creates a new log filterer instance of OriginalTokenVaultV2, bound to a specific deployed contract.
func NewOriginalTokenVaultV2Filterer(address common.Address, filterer bind.ContractFilterer) (*OriginalTokenVaultV2Filterer, error) {
	contract, err := bindOriginalTokenVaultV2(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2Filterer{contract: contract}, nil
}

// bindOriginalTokenVaultV2 binds a generic wrapper to an already deployed contract.
func bindOriginalTokenVaultV2(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OriginalTokenVaultV2ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVaultV2.Contract.OriginalTokenVaultV2Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.OriginalTokenVaultV2Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.OriginalTokenVaultV2Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _OriginalTokenVaultV2.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayPeriod(&_OriginalTokenVaultV2.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) DelayPeriod() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayPeriod(&_OriginalTokenVaultV2.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayThresholds(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.DelayThresholds(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVaultV2.Contract.DelayedTransfers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _OriginalTokenVaultV2.Contract.DelayedTransfers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) EpochLength() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochLength(&_OriginalTokenVaultV2.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) EpochLength() (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochLength(&_OriginalTokenVaultV2.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumeCaps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumeCaps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumes(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.EpochVolumes(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Governors(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Governors(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Governors(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsGovernor(&_OriginalTokenVaultV2.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsGovernor(&_OriginalTokenVaultV2.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsPauser(&_OriginalTokenVaultV2.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) IsPauser(account common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.IsPauser(&_OriginalTokenVaultV2.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.LastOpTimestamps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.LastOpTimestamps(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) MaxDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "maxDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MaxDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MaxDeposit is a free data retrieval call binding the contract method 0x402d267d.
//
// Solidity: function maxDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) MaxDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MaxDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) MinDeposit(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "minDeposit", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MinDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// MinDeposit is a free data retrieval call binding the contract method 0x3c29f839.
//
// Solidity: function minDeposit(address ) view returns(uint256)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) MinDeposit(arg0 common.Address) (*big.Int, error) {
	return _OriginalTokenVaultV2.Contract.MinDeposit(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) NativeWrap(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "nativeWrap")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) NativeWrap() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.NativeWrap(&_OriginalTokenVaultV2.CallOpts)
}

// NativeWrap is a free data retrieval call binding the contract method 0x457bfa2f.
//
// Solidity: function nativeWrap() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) NativeWrap() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.NativeWrap(&_OriginalTokenVaultV2.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Owner() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.Owner(&_OriginalTokenVaultV2.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Owner() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.Owner(&_OriginalTokenVaultV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Paused() (bool, error) {
	return _OriginalTokenVaultV2.Contract.Paused(&_OriginalTokenVaultV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Paused() (bool, error) {
	return _OriginalTokenVaultV2.Contract.Paused(&_OriginalTokenVaultV2.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Pausers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Pausers(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Records(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) Records(arg0 [32]byte) (bool, error) {
	return _OriginalTokenVaultV2.Contract.Records(&_OriginalTokenVaultV2.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Caller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _OriginalTokenVaultV2.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.SigsVerifier(&_OriginalTokenVaultV2.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2CallerSession) SigsVerifier() (common.Address, error) {
	return _OriginalTokenVaultV2.Contract.SigsVerifier(&_OriginalTokenVaultV2.CallOpts)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddPauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.AddPauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Deposit(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "deposit", _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Deposit(&_OriginalTokenVaultV2.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// Deposit is a paid mutator transaction binding the contract method 0x23463624.
//
// Solidity: function deposit(address _token, uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Deposit(_token common.Address, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Deposit(&_OriginalTokenVaultV2.TransactOpts, _token, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) DepositNative(opts *bind.TransactOpts, _amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "depositNative", _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.DepositNative(&_OriginalTokenVaultV2.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// DepositNative is a paid mutator transaction binding the contract method 0x00a95fd7.
//
// Solidity: function depositNative(uint256 _amount, uint64 _mintChainId, address _mintAccount, uint64 _nonce) payable returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) DepositNative(_amount *big.Int, _mintChainId uint64, _mintAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.DepositNative(&_OriginalTokenVaultV2.TransactOpts, _amount, _mintChainId, _mintAccount, _nonce)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.ExecuteDelayedTransfer(&_OriginalTokenVaultV2.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.ExecuteDelayedTransfer(&_OriginalTokenVaultV2.TransactOpts, id)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Pause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Pause(&_OriginalTokenVaultV2.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Pause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Pause(&_OriginalTokenVaultV2.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemoveGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemoveGovernor(&_OriginalTokenVaultV2.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemovePauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RemovePauser(&_OriginalTokenVaultV2.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenounceGovernor(&_OriginalTokenVaultV2.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenounceGovernor(&_OriginalTokenVaultV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenouncePauser(&_OriginalTokenVaultV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.RenouncePauser(&_OriginalTokenVaultV2.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayPeriod(&_OriginalTokenVaultV2.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayPeriod(&_OriginalTokenVaultV2.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayThresholds(&_OriginalTokenVaultV2.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetDelayThresholds(&_OriginalTokenVaultV2.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochLength(&_OriginalTokenVaultV2.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochLength(&_OriginalTokenVaultV2.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochVolumeCaps(&_OriginalTokenVaultV2.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetEpochVolumeCaps(&_OriginalTokenVaultV2.TransactOpts, _tokens, _caps)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetMaxDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setMaxDeposit", _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMaxDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetMaxDeposit is a paid mutator transaction binding the contract method 0x303b6442.
//
// Solidity: function setMaxDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetMaxDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMaxDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetMinDeposit(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setMinDeposit", _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMinDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetMinDeposit is a paid mutator transaction binding the contract method 0x5ec2fa26.
//
// Solidity: function setMinDeposit(address[] _tokens, uint256[] _amounts) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetMinDeposit(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetMinDeposit(&_OriginalTokenVaultV2.TransactOpts, _tokens, _amounts)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) SetWrap(opts *bind.TransactOpts, _weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "setWrap", _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetWrap(&_OriginalTokenVaultV2.TransactOpts, _weth)
}

// SetWrap is a paid mutator transaction binding the contract method 0x9ff9001a.
//
// Solidity: function setWrap(address _weth) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) SetWrap(_weth common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.SetWrap(&_OriginalTokenVaultV2.TransactOpts, _weth)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.TransferOwnership(&_OriginalTokenVaultV2.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.TransferOwnership(&_OriginalTokenVaultV2.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Unpause(&_OriginalTokenVaultV2.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Unpause() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Unpause(&_OriginalTokenVaultV2.TransactOpts)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Withdraw(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.Transact(opts, "withdraw", _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Withdraw(&_OriginalTokenVaultV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Withdraw is a paid mutator transaction binding the contract method 0xa21a9280.
//
// Solidity: function withdraw(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Withdraw(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Withdraw(&_OriginalTokenVaultV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Transactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _OriginalTokenVaultV2.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Session) Receive() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Receive(&_OriginalTokenVaultV2.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2TransactorSession) Receive() (*types.Transaction, error) {
	return _OriginalTokenVaultV2.Contract.Receive(&_OriginalTokenVaultV2.TransactOpts)
}

// OriginalTokenVaultV2DelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayPeriodUpdatedIterator struct {
	Event *OriginalTokenVaultV2DelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayPeriodUpdated represents a DelayPeriodUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayPeriodUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayPeriodUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayPeriodUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayPeriodUpdated(log types.Log) (*OriginalTokenVaultV2DelayPeriodUpdated, error) {
	event := new(OriginalTokenVaultV2DelayPeriodUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayThresholdUpdatedIterator struct {
	Event *OriginalTokenVaultV2DelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayThresholdUpdated represents a DelayThresholdUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayThresholdUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayThresholdUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayThresholdUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayThresholdUpdated(log types.Log) (*OriginalTokenVaultV2DelayThresholdUpdated, error) {
	event := new(OriginalTokenVaultV2DelayThresholdUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferAddedIterator struct {
	Event *OriginalTokenVaultV2DelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayedTransferAdded represents a DelayedTransferAdded event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayedTransferAddedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayedTransferAddedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayedTransferAdded)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayedTransferAdded(log types.Log) (*OriginalTokenVaultV2DelayedTransferAdded, error) {
	event := new(OriginalTokenVaultV2DelayedTransferAdded)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferExecutedIterator struct {
	Event *OriginalTokenVaultV2DelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2DelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2DelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2DelayedTransferExecuted represents a DelayedTransferExecuted event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*OriginalTokenVaultV2DelayedTransferExecutedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DelayedTransferExecutedIterator{contract: _OriginalTokenVaultV2.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2DelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2DelayedTransferExecuted)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDelayedTransferExecuted(log types.Log) (*OriginalTokenVaultV2DelayedTransferExecuted, error) {
	event := new(OriginalTokenVaultV2DelayedTransferExecuted)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2DepositedIterator is returned from FilterDeposited and is used to iterate over the raw logs and unpacked data for Deposited events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2DepositedIterator struct {
	Event *OriginalTokenVaultV2Deposited // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2DepositedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Deposited)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Deposited)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2DepositedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2DepositedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Deposited represents a Deposited event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Deposited struct {
	DepositId   [32]byte
	Depositor   common.Address
	Token       common.Address
	Amount      *big.Int
	MintChainId uint64
	MintAccount common.Address
	Nonce       uint64
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterDeposited is a free log retrieval operation binding the contract event 0x28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount, uint64 nonce)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterDeposited(opts *bind.FilterOpts) (*OriginalTokenVaultV2DepositedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2DepositedIterator{contract: _OriginalTokenVaultV2.contract, event: "Deposited", logs: logs, sub: sub}, nil
}

// WatchDeposited is a free log subscription operation binding the contract event 0x28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount, uint64 nonce)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchDeposited(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Deposited) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Deposited)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Deposited", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposited is a log parse operation binding the contract event 0x28d226819e371600e26624ebc4a9a3947117ee2760209f816c789d3a99bf481b.
//
// Solidity: event Deposited(bytes32 depositId, address depositor, address token, uint256 amount, uint64 mintChainId, address mintAccount, uint64 nonce)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseDeposited(log types.Log) (*OriginalTokenVaultV2Deposited, error) {
	event := new(OriginalTokenVaultV2Deposited)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Deposited", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2EpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochLengthUpdatedIterator struct {
	Event *OriginalTokenVaultV2EpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2EpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2EpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2EpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2EpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2EpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2EpochLengthUpdated represents a EpochLengthUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2EpochLengthUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2EpochLengthUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2EpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2EpochLengthUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseEpochLengthUpdated(log types.Log) (*OriginalTokenVaultV2EpochLengthUpdated, error) {
	event := new(OriginalTokenVaultV2EpochLengthUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2EpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochVolumeUpdatedIterator struct {
	Event *OriginalTokenVaultV2EpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2EpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2EpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2EpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2EpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2EpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2EpochVolumeUpdated represents a EpochVolumeUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2EpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2EpochVolumeUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2EpochVolumeUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2EpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2EpochVolumeUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseEpochVolumeUpdated(log types.Log) (*OriginalTokenVaultV2EpochVolumeUpdated, error) {
	event := new(OriginalTokenVaultV2EpochVolumeUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2GovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorAddedIterator struct {
	Event *OriginalTokenVaultV2GovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2GovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2GovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2GovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2GovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2GovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2GovernorAdded represents a GovernorAdded event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterGovernorAdded(opts *bind.FilterOpts) (*OriginalTokenVaultV2GovernorAddedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2GovernorAddedIterator{contract: _OriginalTokenVaultV2.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2GovernorAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2GovernorAdded)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseGovernorAdded(log types.Log) (*OriginalTokenVaultV2GovernorAdded, error) {
	event := new(OriginalTokenVaultV2GovernorAdded)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2GovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorRemovedIterator struct {
	Event *OriginalTokenVaultV2GovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2GovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2GovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2GovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2GovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2GovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2GovernorRemoved represents a GovernorRemoved event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2GovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultV2GovernorRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2GovernorRemovedIterator{contract: _OriginalTokenVaultV2.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2GovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2GovernorRemoved)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseGovernorRemoved(log types.Log) (*OriginalTokenVaultV2GovernorRemoved, error) {
	event := new(OriginalTokenVaultV2GovernorRemoved)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2MaxDepositUpdatedIterator is returned from FilterMaxDepositUpdated and is used to iterate over the raw logs and unpacked data for MaxDepositUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MaxDepositUpdatedIterator struct {
	Event *OriginalTokenVaultV2MaxDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2MaxDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2MaxDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2MaxDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2MaxDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2MaxDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2MaxDepositUpdated represents a MaxDepositUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MaxDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxDepositUpdated is a free log retrieval operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterMaxDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2MaxDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2MaxDepositUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "MaxDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxDepositUpdated is a free log subscription operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchMaxDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2MaxDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "MaxDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2MaxDepositUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxDepositUpdated is a log parse operation binding the contract event 0x0e5d348f9737ccc8b4cf0eea0ccf3670af071af8bea5d64664f10e700c08de72.
//
// Solidity: event MaxDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseMaxDepositUpdated(log types.Log) (*OriginalTokenVaultV2MaxDepositUpdated, error) {
	event := new(OriginalTokenVaultV2MaxDepositUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MaxDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2MinDepositUpdatedIterator is returned from FilterMinDepositUpdated and is used to iterate over the raw logs and unpacked data for MinDepositUpdated events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MinDepositUpdatedIterator struct {
	Event *OriginalTokenVaultV2MinDepositUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2MinDepositUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2MinDepositUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2MinDepositUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2MinDepositUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2MinDepositUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2MinDepositUpdated represents a MinDepositUpdated event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2MinDepositUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinDepositUpdated is a free log retrieval operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterMinDepositUpdated(opts *bind.FilterOpts) (*OriginalTokenVaultV2MinDepositUpdatedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2MinDepositUpdatedIterator{contract: _OriginalTokenVaultV2.contract, event: "MinDepositUpdated", logs: logs, sub: sub}, nil
}

// WatchMinDepositUpdated is a free log subscription operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchMinDepositUpdated(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2MinDepositUpdated) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "MinDepositUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2MinDepositUpdated)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinDepositUpdated is a log parse operation binding the contract event 0x0f48d517989455cd80ed52427e80553e66f9b69fd5cee8e26bd1a1f9c364fba6.
//
// Solidity: event MinDepositUpdated(address token, uint256 amount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseMinDepositUpdated(log types.Log) (*OriginalTokenVaultV2MinDepositUpdated, error) {
	event := new(OriginalTokenVaultV2MinDepositUpdated)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "MinDepositUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2OwnershipTransferredIterator struct {
	Event *OriginalTokenVaultV2OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2OwnershipTransferred represents a OwnershipTransferred event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*OriginalTokenVaultV2OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2OwnershipTransferredIterator{contract: _OriginalTokenVaultV2.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2OwnershipTransferred)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseOwnershipTransferred(log types.Log) (*OriginalTokenVaultV2OwnershipTransferred, error) {
	event := new(OriginalTokenVaultV2OwnershipTransferred)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2PausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PausedIterator struct {
	Event *OriginalTokenVaultV2Paused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2PausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Paused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Paused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2PausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2PausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Paused represents a Paused event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Paused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterPaused(opts *bind.FilterOpts) (*OriginalTokenVaultV2PausedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2PausedIterator{contract: _OriginalTokenVaultV2.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Paused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Paused)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParsePaused(log types.Log) (*OriginalTokenVaultV2Paused, error) {
	event := new(OriginalTokenVaultV2Paused)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2PauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserAddedIterator struct {
	Event *OriginalTokenVaultV2PauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2PauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2PauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2PauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2PauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2PauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2PauserAdded represents a PauserAdded event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterPauserAdded(opts *bind.FilterOpts) (*OriginalTokenVaultV2PauserAddedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2PauserAddedIterator{contract: _OriginalTokenVaultV2.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2PauserAdded) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2PauserAdded)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParsePauserAdded(log types.Log) (*OriginalTokenVaultV2PauserAdded, error) {
	event := new(OriginalTokenVaultV2PauserAdded)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2PauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserRemovedIterator struct {
	Event *OriginalTokenVaultV2PauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2PauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2PauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2PauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2PauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2PauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2PauserRemoved represents a PauserRemoved event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2PauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterPauserRemoved(opts *bind.FilterOpts) (*OriginalTokenVaultV2PauserRemovedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2PauserRemovedIterator{contract: _OriginalTokenVaultV2.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2PauserRemoved) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2PauserRemoved)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParsePauserRemoved(log types.Log) (*OriginalTokenVaultV2PauserRemoved, error) {
	event := new(OriginalTokenVaultV2PauserRemoved)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2UnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2UnpausedIterator struct {
	Event *OriginalTokenVaultV2Unpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2UnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Unpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Unpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2UnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2UnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Unpaused represents a Unpaused event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Unpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterUnpaused(opts *bind.FilterOpts) (*OriginalTokenVaultV2UnpausedIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2UnpausedIterator{contract: _OriginalTokenVaultV2.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Unpaused) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Unpaused)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseUnpaused(log types.Log) (*OriginalTokenVaultV2Unpaused, error) {
	event := new(OriginalTokenVaultV2Unpaused)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OriginalTokenVaultV2WithdrawnIterator is returned from FilterWithdrawn and is used to iterate over the raw logs and unpacked data for Withdrawn events raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2WithdrawnIterator struct {
	Event *OriginalTokenVaultV2Withdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OriginalTokenVaultV2WithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OriginalTokenVaultV2Withdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OriginalTokenVaultV2Withdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OriginalTokenVaultV2WithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OriginalTokenVaultV2WithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OriginalTokenVaultV2Withdrawn represents a Withdrawn event raised by the OriginalTokenVaultV2 contract.
type OriginalTokenVaultV2Withdrawn struct {
	WithdrawId  [32]byte
	Receiver    common.Address
	Token       common.Address
	Amount      *big.Int
	RefChainId  uint64
	RefId       [32]byte
	BurnAccount common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawn is a free log retrieval operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) FilterWithdrawn(opts *bind.FilterOpts) (*OriginalTokenVaultV2WithdrawnIterator, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.FilterLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return &OriginalTokenVaultV2WithdrawnIterator{contract: _OriginalTokenVaultV2.contract, event: "Withdrawn", logs: logs, sub: sub}, nil
}

// WatchWithdrawn is a free log subscription operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) WatchWithdrawn(opts *bind.WatchOpts, sink chan<- *OriginalTokenVaultV2Withdrawn) (event.Subscription, error) {

	logs, sub, err := _OriginalTokenVaultV2.contract.WatchLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OriginalTokenVaultV2Withdrawn)
				if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Withdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawn is a log parse operation binding the contract event 0x296a629c5265cb4e5319803d016902eb70a9079b89655fe2b7737821ed88beeb.
//
// Solidity: event Withdrawn(bytes32 withdrawId, address receiver, address token, uint256 amount, uint64 refChainId, bytes32 refId, address burnAccount)
func (_OriginalTokenVaultV2 *OriginalTokenVaultV2Filterer) ParseWithdrawn(log types.Log) (*OriginalTokenVaultV2Withdrawn, error) {
	event := new(OriginalTokenVaultV2Withdrawn)
	if err := _OriginalTokenVaultV2.contract.UnpackLog(event, "Withdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MetaData contains all meta data concerning the PeggedTokenBridgeV2 contract.
var PeggedTokenBridgeV2MetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"burnId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"DelayPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"DelayThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DelayedTransferAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DelayedTransferExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"EpochLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"}],\"name\":\"EpochVolumeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GovernorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MinBurnUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mintId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"refChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"SupplyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_toChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_toAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_toChainId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_toAccount\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"decreaseSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delayThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"delayedTransfers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumeCaps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"epochVolumes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"executeDelayedTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"governors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"increaseSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastOpTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_request\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pausers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setDelayPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_thresholds\",\"type\":\"uint256[]\"}],\"name\":\"setDelayThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"setEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_caps\",\"type\":\"uint256[]\"}],\"name\":\"setEpochVolumeCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMaxBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"setMinBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"name\":\"setSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contractISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a06040523480156200001157600080fd5b50604051620032123803806200321283398101604081905262000034916200024f565b6200003f3362000074565b6000805460ff60a01b191690556200005733620000c4565b62000062336200018f565b6001600160a01b031660805262000281565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b03811660009081526001602052604090205460ff1615620001335760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c7265616479207061757365720000000000000060448201526064015b60405180910390fd5b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f891015b60405180910390a150565b6001600160a01b03811660009081526002602052604090205460ff1615620001fa5760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f72000000000060448201526064016200012a565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5910162000184565b6000602082840312156200026257600080fd5b81516001600160a01b03811681146200027a57600080fd5b9392505050565b608051612f6e620002a460003960008181610601015261157b0152612f6e6000f3fe608060405234801561001057600080fd5b50600436106102c85760003560e01c806382dc1ec41161017b578063bf4816f0116100d8578063eecdac881161008c578063f832138311610071578063f8321383146106a0578063f8734302146106c0578063f9a8ea08146106d357600080fd5b8063eecdac881461067a578063f2fde38b1461068d57600080fd5b8063e026049c116100bd578063e026049c14610623578063e3eece261461062b578063e43581b81461064e57600080fd5b8063bf4816f0146105e9578063ccf2683b146105fc57600080fd5b8063a00293011161012f578063b1c94d9411610114578063b1c94d94146105ad578063b4d8cedc146105b6578063b5f2bc47146105c957600080fd5b8063a00293011461052d578063adc0d57f1461054057600080fd5b80638da5cb5b116101605780638da5cb5b146104e25780639e25fc5c146105075780639e422c331461051a57600080fd5b806382dc1ec4146104c75780638456cb59146104da57600080fd5b806352532faa116102295780636b2c0f55116101dd57806379fcd8ee116101c257806379fcd8ee146104715780637f8560131461048457806380f51c12146104a457600080fd5b80636b2c0f55146104565780636ef8d66d1461046957600080fd5b806357d775f81161020e57806357d775f81461041b5780635c975abb1461042457806360216b001461043657600080fd5b806352532faa146103e857806354eea7961461040857600080fd5b80633d5721071161028057806346fbf68e1161026557806346fbf68e1461038957806347b16c6c146103b5578063497bf3b2146103c857600080fd5b80633d5721071461036e5780633f4ba83a1461038157600080fd5b806317bdbae5116102b157806317bdbae51461031a578063274cee311461032d5780633c4a25d01461035b57600080fd5b806301e64725146102cd57806315d0975c14610305575b600080fd5b6102f06102db3660046129b4565b600a6020526000908152604090205460ff1681565b60405190151581526020015b60405180910390f35b6103186103133660046129e9565b6106e6565b005b610318610328366004612a5f565b6107d7565b61034d61033b366004612acb565b600b6020526000908152604090205481565b6040519081526020016102fc565b610318610369366004612acb565b610975565b61031861037c3660046129b4565b6109ea565b610318610a7e565b6102f0610397366004612acb565b6001600160a01b031660009081526001602052604090205460ff1690565b6103186103c3366004612a5f565b610ae7565b61034d6103d6366004612acb565b600d6020526000908152604090205481565b61034d6103f6366004612acb565b60086020526000908152604090205481565b6103186104163660046129b4565b610c7e565b61034d60035481565b600054600160a01b900460ff166102f0565b61034d610444366004612acb565b60046020526000908152604090205481565b610318610464366004612acb565b610d0b565b610318610d7d565b61031861047f3660046129e9565b610d86565b61034d610492366004612acb565b600c6020526000908152604090205481565b6102f06104b2366004612acb565b60016020526000908152604090205460ff1681565b6103186104d5366004612acb565b610e17565b610318610e89565b6000546001600160a01b03165b6040516001600160a01b0390911681526020016102fc565b6103186105153660046129b4565b610ef0565b61034d610528366004612b05565b610fbd565b61034d61053b366004612b05565b611089565b61058261054e3660046129b4565b60076020526000908152604090208054600182015460028301546003909301546001600160a01b0392831693919092169184565b604080516001600160a01b0395861681529490931660208501529183015260608201526080016102fc565b61034d60095481565b6103186105c43660046129e9565b61111c565b61034d6105d7366004612acb565b60056020526000908152604090205481565b6103186105f7366004612a5f565b6111d6565b6104ef7f000000000000000000000000000000000000000000000000000000000000000081565b61031861136d565b6102f0610639366004612acb565b60026020526000908152604090205460ff1681565b6102f061065c366004612acb565b6001600160a01b031660009081526002602052604090205460ff1690565b610318610688366004612acb565b611376565b61031861069b366004612acb565b6113e8565b61034d6106ae366004612acb565b60066020526000908152604090205481565b61034d6106ce366004612b63565b6114d6565b6103186106e1366004612a5f565b611921565b336106f96000546001600160a01b031690565b6001600160a01b0316146107545760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b6001600160a01b0382166000908152600b60205260408120805483929061077c908490612c68565b90915550506001600160a01b0382166000818152600b6020908152604091829020548251938452908301527feb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e949991015b60405180910390a15050565b3360009081526002602052604090205460ff1661082f5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161074b565b8281146108705760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161074b565b60005b8381101561096e5782828281811061088d5761088d612c7f565b90506020020135600860008787858181106108aa576108aa612c7f565b90506020020160208101906108bf9190612acb565b6001600160a01b031681526020810191909152604001600020557fceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce85858381811061090c5761090c612c7f565b90506020020160208101906109219190612acb565b84848481811061093357610933612c7f565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061096681612c95565b915050610873565b5050505050565b336109886000546001600160a01b031690565b6001600160a01b0316146109de5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161074b565b6109e781611ab8565b50565b3360009081526002602052604090205460ff16610a425760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161074b565b60098190556040518181527fc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6906020015b60405180910390a150565b3360009081526001602052604090205460ff16610add5760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f7420706175736572000000000000000000000000604482015260640161074b565b610ae5611b75565b565b3360009081526002602052604090205460ff16610b3f5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161074b565b828114610b805760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161074b565b60005b8381101561096e57828282818110610b9d57610b9d612c7f565b9050602002013560056000878785818110610bba57610bba612c7f565b9050602002016020810190610bcf9190612acb565b6001600160a01b031681526020810191909152604001600020557f608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89858583818110610c1c57610c1c612c7f565b9050602002016020810190610c319190612acb565b848484818110610c4357610c43612c7f565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180610c7681612c95565b915050610b83565b3360009081526002602052604090205460ff16610cd65760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161074b565b60038190556040518181527f2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b390602001610a73565b33610d1e6000546001600160a01b031690565b6001600160a01b031614610d745760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161074b565b6109e781611c1b565b610ae533611c1b565b33610d996000546001600160a01b031690565b6001600160a01b031614610def5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161074b565b6001600160a01b0382166000908152600b60205260408120805483929061077c908490612cb0565b33610e2a6000546001600160a01b031690565b6001600160a01b031614610e805760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161074b565b6109e781611cd4565b3360009081526001602052604090205460ff16610ee85760405162461bcd60e51b815260206004820152601460248201527f43616c6c6572206973206e6f7420706175736572000000000000000000000000604482015260640161074b565b610ae5611d92565b600054600160a01b900460ff1615610f3d5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161074b565b6000610f4882611e1a565b6020810151815160408084015190516340c10f1960e01b81526001600160a01b039283166004820152602481019190915292935016906340c10f1990604401600060405180830381600087803b158015610fa157600080fd5b505af1158015610fb5573d6000803e3d6000fd5b505050505050565b60008054600160a01b900460ff161561100b5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161074b565b600061101a8787878787611fec565b60405163079cc67960e41b8152336004820152602481018890529091506001600160a01b038816906379cc6790906044015b600060405180830381600087803b15801561106657600080fd5b505af115801561107a573d6000803e3d6000fd5b50929998505050505050505050565b60008054600160a01b900460ff16156110d75760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161074b565b60006110e68787878787611fec565b604051632770a7eb60e21b8152336004820152602481018890529091506001600160a01b03881690639dc29fac9060440161104c565b3361112f6000546001600160a01b031690565b6001600160a01b0316146111855760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161074b565b6001600160a01b0382166000818152600b6020908152604091829020849055815192835282018390527feb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e949991016107cb565b3360009081526002602052604090205460ff1661122e5760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161074b565b82811461126f5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161074b565b60005b8381101561096e5782828281811061128c5761128c612c7f565b90506020020135600c60008787858181106112a9576112a9612c7f565b90506020020160208101906112be9190612acb565b6001600160a01b031681526020810191909152604001600020557f3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d0668385858381811061130b5761130b612c7f565b90506020020160208101906113209190612acb565b84848481811061133257611332612c7f565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a18061136581612c95565b915050611272565b610ae53361228c565b336113896000546001600160a01b031690565b6001600160a01b0316146113df5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161074b565b6109e78161228c565b336113fb6000546001600160a01b031690565b6001600160a01b0316146114515760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161074b565b6001600160a01b0381166114cd5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161074b565b6109e781612345565b60008054600160a01b900460ff16156115245760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161074b565b6000463060405160200161156192919091825260601b6bffffffffffffffffffffffff1916602082015263135a5b9d60e21b603482015260380190565b6040516020818303038152906040528051906020012090507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663682dbc22828c8c6040516020016115bd93929190612cc8565b6040516020818303038152906040528a8a8a8a8a8a6040518863ffffffff1660e01b81526004016115f49796959493929190612e2f565b60006040518083038186803b15801561160c57600080fd5b505afa158015611620573d6000803e3d6000fd5b5050505060006116658b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506123a292505050565b6020818101518251604080850151606080870151608088015160a089015185516bffffffffffffffffffffffff1998851b8916818b015296841b88166034880152604887019490945290821b8616606886015277ffffffffffffffffffffffffffffffffffffffffffffffff1960c09190911b16607c850152608484019190915230901b90921660a48201528151808203609801815260b890910182528051908301206000818152600a9093529120549192509060ff16156117595760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b604482015260640161074b565b6000818152600a602052604090819020805460ff191660011790558251908301516117849190612504565b81516001600160a01b031660009081526008602052604090205480158015906117b05750808360400151115b156117d2576117cd8284602001518560000151866040015161261c565b611842565b8251602084015160408086015190516340c10f1960e01b81526001600160a01b03928316600482015260248101919091529116906340c10f1990604401600060405180830381600087803b15801561182957600080fd5b505af115801561183d573d6000803e3d6000fd5b505050505b60408084015184516001600160a01b03166000908152600b602052918220805491929091611871908490612cb0565b925050819055507f5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a8284600001518560200151866040015187608001518860a00151896060015160405161190997969594939291909687526001600160a01b0395861660208801529385166040870152606086019290925267ffffffffffffffff16608085015260a08401521660c082015260e00190565b60405180910390a1509b9a5050505050505050505050565b3360009081526002602052604090205460ff166119795760405162461bcd60e51b815260206004820152601660248201527521b0b63632b91034b9903737ba1033b7bb32b93737b960511b604482015260640161074b565b8281146119ba5760405162461bcd60e51b815260206004820152600f60248201526e0d8cadccee8d040dad2e6dac2e8c6d608b1b604482015260640161074b565b60005b8381101561096e578282828181106119d7576119d7612c7f565b90506020020135600d60008787858181106119f4576119f4612c7f565b9050602002016020810190611a099190612acb565b6001600160a01b031681526020810191909152604001600020557fa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5858583818110611a5657611a56612c7f565b9050602002016020810190611a6b9190612acb565b848484818110611a7d57611a7d612c7f565b604080516001600160a01b0390951685526020918202939093013590840152500160405180910390a180611ab081612c95565b9150506119bd565b6001600160a01b03811660009081526002602052604090205460ff1615611b215760405162461bcd60e51b815260206004820152601b60248201527f4163636f756e7420697320616c726561647920676f7665726e6f720000000000604482015260640161074b565b6001600160a01b038116600081815260026020908152604091829020805460ff1916600117905590519182527fdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b59101610a73565b600054600160a01b900460ff16611bce5760405162461bcd60e51b815260206004820152601460248201527f5061757361626c653a206e6f7420706175736564000000000000000000000000604482015260640161074b565b6000805460ff60a01b191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b6001600160a01b03811660009081526001602052604090205460ff16611c835760405162461bcd60e51b815260206004820152601560248201527f4163636f756e74206973206e6f74207061757365720000000000000000000000604482015260640161074b565b6001600160a01b038116600081815260016020908152604091829020805460ff1916905590519182527fcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e9101610a73565b6001600160a01b03811660009081526001602052604090205460ff1615611d3d5760405162461bcd60e51b815260206004820152601960248201527f4163636f756e7420697320616c72656164792070617573657200000000000000604482015260640161074b565b6001600160a01b038116600081815260016020818152604092839020805460ff191690921790915590519182527f6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f89101610a73565b600054600160a01b900460ff1615611ddf5760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161074b565b6000805460ff60a01b1916600160a01b1790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258611bfe3390565b604080516080810182526000808252602082018190529181018290526060810191909152600082815260076020908152604091829020825160808101845281546001600160a01b0390811682526001830154169281019290925260028101549282019290925260039091015460608201819052611ed95760405162461bcd60e51b815260206004820152601a60248201527f64656c61796564207472616e73666572206e6f74206578697374000000000000604482015260640161074b565b6009548160600151611eeb9190612cb0565b4211611f395760405162461bcd60e51b815260206004820152601d60248201527f64656c61796564207472616e73666572207374696c6c206c6f636b6564000000604482015260640161074b565b6000838152600760209081526040808320805473ffffffffffffffffffffffffffffffffffffffff199081168255600182018054909116905560028101849055600301929092558251908301518383015192517f3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d442693611fde93889390929091909384526001600160a01b03928316602085015291166040830152606082015260800190565b60405180910390a192915050565b6001600160a01b0385166000908152600c602052604081205485116120535760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f20736d616c6c00000000000000000000000000000000604482015260640161074b565b6001600160a01b0386166000908152600d6020526040902054158061209057506001600160a01b0386166000908152600d60205260409020548511155b6120dc5760405162461bcd60e51b815260206004820152601060248201527f616d6f756e7420746f6f206c6172676500000000000000000000000000000000604482015260640161074b565b6001600160a01b0386166000908152600b602052604081208054879290612104908490612c68565b90915550506040516bffffffffffffffffffffffff1933606090811b8216602084015288811b821660348401526048830188905277ffffffffffffffffffffffffffffffffffffffffffffffff1960c088811b8216606886015287831b8416607086015286811b8216608486015246901b16608c84015230901b16609482015260009060a80160408051601f1981840301815291815281516020928301206000818152600a90935291205490915060ff16156121f25760405162461bcd60e51b815260206004820152600d60248201526c7265636f72642065786973747360981b604482015260640161074b565b6000818152600a6020908152604091829020805460ff1916600117905581518381526001600160a01b038a81169282019290925233928101929092526060820188905267ffffffffffffffff878116608084015290861660a0830152841660c08201527f6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a39060e00160405180910390a19695505050505050565b6001600160a01b03811660009081526002602052604090205460ff166122f45760405162461bcd60e51b815260206004820152601760248201527f4163636f756e74206973206e6f7420676f7665726e6f72000000000000000000604482015260640161074b565b6001600160a01b038116600081815260026020908152604091829020805460ff1916905590519182527f1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b9101610a73565b600080546001600160a01b0383811673ffffffffffffffffffffffffffffffffffffffff19831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6040805160c08101825260008082526020808301829052828401829052606083018290526080830182905260a0830182905283518085019094528184528301849052909190805b602083015151835110156124fc576124008361273c565b9092509050816001141561242f5761241f61241a84612776565b612833565b6001600160a01b031684526123e9565b81600214156124575761244461241a84612776565b6001600160a01b031660208501526123e9565b816003141561247b5761247161246c84612776565b612844565b60408501526123e9565b81600414156124a35761249061241a84612776565b6001600160a01b031660608501526123e9565b81600514156124c9576124b58361287b565b67ffffffffffffffff1660808501526123e9565b81600614156124ed576124e36124de84612776565b6128fd565b60a08501526123e9565b6124f78382612915565b6123e9565b505050919050565b60035461250f575050565b6001600160a01b0382166000908152600560205260409020548061253257505050565b6001600160a01b0383166000908152600460205260408120546003549091429161255c8184612ecb565b6125669190612eed565b6001600160a01b0387166000908152600660205260409020549091508111156125915784925061259e565b61259b8584612cb0565b92505b838311156125ee5760405162461bcd60e51b815260206004820152601260248201527f766f6c756d652065786365656473206361700000000000000000000000000000604482015260640161074b565b506001600160a01b039094166000908152600460209081526040808320939093556006905220929092555050565b6000848152600760205260409020600301541561267b5760405162461bcd60e51b815260206004820152601f60248201527f64656c61796564207472616e7366657220616c72656164792065786973747300604482015260640161074b565b604080516080810182526001600160a01b0380861682528481166020808401918252838501868152426060860190815260008b81526007909352918690209451855490851673ffffffffffffffffffffffffffffffffffffffff1991821617865592516001860180549190951693169290921790925551600283015551600390910155517fcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce69061272e9086815260200190565b60405180910390a150505050565b600080600061274a8461287b565b9050612757600882612ecb565b925080600716600581111561276e5761276e612f0c565b915050915091565b606060006127838361287b565b905060008184600001516127979190612cb0565b90508360200151518111156127ab57600080fd5b8167ffffffffffffffff8111156127c4576127c4612f22565b6040519080825280601f01601f1916602001820160405280156127ee576020820181803683370190505b50602080860151865192955091818601919083010160005b85811015612828578181015183820152612821602082612cb0565b9050612806565b505050935250919050565b600061283e8261298c565b92915050565b600060208251111561285557600080fd5b602082015190508151602061286a9190612c68565b612875906008612eed565b1c919050565b602080820151825181019091015160009182805b600a8110156128f75783811a91506128a8816007612eed565b82607f16901b8517945081608016600014156128e5576128c9816001612cb0565b865187906128d8908390612cb0565b9052509395945050505050565b806128ef81612c95565b91505061288f565b50600080fd5b6000815160201461290d57600080fd5b506020015190565b600081600581111561292957612929612f0c565b141561293d576129388261287b565b505050565b600281600581111561295157612951612f0c565b14156102c85760006129628361287b565b905080836000018181516129769190612cb0565b9052506020830151518351111561293857600080fd5b6000815160141461299c57600080fd5b50602001516c01000000000000000000000000900490565b6000602082840312156129c657600080fd5b5035919050565b80356001600160a01b03811681146129e457600080fd5b919050565b600080604083850312156129fc57600080fd5b612a05836129cd565b946020939093013593505050565b60008083601f840112612a2557600080fd5b50813567ffffffffffffffff811115612a3d57600080fd5b6020830191508360208260051b8501011115612a5857600080fd5b9250929050565b60008060008060408587031215612a7557600080fd5b843567ffffffffffffffff80821115612a8d57600080fd5b612a9988838901612a13565b90965094506020870135915080821115612ab257600080fd5b50612abf87828801612a13565b95989497509550505050565b600060208284031215612add57600080fd5b612ae6826129cd565b9392505050565b803567ffffffffffffffff811681146129e457600080fd5b600080600080600060a08688031215612b1d57600080fd5b612b26866129cd565b945060208601359350612b3b60408701612aed565b9250612b49606087016129cd565b9150612b5760808701612aed565b90509295509295909350565b6000806000806000806000806080898b031215612b7f57600080fd5b883567ffffffffffffffff80821115612b9757600080fd5b818b0191508b601f830112612bab57600080fd5b813581811115612bba57600080fd5b8c6020828501011115612bcc57600080fd5b60209283019a509850908a01359080821115612be757600080fd5b612bf38c838d01612a13565b909850965060408b0135915080821115612c0c57600080fd5b612c188c838d01612a13565b909650945060608b0135915080821115612c3157600080fd5b50612c3e8b828c01612a13565b999c989b5096995094979396929594505050565b634e487b7160e01b600052601160045260246000fd5b600082821015612c7a57612c7a612c52565b500390565b634e487b7160e01b600052603260045260246000fd5b6000600019821415612ca957612ca9612c52565b5060010190565b60008219821115612cc357612cc3612c52565b500190565b838152818360208301376000910160200190815292915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b818352600060208085019450848460051b86018460005b87811015612d8c5783830389528135601e19883603018112612d4357600080fd5b8701803567ffffffffffffffff811115612d5c57600080fd5b803603891315612d6b57600080fd5b612d788582898501612ce2565b9a87019a9450505090840190600101612d22565b5090979650505050505050565b8183526000602080850194508260005b85811015612dd5576001600160a01b03612dc2836129cd565b1687529582019590820190600101612da9565b509495945050505050565b81835260007f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115612e1257600080fd5b8260051b8083602087013760009401602001938452509192915050565b608081526000885180608084015260005b81811015612e5d576020818c0181015160a0868401015201612e40565b81811115612e6f57600060a083860101525b50601f01601f1916820182810360a09081016020850152612e93908201898b612d0b565b90508281036040840152612ea8818789612d99565b90508281036060840152612ebd818587612de0565b9a9950505050505050505050565b600082612ee857634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615612f0757612f07612c52565b500290565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220fce3f8342c074e889861ce30191b4eec5b6a14855707d36d231398397a5694b864736f6c63430008090033",
}

// PeggedTokenBridgeV2ABI is the input ABI used to generate the binding from.
// Deprecated: Use PeggedTokenBridgeV2MetaData.ABI instead.
var PeggedTokenBridgeV2ABI = PeggedTokenBridgeV2MetaData.ABI

// PeggedTokenBridgeV2Bin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use PeggedTokenBridgeV2MetaData.Bin instead.
var PeggedTokenBridgeV2Bin = PeggedTokenBridgeV2MetaData.Bin

// DeployPeggedTokenBridgeV2 deploys a new Ethereum contract, binding an instance of PeggedTokenBridgeV2 to it.
func DeployPeggedTokenBridgeV2(auth *bind.TransactOpts, backend bind.ContractBackend, _sigsVerifier common.Address) (common.Address, *types.Transaction, *PeggedTokenBridgeV2, error) {
	parsed, err := PeggedTokenBridgeV2MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(PeggedTokenBridgeV2Bin), backend, _sigsVerifier)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PeggedTokenBridgeV2{PeggedTokenBridgeV2Caller: PeggedTokenBridgeV2Caller{contract: contract}, PeggedTokenBridgeV2Transactor: PeggedTokenBridgeV2Transactor{contract: contract}, PeggedTokenBridgeV2Filterer: PeggedTokenBridgeV2Filterer{contract: contract}}, nil
}

// PeggedTokenBridgeV2 is an auto generated Go binding around an Ethereum contract.
type PeggedTokenBridgeV2 struct {
	PeggedTokenBridgeV2Caller     // Read-only binding to the contract
	PeggedTokenBridgeV2Transactor // Write-only binding to the contract
	PeggedTokenBridgeV2Filterer   // Log filterer for contract events
}

// PeggedTokenBridgeV2Caller is an auto generated read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeV2Transactor is an auto generated write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeV2Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PeggedTokenBridgeV2Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PeggedTokenBridgeV2Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PeggedTokenBridgeV2Session struct {
	Contract     *PeggedTokenBridgeV2 // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeV2CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PeggedTokenBridgeV2CallerSession struct {
	Contract *PeggedTokenBridgeV2Caller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// PeggedTokenBridgeV2TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PeggedTokenBridgeV2TransactorSession struct {
	Contract     *PeggedTokenBridgeV2Transactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// PeggedTokenBridgeV2Raw is an auto generated low-level Go binding around an Ethereum contract.
type PeggedTokenBridgeV2Raw struct {
	Contract *PeggedTokenBridgeV2 // Generic contract binding to access the raw methods on
}

// PeggedTokenBridgeV2CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2CallerRaw struct {
	Contract *PeggedTokenBridgeV2Caller // Generic read-only contract binding to access the raw methods on
}

// PeggedTokenBridgeV2TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PeggedTokenBridgeV2TransactorRaw struct {
	Contract *PeggedTokenBridgeV2Transactor // Generic write-only contract binding to access the raw methods on
}

// NewPeggedTokenBridgeV2 creates a new instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2(address common.Address, backend bind.ContractBackend) (*PeggedTokenBridgeV2, error) {
	contract, err := bindPeggedTokenBridgeV2(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2{PeggedTokenBridgeV2Caller: PeggedTokenBridgeV2Caller{contract: contract}, PeggedTokenBridgeV2Transactor: PeggedTokenBridgeV2Transactor{contract: contract}, PeggedTokenBridgeV2Filterer: PeggedTokenBridgeV2Filterer{contract: contract}}, nil
}

// NewPeggedTokenBridgeV2Caller creates a new read-only instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2Caller(address common.Address, caller bind.ContractCaller) (*PeggedTokenBridgeV2Caller, error) {
	contract, err := bindPeggedTokenBridgeV2(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2Caller{contract: contract}, nil
}

// NewPeggedTokenBridgeV2Transactor creates a new write-only instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2Transactor(address common.Address, transactor bind.ContractTransactor) (*PeggedTokenBridgeV2Transactor, error) {
	contract, err := bindPeggedTokenBridgeV2(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2Transactor{contract: contract}, nil
}

// NewPeggedTokenBridgeV2Filterer creates a new log filterer instance of PeggedTokenBridgeV2, bound to a specific deployed contract.
func NewPeggedTokenBridgeV2Filterer(address common.Address, filterer bind.ContractFilterer) (*PeggedTokenBridgeV2Filterer, error) {
	contract, err := bindPeggedTokenBridgeV2(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2Filterer{contract: contract}, nil
}

// bindPeggedTokenBridgeV2 binds a generic wrapper to an already deployed contract.
func bindPeggedTokenBridgeV2(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PeggedTokenBridgeV2ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridgeV2.Contract.PeggedTokenBridgeV2Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.PeggedTokenBridgeV2Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.PeggedTokenBridgeV2Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _PeggedTokenBridgeV2.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.contract.Transact(opts, method, params...)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) DelayPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "delayPeriod")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayPeriod(&_PeggedTokenBridgeV2.CallOpts)
}

// DelayPeriod is a free data retrieval call binding the contract method 0xb1c94d94.
//
// Solidity: function delayPeriod() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) DelayPeriod() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayPeriod(&_PeggedTokenBridgeV2.CallOpts)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) DelayThresholds(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "delayThresholds", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayThresholds(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// DelayThresholds is a free data retrieval call binding the contract method 0x52532faa.
//
// Solidity: function delayThresholds(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) DelayThresholds(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.DelayThresholds(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) DelayedTransfers(opts *bind.CallOpts, arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "delayedTransfers", arg0)

	outstruct := new(struct {
		Receiver  common.Address
		Token     common.Address
		Amount    *big.Int
		Timestamp *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Receiver = *abi.ConvertType(out[0], new(common.Address)).(*common.Address)
	outstruct.Token = *abi.ConvertType(out[1], new(common.Address)).(*common.Address)
	outstruct.Amount = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.Timestamp = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridgeV2.Contract.DelayedTransfers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// DelayedTransfers is a free data retrieval call binding the contract method 0xadc0d57f.
//
// Solidity: function delayedTransfers(bytes32 ) view returns(address receiver, address token, uint256 amount, uint256 timestamp)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) DelayedTransfers(arg0 [32]byte) (struct {
	Receiver  common.Address
	Token     common.Address
	Amount    *big.Int
	Timestamp *big.Int
}, error) {
	return _PeggedTokenBridgeV2.Contract.DelayedTransfers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) EpochLength(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "epochLength")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochLength(&_PeggedTokenBridgeV2.CallOpts)
}

// EpochLength is a free data retrieval call binding the contract method 0x57d775f8.
//
// Solidity: function epochLength() view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) EpochLength() (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochLength(&_PeggedTokenBridgeV2.CallOpts)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) EpochVolumeCaps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "epochVolumeCaps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumeCaps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochVolumeCaps is a free data retrieval call binding the contract method 0xb5f2bc47.
//
// Solidity: function epochVolumeCaps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) EpochVolumeCaps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumeCaps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) EpochVolumes(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "epochVolumes", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumes(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// EpochVolumes is a free data retrieval call binding the contract method 0x60216b00.
//
// Solidity: function epochVolumes(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) EpochVolumes(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.EpochVolumes(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Governors(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "governors", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Governors(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Governors is a free data retrieval call binding the contract method 0xe3eece26.
//
// Solidity: function governors(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Governors(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Governors(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) IsGovernor(opts *bind.CallOpts, _account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "isGovernor", _account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsGovernor(&_PeggedTokenBridgeV2.CallOpts, _account)
}

// IsGovernor is a free data retrieval call binding the contract method 0xe43581b8.
//
// Solidity: function isGovernor(address _account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) IsGovernor(_account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsGovernor(&_PeggedTokenBridgeV2.CallOpts, _account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) IsPauser(opts *bind.CallOpts, account common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "isPauser", account)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsPauser(&_PeggedTokenBridgeV2.CallOpts, account)
}

// IsPauser is a free data retrieval call binding the contract method 0x46fbf68e.
//
// Solidity: function isPauser(address account) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) IsPauser(account common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.IsPauser(&_PeggedTokenBridgeV2.CallOpts, account)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) LastOpTimestamps(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "lastOpTimestamps", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.LastOpTimestamps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// LastOpTimestamps is a free data retrieval call binding the contract method 0xf8321383.
//
// Solidity: function lastOpTimestamps(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) LastOpTimestamps(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.LastOpTimestamps(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) MaxBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "maxBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MaxBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MaxBurn is a free data retrieval call binding the contract method 0x497bf3b2.
//
// Solidity: function maxBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) MaxBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MaxBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) MinBurn(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "minBurn", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MinBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// MinBurn is a free data retrieval call binding the contract method 0x7f856013.
//
// Solidity: function minBurn(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) MinBurn(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.MinBurn(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Owner() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.Owner(&_PeggedTokenBridgeV2.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Owner() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.Owner(&_PeggedTokenBridgeV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Paused() (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Paused(&_PeggedTokenBridgeV2.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Paused() (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Paused(&_PeggedTokenBridgeV2.CallOpts)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Pausers(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "pausers", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Pausers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Pausers is a free data retrieval call binding the contract method 0x80f51c12.
//
// Solidity: function pausers(address ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Pausers(arg0 common.Address) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Pausers(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Records(opts *bind.CallOpts, arg0 [32]byte) (bool, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "records", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Records(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Records is a free data retrieval call binding the contract method 0x01e64725.
//
// Solidity: function records(bytes32 ) view returns(bool)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Records(arg0 [32]byte) (bool, error) {
	return _PeggedTokenBridgeV2.Contract.Records(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) SigsVerifier(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "sigsVerifier")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.SigsVerifier(&_PeggedTokenBridgeV2.CallOpts)
}

// SigsVerifier is a free data retrieval call binding the contract method 0xccf2683b.
//
// Solidity: function sigsVerifier() view returns(address)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) SigsVerifier() (common.Address, error) {
	return _PeggedTokenBridgeV2.Contract.SigsVerifier(&_PeggedTokenBridgeV2.CallOpts)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Caller) Supplies(opts *bind.CallOpts, arg0 common.Address) (*big.Int, error) {
	var out []interface{}
	err := _PeggedTokenBridgeV2.contract.Call(opts, &out, "supplies", arg0)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.Supplies(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// Supplies is a free data retrieval call binding the contract method 0x274cee31.
//
// Solidity: function supplies(address ) view returns(uint256)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2CallerSession) Supplies(arg0 common.Address) (*big.Int, error) {
	return _PeggedTokenBridgeV2.Contract.Supplies(&_PeggedTokenBridgeV2.CallOpts, arg0)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) AddGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "addGovernor", _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// AddGovernor is a paid mutator transaction binding the contract method 0x3c4a25d0.
//
// Solidity: function addGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) AddGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) AddPauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "addPauser", account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddPauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// AddPauser is a paid mutator transaction binding the contract method 0x82dc1ec4.
//
// Solidity: function addPauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) AddPauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.AddPauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Burn(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "burn", _token, _amount, _toChainId, _toAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Burn(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// Burn is a paid mutator transaction binding the contract method 0xa0029301.
//
// Solidity: function burn(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Burn(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Burn(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x9e422c33.
//
// Solidity: function burnFrom(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) BurnFrom(opts *bind.TransactOpts, _token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "burnFrom", _token, _amount, _toChainId, _toAccount, _nonce)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x9e422c33.
//
// Solidity: function burnFrom(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) BurnFrom(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.BurnFrom(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x9e422c33.
//
// Solidity: function burnFrom(address _token, uint256 _amount, uint64 _toChainId, address _toAccount, uint64 _nonce) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) BurnFrom(_token common.Address, _amount *big.Int, _toChainId uint64, _toAccount common.Address, _nonce uint64) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.BurnFrom(&_PeggedTokenBridgeV2.TransactOpts, _token, _amount, _toChainId, _toAccount, _nonce)
}

// DecreaseSupply is a paid mutator transaction binding the contract method 0x15d0975c.
//
// Solidity: function decreaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) DecreaseSupply(opts *bind.TransactOpts, _token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "decreaseSupply", _token, _delta)
}

// DecreaseSupply is a paid mutator transaction binding the contract method 0x15d0975c.
//
// Solidity: function decreaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) DecreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.DecreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// DecreaseSupply is a paid mutator transaction binding the contract method 0x15d0975c.
//
// Solidity: function decreaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) DecreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.DecreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) ExecuteDelayedTransfer(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "executeDelayedTransfer", id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridgeV2.TransactOpts, id)
}

// ExecuteDelayedTransfer is a paid mutator transaction binding the contract method 0x9e25fc5c.
//
// Solidity: function executeDelayedTransfer(bytes32 id) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) ExecuteDelayedTransfer(id [32]byte) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.ExecuteDelayedTransfer(&_PeggedTokenBridgeV2.TransactOpts, id)
}

// IncreaseSupply is a paid mutator transaction binding the contract method 0x79fcd8ee.
//
// Solidity: function increaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) IncreaseSupply(opts *bind.TransactOpts, _token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "increaseSupply", _token, _delta)
}

// IncreaseSupply is a paid mutator transaction binding the contract method 0x79fcd8ee.
//
// Solidity: function increaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) IncreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.IncreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// IncreaseSupply is a paid mutator transaction binding the contract method 0x79fcd8ee.
//
// Solidity: function increaseSupply(address _token, uint256 _delta) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) IncreaseSupply(_token common.Address, _delta *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.IncreaseSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _delta)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Mint(opts *bind.TransactOpts, _request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "mint", _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Mint(&_PeggedTokenBridgeV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Mint is a paid mutator transaction binding the contract method 0xf8734302.
//
// Solidity: function mint(bytes _request, bytes[] _sigs, address[] _signers, uint256[] _powers) returns(bytes32)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Mint(_request []byte, _sigs [][]byte, _signers []common.Address, _powers []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Mint(&_PeggedTokenBridgeV2.TransactOpts, _request, _sigs, _signers, _powers)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Pause(&_PeggedTokenBridgeV2.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Pause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Pause(&_PeggedTokenBridgeV2.TransactOpts)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RemoveGovernor(opts *bind.TransactOpts, _account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "removeGovernor", _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemoveGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// RemoveGovernor is a paid mutator transaction binding the contract method 0xeecdac88.
//
// Solidity: function removeGovernor(address _account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RemoveGovernor(_account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemoveGovernor(&_PeggedTokenBridgeV2.TransactOpts, _account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RemovePauser(opts *bind.TransactOpts, account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "removePauser", account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemovePauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// RemovePauser is a paid mutator transaction binding the contract method 0x6b2c0f55.
//
// Solidity: function removePauser(address account) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RemovePauser(account common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RemovePauser(&_PeggedTokenBridgeV2.TransactOpts, account)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RenounceGovernor(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "renounceGovernor")
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenounceGovernor(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenounceGovernor is a paid mutator transaction binding the contract method 0xe026049c.
//
// Solidity: function renounceGovernor() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RenounceGovernor() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenounceGovernor(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) RenouncePauser(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "renouncePauser")
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenouncePauser(&_PeggedTokenBridgeV2.TransactOpts)
}

// RenouncePauser is a paid mutator transaction binding the contract method 0x6ef8d66d.
//
// Solidity: function renouncePauser() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) RenouncePauser() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.RenouncePauser(&_PeggedTokenBridgeV2.TransactOpts)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetDelayPeriod(opts *bind.TransactOpts, _period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setDelayPeriod", _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayPeriod(&_PeggedTokenBridgeV2.TransactOpts, _period)
}

// SetDelayPeriod is a paid mutator transaction binding the contract method 0x3d572107.
//
// Solidity: function setDelayPeriod(uint256 _period) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetDelayPeriod(_period *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayPeriod(&_PeggedTokenBridgeV2.TransactOpts, _period)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetDelayThresholds(opts *bind.TransactOpts, _tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setDelayThresholds", _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayThresholds(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _thresholds)
}

// SetDelayThresholds is a paid mutator transaction binding the contract method 0x17bdbae5.
//
// Solidity: function setDelayThresholds(address[] _tokens, uint256[] _thresholds) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetDelayThresholds(_tokens []common.Address, _thresholds []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetDelayThresholds(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _thresholds)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetEpochLength(opts *bind.TransactOpts, _length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setEpochLength", _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochLength(&_PeggedTokenBridgeV2.TransactOpts, _length)
}

// SetEpochLength is a paid mutator transaction binding the contract method 0x54eea796.
//
// Solidity: function setEpochLength(uint256 _length) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetEpochLength(_length *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochLength(&_PeggedTokenBridgeV2.TransactOpts, _length)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetEpochVolumeCaps(opts *bind.TransactOpts, _tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setEpochVolumeCaps", _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochVolumeCaps(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _caps)
}

// SetEpochVolumeCaps is a paid mutator transaction binding the contract method 0x47b16c6c.
//
// Solidity: function setEpochVolumeCaps(address[] _tokens, uint256[] _caps) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetEpochVolumeCaps(_tokens []common.Address, _caps []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetEpochVolumeCaps(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _caps)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetMaxBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setMaxBurn", _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMaxBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetMaxBurn is a paid mutator transaction binding the contract method 0xf9a8ea08.
//
// Solidity: function setMaxBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetMaxBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMaxBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetMinBurn(opts *bind.TransactOpts, _tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setMinBurn", _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMinBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetMinBurn is a paid mutator transaction binding the contract method 0xbf4816f0.
//
// Solidity: function setMinBurn(address[] _tokens, uint256[] _amounts) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetMinBurn(_tokens []common.Address, _amounts []*big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetMinBurn(&_PeggedTokenBridgeV2.TransactOpts, _tokens, _amounts)
}

// SetSupply is a paid mutator transaction binding the contract method 0xb4d8cedc.
//
// Solidity: function setSupply(address _token, uint256 _supply) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) SetSupply(opts *bind.TransactOpts, _token common.Address, _supply *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "setSupply", _token, _supply)
}

// SetSupply is a paid mutator transaction binding the contract method 0xb4d8cedc.
//
// Solidity: function setSupply(address _token, uint256 _supply) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) SetSupply(_token common.Address, _supply *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _supply)
}

// SetSupply is a paid mutator transaction binding the contract method 0xb4d8cedc.
//
// Solidity: function setSupply(address _token, uint256 _supply) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) SetSupply(_token common.Address, _supply *big.Int) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.SetSupply(&_PeggedTokenBridgeV2.TransactOpts, _token, _supply)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.TransferOwnership(&_PeggedTokenBridgeV2.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.TransferOwnership(&_PeggedTokenBridgeV2.TransactOpts, newOwner)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Transactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Session) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Unpause(&_PeggedTokenBridgeV2.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2TransactorSession) Unpause() (*types.Transaction, error) {
	return _PeggedTokenBridgeV2.Contract.Unpause(&_PeggedTokenBridgeV2.TransactOpts)
}

// PeggedTokenBridgeV2BurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2BurnIterator struct {
	Event *PeggedTokenBridgeV2Burn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2BurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Burn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Burn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2BurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2BurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Burn represents a Burn event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Burn struct {
	BurnId    [32]byte
	Token     common.Address
	Account   common.Address
	Amount    *big.Int
	ToChainId uint64
	ToAccount common.Address
	Nonce     uint64
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0x6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a3.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, uint64 toChainId, address toAccount, uint64 nonce)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterBurn(opts *bind.FilterOpts) (*PeggedTokenBridgeV2BurnIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2BurnIterator{contract: _PeggedTokenBridgeV2.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0x6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a3.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, uint64 toChainId, address toAccount, uint64 nonce)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Burn) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Burn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Burn)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0x6298d7b58f235730b3b399dc5c282f15dae8b022e5fbbf89cee21fd83c8810a3.
//
// Solidity: event Burn(bytes32 burnId, address token, address account, uint256 amount, uint64 toChainId, address toAccount, uint64 nonce)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseBurn(log types.Log) (*PeggedTokenBridgeV2Burn, error) {
	event := new(PeggedTokenBridgeV2Burn)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayPeriodUpdatedIterator is returned from FilterDelayPeriodUpdated and is used to iterate over the raw logs and unpacked data for DelayPeriodUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayPeriodUpdatedIterator struct {
	Event *PeggedTokenBridgeV2DelayPeriodUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayPeriodUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayPeriodUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayPeriodUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayPeriodUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayPeriodUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayPeriodUpdated represents a DelayPeriodUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayPeriodUpdated struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDelayPeriodUpdated is a free log retrieval operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayPeriodUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayPeriodUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayPeriodUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayPeriodUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayPeriodUpdated is a free log subscription operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayPeriodUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayPeriodUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayPeriodUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayPeriodUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayPeriodUpdated is a log parse operation binding the contract event 0xc0a39f234199b125fb93713c4d067bdcebbf691087f87b79c0feb92b156ba8b6.
//
// Solidity: event DelayPeriodUpdated(uint256 period)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayPeriodUpdated(log types.Log) (*PeggedTokenBridgeV2DelayPeriodUpdated, error) {
	event := new(PeggedTokenBridgeV2DelayPeriodUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayPeriodUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayThresholdUpdatedIterator is returned from FilterDelayThresholdUpdated and is used to iterate over the raw logs and unpacked data for DelayThresholdUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayThresholdUpdatedIterator struct {
	Event *PeggedTokenBridgeV2DelayThresholdUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayThresholdUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayThresholdUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayThresholdUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayThresholdUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayThresholdUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayThresholdUpdated represents a DelayThresholdUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayThresholdUpdated struct {
	Token     common.Address
	Threshold *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterDelayThresholdUpdated is a free log retrieval operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayThresholdUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayThresholdUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayThresholdUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayThresholdUpdated", logs: logs, sub: sub}, nil
}

// WatchDelayThresholdUpdated is a free log subscription operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayThresholdUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayThresholdUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayThresholdUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayThresholdUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayThresholdUpdated is a log parse operation binding the contract event 0xceaad6533bfb481492fb3e08ef19297f46611b8fa9de5ef4cf8dc23a56ad09ce.
//
// Solidity: event DelayThresholdUpdated(address token, uint256 threshold)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayThresholdUpdated(log types.Log) (*PeggedTokenBridgeV2DelayThresholdUpdated, error) {
	event := new(PeggedTokenBridgeV2DelayThresholdUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayThresholdUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayedTransferAddedIterator is returned from FilterDelayedTransferAdded and is used to iterate over the raw logs and unpacked data for DelayedTransferAdded events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferAddedIterator struct {
	Event *PeggedTokenBridgeV2DelayedTransferAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayedTransferAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayedTransferAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayedTransferAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayedTransferAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayedTransferAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayedTransferAdded represents a DelayedTransferAdded event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferAdded struct {
	Id  [32]byte
	Raw types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferAdded is a free log retrieval operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayedTransferAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayedTransferAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayedTransferAddedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayedTransferAdded", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferAdded is a free log subscription operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayedTransferAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayedTransferAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayedTransferAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayedTransferAdded)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferAdded is a log parse operation binding the contract event 0xcbcfffe5102114216a85d3aceb14ad4b81a3935b1b5c468fadf3889eb9c5dce6.
//
// Solidity: event DelayedTransferAdded(bytes32 id)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayedTransferAdded(log types.Log) (*PeggedTokenBridgeV2DelayedTransferAdded, error) {
	event := new(PeggedTokenBridgeV2DelayedTransferAdded)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2DelayedTransferExecutedIterator is returned from FilterDelayedTransferExecuted and is used to iterate over the raw logs and unpacked data for DelayedTransferExecuted events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferExecutedIterator struct {
	Event *PeggedTokenBridgeV2DelayedTransferExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2DelayedTransferExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2DelayedTransferExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2DelayedTransferExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2DelayedTransferExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2DelayedTransferExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2DelayedTransferExecuted represents a DelayedTransferExecuted event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2DelayedTransferExecuted struct {
	Id       [32]byte
	Receiver common.Address
	Token    common.Address
	Amount   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelayedTransferExecuted is a free log retrieval operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterDelayedTransferExecuted(opts *bind.FilterOpts) (*PeggedTokenBridgeV2DelayedTransferExecutedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2DelayedTransferExecutedIterator{contract: _PeggedTokenBridgeV2.contract, event: "DelayedTransferExecuted", logs: logs, sub: sub}, nil
}

// WatchDelayedTransferExecuted is a free log subscription operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchDelayedTransferExecuted(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2DelayedTransferExecuted) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "DelayedTransferExecuted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2DelayedTransferExecuted)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelayedTransferExecuted is a log parse operation binding the contract event 0x3b40e5089937425d14cdd96947e5661868357e224af59bd8b24a4b8a330d4426.
//
// Solidity: event DelayedTransferExecuted(bytes32 id, address receiver, address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseDelayedTransferExecuted(log types.Log) (*PeggedTokenBridgeV2DelayedTransferExecuted, error) {
	event := new(PeggedTokenBridgeV2DelayedTransferExecuted)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "DelayedTransferExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2EpochLengthUpdatedIterator is returned from FilterEpochLengthUpdated and is used to iterate over the raw logs and unpacked data for EpochLengthUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochLengthUpdatedIterator struct {
	Event *PeggedTokenBridgeV2EpochLengthUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2EpochLengthUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2EpochLengthUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2EpochLengthUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2EpochLengthUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2EpochLengthUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2EpochLengthUpdated represents a EpochLengthUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochLengthUpdated struct {
	Length *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterEpochLengthUpdated is a free log retrieval operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterEpochLengthUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2EpochLengthUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2EpochLengthUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "EpochLengthUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochLengthUpdated is a free log subscription operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchEpochLengthUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2EpochLengthUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "EpochLengthUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2EpochLengthUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochLengthUpdated is a log parse operation binding the contract event 0x2664fec2ff76486ac58ed087310855b648b15b9d19f3de8529e95f7c46b7d6b3.
//
// Solidity: event EpochLengthUpdated(uint256 length)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseEpochLengthUpdated(log types.Log) (*PeggedTokenBridgeV2EpochLengthUpdated, error) {
	event := new(PeggedTokenBridgeV2EpochLengthUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochLengthUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2EpochVolumeUpdatedIterator is returned from FilterEpochVolumeUpdated and is used to iterate over the raw logs and unpacked data for EpochVolumeUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochVolumeUpdatedIterator struct {
	Event *PeggedTokenBridgeV2EpochVolumeUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2EpochVolumeUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2EpochVolumeUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2EpochVolumeUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2EpochVolumeUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2EpochVolumeUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2EpochVolumeUpdated represents a EpochVolumeUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2EpochVolumeUpdated struct {
	Token common.Address
	Cap   *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterEpochVolumeUpdated is a free log retrieval operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterEpochVolumeUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2EpochVolumeUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2EpochVolumeUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "EpochVolumeUpdated", logs: logs, sub: sub}, nil
}

// WatchEpochVolumeUpdated is a free log subscription operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchEpochVolumeUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2EpochVolumeUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "EpochVolumeUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2EpochVolumeUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEpochVolumeUpdated is a log parse operation binding the contract event 0x608e49c22994f20b5d3496dca088b88dfd81b4a3e8cc3809ea1e10a320107e89.
//
// Solidity: event EpochVolumeUpdated(address token, uint256 cap)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseEpochVolumeUpdated(log types.Log) (*PeggedTokenBridgeV2EpochVolumeUpdated, error) {
	event := new(PeggedTokenBridgeV2EpochVolumeUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "EpochVolumeUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2GovernorAddedIterator is returned from FilterGovernorAdded and is used to iterate over the raw logs and unpacked data for GovernorAdded events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorAddedIterator struct {
	Event *PeggedTokenBridgeV2GovernorAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2GovernorAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2GovernorAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2GovernorAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2GovernorAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2GovernorAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2GovernorAdded represents a GovernorAdded event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorAdded is a free log retrieval operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterGovernorAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeV2GovernorAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2GovernorAddedIterator{contract: _PeggedTokenBridgeV2.contract, event: "GovernorAdded", logs: logs, sub: sub}, nil
}

// WatchGovernorAdded is a free log subscription operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchGovernorAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2GovernorAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "GovernorAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2GovernorAdded)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorAdded is a log parse operation binding the contract event 0xdc5a48d79e2e147530ff63ecdbed5a5a66adb9d5cf339384d5d076da197c40b5.
//
// Solidity: event GovernorAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseGovernorAdded(log types.Log) (*PeggedTokenBridgeV2GovernorAdded, error) {
	event := new(PeggedTokenBridgeV2GovernorAdded)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2GovernorRemovedIterator is returned from FilterGovernorRemoved and is used to iterate over the raw logs and unpacked data for GovernorRemoved events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorRemovedIterator struct {
	Event *PeggedTokenBridgeV2GovernorRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2GovernorRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2GovernorRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2GovernorRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2GovernorRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2GovernorRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2GovernorRemoved represents a GovernorRemoved event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2GovernorRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGovernorRemoved is a free log retrieval operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterGovernorRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgeV2GovernorRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2GovernorRemovedIterator{contract: _PeggedTokenBridgeV2.contract, event: "GovernorRemoved", logs: logs, sub: sub}, nil
}

// WatchGovernorRemoved is a free log subscription operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchGovernorRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2GovernorRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "GovernorRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2GovernorRemoved)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGovernorRemoved is a log parse operation binding the contract event 0x1ebe834e73d60a5fec822c1e1727d34bc79f2ad977ed504581cc1822fe20fb5b.
//
// Solidity: event GovernorRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseGovernorRemoved(log types.Log) (*PeggedTokenBridgeV2GovernorRemoved, error) {
	event := new(PeggedTokenBridgeV2GovernorRemoved)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "GovernorRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MaxBurnUpdatedIterator is returned from FilterMaxBurnUpdated and is used to iterate over the raw logs and unpacked data for MaxBurnUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MaxBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeV2MaxBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2MaxBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2MaxBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2MaxBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2MaxBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2MaxBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2MaxBurnUpdated represents a MaxBurnUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MaxBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMaxBurnUpdated is a free log retrieval operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterMaxBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2MaxBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2MaxBurnUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "MaxBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMaxBurnUpdated is a free log subscription operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchMaxBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2MaxBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "MaxBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2MaxBurnUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxBurnUpdated is a log parse operation binding the contract event 0xa3181379f6db47d9037efc6b6e8e3efe8c55ddb090b4f0512c152f97c4e47da5.
//
// Solidity: event MaxBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseMaxBurnUpdated(log types.Log) (*PeggedTokenBridgeV2MaxBurnUpdated, error) {
	event := new(PeggedTokenBridgeV2MaxBurnUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MaxBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MinBurnUpdatedIterator is returned from FilterMinBurnUpdated and is used to iterate over the raw logs and unpacked data for MinBurnUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MinBurnUpdatedIterator struct {
	Event *PeggedTokenBridgeV2MinBurnUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2MinBurnUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2MinBurnUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2MinBurnUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2MinBurnUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2MinBurnUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2MinBurnUpdated represents a MinBurnUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MinBurnUpdated struct {
	Token  common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMinBurnUpdated is a free log retrieval operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterMinBurnUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2MinBurnUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2MinBurnUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "MinBurnUpdated", logs: logs, sub: sub}, nil
}

// WatchMinBurnUpdated is a free log subscription operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchMinBurnUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2MinBurnUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "MinBurnUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2MinBurnUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMinBurnUpdated is a log parse operation binding the contract event 0x3796cd0b17a8734f8da819920625598e9a18be490f686725282e5383f1d06683.
//
// Solidity: event MinBurnUpdated(address token, uint256 amount)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseMinBurnUpdated(log types.Log) (*PeggedTokenBridgeV2MinBurnUpdated, error) {
	event := new(PeggedTokenBridgeV2MinBurnUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "MinBurnUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2MintIterator is returned from FilterMint and is used to iterate over the raw logs and unpacked data for Mint events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2MintIterator struct {
	Event *PeggedTokenBridgeV2Mint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2MintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Mint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Mint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2MintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2MintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Mint represents a Mint event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Mint struct {
	MintId     [32]byte
	Token      common.Address
	Account    common.Address
	Amount     *big.Int
	RefChainId uint64
	RefId      [32]byte
	Depositor  common.Address
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterMint is a free log retrieval operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterMint(opts *bind.FilterOpts) (*PeggedTokenBridgeV2MintIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2MintIterator{contract: _PeggedTokenBridgeV2.contract, event: "Mint", logs: logs, sub: sub}, nil
}

// WatchMint is a free log subscription operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchMint(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Mint) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Mint")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Mint)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Mint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMint is a log parse operation binding the contract event 0x5bc84ecccfced5bb04bfc7f3efcdbe7f5cd21949ef146811b4d1967fe41f777a.
//
// Solidity: event Mint(bytes32 mintId, address token, address account, uint256 amount, uint64 refChainId, bytes32 refId, address depositor)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseMint(log types.Log) (*PeggedTokenBridgeV2Mint, error) {
	event := new(PeggedTokenBridgeV2Mint)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Mint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2OwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2OwnershipTransferredIterator struct {
	Event *PeggedTokenBridgeV2OwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2OwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2OwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2OwnershipTransferred represents a OwnershipTransferred event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2OwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PeggedTokenBridgeV2OwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2OwnershipTransferredIterator{contract: _PeggedTokenBridgeV2.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2OwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2OwnershipTransferred)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseOwnershipTransferred(log types.Log) (*PeggedTokenBridgeV2OwnershipTransferred, error) {
	event := new(PeggedTokenBridgeV2OwnershipTransferred)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2PausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PausedIterator struct {
	Event *PeggedTokenBridgeV2Paused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2PausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Paused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Paused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2PausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2PausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Paused represents a Paused event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Paused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterPaused(opts *bind.FilterOpts) (*PeggedTokenBridgeV2PausedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2PausedIterator{contract: _PeggedTokenBridgeV2.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Paused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Paused)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParsePaused(log types.Log) (*PeggedTokenBridgeV2Paused, error) {
	event := new(PeggedTokenBridgeV2Paused)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2PauserAddedIterator is returned from FilterPauserAdded and is used to iterate over the raw logs and unpacked data for PauserAdded events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserAddedIterator struct {
	Event *PeggedTokenBridgeV2PauserAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2PauserAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2PauserAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2PauserAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2PauserAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2PauserAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2PauserAdded represents a PauserAdded event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserAdded struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserAdded is a free log retrieval operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterPauserAdded(opts *bind.FilterOpts) (*PeggedTokenBridgeV2PauserAddedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2PauserAddedIterator{contract: _PeggedTokenBridgeV2.contract, event: "PauserAdded", logs: logs, sub: sub}, nil
}

// WatchPauserAdded is a free log subscription operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchPauserAdded(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2PauserAdded) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "PauserAdded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2PauserAdded)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserAdded is a log parse operation binding the contract event 0x6719d08c1888103bea251a4ed56406bd0c3e69723c8a1686e017e7bbe159b6f8.
//
// Solidity: event PauserAdded(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParsePauserAdded(log types.Log) (*PeggedTokenBridgeV2PauserAdded, error) {
	event := new(PeggedTokenBridgeV2PauserAdded)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserAdded", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2PauserRemovedIterator is returned from FilterPauserRemoved and is used to iterate over the raw logs and unpacked data for PauserRemoved events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserRemovedIterator struct {
	Event *PeggedTokenBridgeV2PauserRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2PauserRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2PauserRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2PauserRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2PauserRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2PauserRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2PauserRemoved represents a PauserRemoved event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2PauserRemoved struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPauserRemoved is a free log retrieval operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterPauserRemoved(opts *bind.FilterOpts) (*PeggedTokenBridgeV2PauserRemovedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2PauserRemovedIterator{contract: _PeggedTokenBridgeV2.contract, event: "PauserRemoved", logs: logs, sub: sub}, nil
}

// WatchPauserRemoved is a free log subscription operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchPauserRemoved(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2PauserRemoved) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "PauserRemoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2PauserRemoved)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePauserRemoved is a log parse operation binding the contract event 0xcd265ebaf09df2871cc7bd4133404a235ba12eff2041bb89d9c714a2621c7c7e.
//
// Solidity: event PauserRemoved(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParsePauserRemoved(log types.Log) (*PeggedTokenBridgeV2PauserRemoved, error) {
	event := new(PeggedTokenBridgeV2PauserRemoved)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "PauserRemoved", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2SupplyUpdatedIterator is returned from FilterSupplyUpdated and is used to iterate over the raw logs and unpacked data for SupplyUpdated events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2SupplyUpdatedIterator struct {
	Event *PeggedTokenBridgeV2SupplyUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2SupplyUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2SupplyUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2SupplyUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2SupplyUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2SupplyUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2SupplyUpdated represents a SupplyUpdated event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2SupplyUpdated struct {
	Token  common.Address
	Supply *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterSupplyUpdated is a free log retrieval operation binding the contract event 0xeb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e9499.
//
// Solidity: event SupplyUpdated(address token, uint256 supply)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterSupplyUpdated(opts *bind.FilterOpts) (*PeggedTokenBridgeV2SupplyUpdatedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "SupplyUpdated")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2SupplyUpdatedIterator{contract: _PeggedTokenBridgeV2.contract, event: "SupplyUpdated", logs: logs, sub: sub}, nil
}

// WatchSupplyUpdated is a free log subscription operation binding the contract event 0xeb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e9499.
//
// Solidity: event SupplyUpdated(address token, uint256 supply)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchSupplyUpdated(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2SupplyUpdated) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "SupplyUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2SupplyUpdated)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "SupplyUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSupplyUpdated is a log parse operation binding the contract event 0xeb2f7272b55acd6dea98f5742868e8d2221ad82acb36b2d0cdd00150290e9499.
//
// Solidity: event SupplyUpdated(address token, uint256 supply)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseSupplyUpdated(log types.Log) (*PeggedTokenBridgeV2SupplyUpdated, error) {
	event := new(PeggedTokenBridgeV2SupplyUpdated)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "SupplyUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// PeggedTokenBridgeV2UnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2UnpausedIterator struct {
	Event *PeggedTokenBridgeV2Unpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PeggedTokenBridgeV2UnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PeggedTokenBridgeV2Unpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PeggedTokenBridgeV2Unpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PeggedTokenBridgeV2UnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PeggedTokenBridgeV2UnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PeggedTokenBridgeV2Unpaused represents a Unpaused event raised by the PeggedTokenBridgeV2 contract.
type PeggedTokenBridgeV2Unpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) FilterUnpaused(opts *bind.FilterOpts) (*PeggedTokenBridgeV2UnpausedIterator, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &PeggedTokenBridgeV2UnpausedIterator{contract: _PeggedTokenBridgeV2.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *PeggedTokenBridgeV2Unpaused) (event.Subscription, error) {

	logs, sub, err := _PeggedTokenBridgeV2.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PeggedTokenBridgeV2Unpaused)
				if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_PeggedTokenBridgeV2 *PeggedTokenBridgeV2Filterer) ParseUnpaused(log types.Log) (*PeggedTokenBridgeV2Unpaused, error) {
	event := new(PeggedTokenBridgeV2Unpaused)
	if err := _PeggedTokenBridgeV2.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
