// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/gateway/v1/gateway.proto

package webapi

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	types "github.com/celer-network/sgn-v2/x/cbridge/types"
	types1 "github.com/celer-network/sgn-v2/x/farming/types"
	_ "github.com/cosmos/cosmos-sdk/types"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TransferType int32

const (
	TransferType_TRANSFER_TYPE_UNKNOWN TransferType = 0
	TransferType_TRANSFER_TYPE_SEND    TransferType = 1
	TransferType_TRANSFER_TYPE_REFUND  TransferType = 2
)

var TransferType_name = map[int32]string{
	0: "TRANSFER_TYPE_UNKNOWN",
	1: "TRANSFER_TYPE_SEND",
	2: "TRANSFER_TYPE_REFUND",
}

var TransferType_value = map[string]int32{
	"TRANSFER_TYPE_UNKNOWN": 0,
	"TRANSFER_TYPE_SEND":    1,
	"TRANSFER_TYPE_REFUND":  2,
}

func (x TransferType) String() string {
	return proto.EnumName(TransferType_name, int32(x))
}

func (TransferType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{0}
}

type LPType int32

const (
	LPType_LP_TYPE_UNKNOWN LPType = 0
	LPType_LP_TYPE_ADD     LPType = 1
	LPType_LP_TYPE_REMOVE  LPType = 2
)

var LPType_name = map[int32]string{
	0: "LP_TYPE_UNKNOWN",
	1: "LP_TYPE_ADD",
	2: "LP_TYPE_REMOVE",
}

var LPType_value = map[string]int32{
	"LP_TYPE_UNKNOWN": 0,
	"LP_TYPE_ADD":     1,
	"LP_TYPE_REMOVE":  2,
}

func (x LPType) String() string {
	return proto.EnumName(LPType_name, int32(x))
}

func (LPType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{1}
}

type ErrCode int32

const (
	ErrCode_ERROR_CODE_UNDEFINED        ErrCode = 0
	ErrCode_ERROR_CODE_COMMON           ErrCode = 500
	ErrCode_ERROR_NO_TOKEN_ON_DST_CHAIN ErrCode = 1001
)

var ErrCode_name = map[int32]string{
	0:    "ERROR_CODE_UNDEFINED",
	500:  "ERROR_CODE_COMMON",
	1001: "ERROR_NO_TOKEN_ON_DST_CHAIN",
}

var ErrCode_value = map[string]int32{
	"ERROR_CODE_UNDEFINED":        0,
	"ERROR_CODE_COMMON":           500,
	"ERROR_NO_TOKEN_ON_DST_CHAIN": 1001,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{2}
}

type QueryLiquidityStatusResponse struct {
	Err        *ErrMsg               `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Status     types.LPHistoryStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sgn.cbridge.v1.LPHistoryStatus" json:"status,omitempty"`
	WdOnchain  []byte                `protobuf:"bytes,3,opt,name=wd_onchain,json=wdOnchain,proto3" json:"wd_onchain,omitempty"`
	SortedSigs [][]byte              `protobuf:"bytes,4,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	Signers    [][]byte              `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
	Powers     [][]byte              `protobuf:"bytes,6,rep,name=powers,proto3" json:"powers,omitempty"`
}

func (m *QueryLiquidityStatusResponse) Reset()         { *m = QueryLiquidityStatusResponse{} }
func (m *QueryLiquidityStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidityStatusResponse) ProtoMessage()    {}
func (*QueryLiquidityStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{0}
}
func (m *QueryLiquidityStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidityStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidityStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidityStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidityStatusResponse.Merge(m, src)
}
func (m *QueryLiquidityStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidityStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidityStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidityStatusResponse proto.InternalMessageInfo

func (m *QueryLiquidityStatusResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetStatus() types.LPHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.LPHistoryStatus_LP_UNKNOWN
}

func (m *QueryLiquidityStatusResponse) GetWdOnchain() []byte {
	if m != nil {
		return m.WdOnchain
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetSortedSigs() [][]byte {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetSigners() [][]byte {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetPowers() [][]byte {
	if m != nil {
		return m.Powers
	}
	return nil
}

type Chain struct {
	Id   uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon string `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *Chain) Reset()         { *m = Chain{} }
func (m *Chain) String() string { return proto.CompactTextString(m) }
func (*Chain) ProtoMessage()    {}
func (*Chain) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{1}
}
func (m *Chain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chain.Merge(m, src)
}
func (m *Chain) XXX_Size() int {
	return m.Size()
}
func (m *Chain) XXX_DiscardUnknown() {
	xxx_messageInfo_Chain.DiscardUnknown(m)
}

var xxx_messageInfo_Chain proto.InternalMessageInfo

func (m *Chain) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Chain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Chain) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type ChainTokenInfo struct {
	Token []*TokenInfo `protobuf:"bytes,1,rep,name=token,proto3" json:"token,omitempty"`
}

func (m *ChainTokenInfo) Reset()         { *m = ChainTokenInfo{} }
func (m *ChainTokenInfo) String() string { return proto.CompactTextString(m) }
func (*ChainTokenInfo) ProtoMessage()    {}
func (*ChainTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{2}
}
func (m *ChainTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainTokenInfo.Merge(m, src)
}
func (m *ChainTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChainTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChainTokenInfo proto.InternalMessageInfo

func (m *ChainTokenInfo) GetToken() []*TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

type TokenInfo struct {
	Token        *types.Token `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Name         string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon         string       `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	ContractAddr string       `protobuf:"bytes,4,opt,name=contract_addr,json=contractAddr,proto3" json:"contract_addr,omitempty"`
}

func (m *TokenInfo) Reset()         { *m = TokenInfo{} }
func (m *TokenInfo) String() string { return proto.CompactTextString(m) }
func (*TokenInfo) ProtoMessage()    {}
func (*TokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{3}
}
func (m *TokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenInfo.Merge(m, src)
}
func (m *TokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *TokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenInfo proto.InternalMessageInfo

func (m *TokenInfo) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *TokenInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TokenInfo) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *TokenInfo) GetContractAddr() string {
	if m != nil {
		return m.ContractAddr
	}
	return ""
}

type TransferInfo struct {
	Chain  *Chain       `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token  *types.Token `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Amount string       `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *TransferInfo) Reset()         { *m = TransferInfo{} }
func (m *TransferInfo) String() string { return proto.CompactTextString(m) }
func (*TransferInfo) ProtoMessage()    {}
func (*TransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{4}
}
func (m *TransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferInfo.Merge(m, src)
}
func (m *TransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *TransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TransferInfo proto.InternalMessageInfo

func (m *TransferInfo) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *TransferInfo) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *TransferInfo) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type SetAdvancedInfoRequest struct {
	Addr              string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	SlippageTolerance uint32 `protobuf:"varint,2,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
}

func (m *SetAdvancedInfoRequest) Reset()         { *m = SetAdvancedInfoRequest{} }
func (m *SetAdvancedInfoRequest) String() string { return proto.CompactTextString(m) }
func (*SetAdvancedInfoRequest) ProtoMessage()    {}
func (*SetAdvancedInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{5}
}
func (m *SetAdvancedInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetAdvancedInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetAdvancedInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetAdvancedInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetAdvancedInfoRequest.Merge(m, src)
}
func (m *SetAdvancedInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetAdvancedInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetAdvancedInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetAdvancedInfoRequest proto.InternalMessageInfo

func (m *SetAdvancedInfoRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *SetAdvancedInfoRequest) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

type SetAdvancedInfoResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *SetAdvancedInfoResponse) Reset()         { *m = SetAdvancedInfoResponse{} }
func (m *SetAdvancedInfoResponse) String() string { return proto.CompactTextString(m) }
func (*SetAdvancedInfoResponse) ProtoMessage()    {}
func (*SetAdvancedInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{6}
}
func (m *SetAdvancedInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetAdvancedInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetAdvancedInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetAdvancedInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetAdvancedInfoResponse.Merge(m, src)
}
func (m *SetAdvancedInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetAdvancedInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetAdvancedInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetAdvancedInfoResponse proto.InternalMessageInfo

func (m *SetAdvancedInfoResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetAdvancedInfoRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetAdvancedInfoRequest) Reset()         { *m = GetAdvancedInfoRequest{} }
func (m *GetAdvancedInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetAdvancedInfoRequest) ProtoMessage()    {}
func (*GetAdvancedInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{7}
}
func (m *GetAdvancedInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAdvancedInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdvancedInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAdvancedInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdvancedInfoRequest.Merge(m, src)
}
func (m *GetAdvancedInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAdvancedInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdvancedInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdvancedInfoRequest proto.InternalMessageInfo

func (m *GetAdvancedInfoRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type GetAdvancedInfoResponse struct {
	Err               *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	SlippageTolerance uint32  `protobuf:"varint,2,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
}

func (m *GetAdvancedInfoResponse) Reset()         { *m = GetAdvancedInfoResponse{} }
func (m *GetAdvancedInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetAdvancedInfoResponse) ProtoMessage()    {}
func (*GetAdvancedInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{8}
}
func (m *GetAdvancedInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAdvancedInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAdvancedInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAdvancedInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAdvancedInfoResponse.Merge(m, src)
}
func (m *GetAdvancedInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAdvancedInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAdvancedInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAdvancedInfoResponse proto.InternalMessageInfo

func (m *GetAdvancedInfoResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetAdvancedInfoResponse) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

type GetTransferStatusRequest struct {
	TransferId string `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
}

func (m *GetTransferStatusRequest) Reset()         { *m = GetTransferStatusRequest{} }
func (m *GetTransferStatusRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransferStatusRequest) ProtoMessage()    {}
func (*GetTransferStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{9}
}
func (m *GetTransferStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferStatusRequest.Merge(m, src)
}
func (m *GetTransferStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferStatusRequest proto.InternalMessageInfo

func (m *GetTransferStatusRequest) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

type GetTransferStatusResponse struct {
	Err          *ErrMsg                     `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Status       types.TransferHistoryStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sgn.cbridge.v1.TransferHistoryStatus" json:"status,omitempty"`
	WdOnchain    []byte                      `protobuf:"bytes,3,opt,name=wd_onchain,json=wdOnchain,proto3" json:"wd_onchain,omitempty"`
	SortedSigs   [][]byte                    `protobuf:"bytes,4,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	Signers      [][]byte                    `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
	Powers       [][]byte                    `protobuf:"bytes,6,rep,name=powers,proto3" json:"powers,omitempty"`
	RefundReason types.XferStatus            `protobuf:"varint,7,opt,name=refund_reason,json=refundReason,proto3,enum=sgn.cbridge.v1.XferStatus" json:"refund_reason,omitempty"`
	BlockDelay   uint32                      `protobuf:"varint,8,opt,name=block_delay,json=blockDelay,proto3" json:"block_delay,omitempty"`
}

func (m *GetTransferStatusResponse) Reset()         { *m = GetTransferStatusResponse{} }
func (m *GetTransferStatusResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransferStatusResponse) ProtoMessage()    {}
func (*GetTransferStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{10}
}
func (m *GetTransferStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferStatusResponse.Merge(m, src)
}
func (m *GetTransferStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferStatusResponse proto.InternalMessageInfo

func (m *GetTransferStatusResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTransferStatusResponse) GetStatus() types.TransferHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.TransferHistoryStatus_TRANSFER_UNKNOWN
}

func (m *GetTransferStatusResponse) GetWdOnchain() []byte {
	if m != nil {
		return m.WdOnchain
	}
	return nil
}

func (m *GetTransferStatusResponse) GetSortedSigs() [][]byte {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *GetTransferStatusResponse) GetSigners() [][]byte {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *GetTransferStatusResponse) GetPowers() [][]byte {
	if m != nil {
		return m.Powers
	}
	return nil
}

func (m *GetTransferStatusResponse) GetRefundReason() types.XferStatus {
	if m != nil {
		return m.RefundReason
	}
	return types.XferStatus_UNKNOWN
}

func (m *GetTransferStatusResponse) GetBlockDelay() uint32 {
	if m != nil {
		return m.BlockDelay
	}
	return 0
}

type GetTransferConfigsRequest struct {
}

func (m *GetTransferConfigsRequest) Reset()         { *m = GetTransferConfigsRequest{} }
func (m *GetTransferConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransferConfigsRequest) ProtoMessage()    {}
func (*GetTransferConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{11}
}
func (m *GetTransferConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferConfigsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferConfigsRequest.Merge(m, src)
}
func (m *GetTransferConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferConfigsRequest proto.InternalMessageInfo

type GetTransferConfigsResponse struct {
	Err        *ErrMsg                    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Chains     []*Chain                   `protobuf:"bytes,2,rep,name=chains,proto3" json:"chains,omitempty"`
	ChainToken map[uint32]*ChainTokenInfo `protobuf:"bytes,3,rep,name=chain_token,json=chainToken,proto3" json:"chain_token,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetTransferConfigsResponse) Reset()         { *m = GetTransferConfigsResponse{} }
func (m *GetTransferConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransferConfigsResponse) ProtoMessage()    {}
func (*GetTransferConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{12}
}
func (m *GetTransferConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferConfigsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferConfigsResponse.Merge(m, src)
}
func (m *GetTransferConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferConfigsResponse proto.InternalMessageInfo

func (m *GetTransferConfigsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetChains() []*Chain {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetChainToken() map[uint32]*ChainTokenInfo {
	if m != nil {
		return m.ChainToken
	}
	return nil
}

type EstimateAmtRequest struct {
	SrcChainId  uint32 `protobuf:"varint,1,opt,name=src_chain_id,json=srcChainId,proto3" json:"src_chain_id,omitempty"`
	DstChainId  uint32 `protobuf:"varint,2,opt,name=dst_chain_id,json=dstChainId,proto3" json:"dst_chain_id,omitempty"`
	TokenSymbol string `protobuf:"bytes,3,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
	Amt         string `protobuf:"bytes,4,opt,name=amt,proto3" json:"amt,omitempty"`
	UsrAddr     string `protobuf:"bytes,5,opt,name=usr_addr,json=usrAddr,proto3" json:"usr_addr,omitempty"`
}

func (m *EstimateAmtRequest) Reset()         { *m = EstimateAmtRequest{} }
func (m *EstimateAmtRequest) String() string { return proto.CompactTextString(m) }
func (*EstimateAmtRequest) ProtoMessage()    {}
func (*EstimateAmtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{13}
}
func (m *EstimateAmtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateAmtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateAmtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateAmtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateAmtRequest.Merge(m, src)
}
func (m *EstimateAmtRequest) XXX_Size() int {
	return m.Size()
}
func (m *EstimateAmtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateAmtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateAmtRequest proto.InternalMessageInfo

func (m *EstimateAmtRequest) GetSrcChainId() uint32 {
	if m != nil {
		return m.SrcChainId
	}
	return 0
}

func (m *EstimateAmtRequest) GetDstChainId() uint32 {
	if m != nil {
		return m.DstChainId
	}
	return 0
}

func (m *EstimateAmtRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

func (m *EstimateAmtRequest) GetAmt() string {
	if m != nil {
		return m.Amt
	}
	return ""
}

func (m *EstimateAmtRequest) GetUsrAddr() string {
	if m != nil {
		return m.UsrAddr
	}
	return ""
}

type EstimateAmtResponse struct {
	Err               *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	EqValueTokenAmt   string  `protobuf:"bytes,2,opt,name=eq_value_token_amt,json=eqValueTokenAmt,proto3" json:"eq_value_token_amt,omitempty"`
	BridgeRate        float32 `protobuf:"fixed32,3,opt,name=bridge_rate,json=bridgeRate,proto3" json:"bridge_rate,omitempty"`
	Fee               string  `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	SlippageTolerance uint32  `protobuf:"varint,5,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	MaxSlippage       uint32  `protobuf:"varint,6,opt,name=max_slippage,json=maxSlippage,proto3" json:"max_slippage,omitempty"`
}

func (m *EstimateAmtResponse) Reset()         { *m = EstimateAmtResponse{} }
func (m *EstimateAmtResponse) String() string { return proto.CompactTextString(m) }
func (*EstimateAmtResponse) ProtoMessage()    {}
func (*EstimateAmtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{14}
}
func (m *EstimateAmtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateAmtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateAmtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateAmtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateAmtResponse.Merge(m, src)
}
func (m *EstimateAmtResponse) XXX_Size() int {
	return m.Size()
}
func (m *EstimateAmtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateAmtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateAmtResponse proto.InternalMessageInfo

func (m *EstimateAmtResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *EstimateAmtResponse) GetEqValueTokenAmt() string {
	if m != nil {
		return m.EqValueTokenAmt
	}
	return ""
}

func (m *EstimateAmtResponse) GetBridgeRate() float32 {
	if m != nil {
		return m.BridgeRate
	}
	return 0
}

func (m *EstimateAmtResponse) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *EstimateAmtResponse) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *EstimateAmtResponse) GetMaxSlippage() uint32 {
	if m != nil {
		return m.MaxSlippage
	}
	return 0
}

type MarkTransferRequest struct {
	TransferId         string        `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	SrcSendInfo        *TransferInfo `protobuf:"bytes,2,opt,name=src_send_info,json=srcSendInfo,proto3" json:"src_send_info,omitempty"`
	DstMinReceivedInfo *TransferInfo `protobuf:"bytes,3,opt,name=dst_min_received_info,json=dstMinReceivedInfo,proto3" json:"dst_min_received_info,omitempty"`
	Addr               string        `protobuf:"bytes,4,opt,name=addr,proto3" json:"addr,omitempty"`
	SrcTxHash          string        `protobuf:"bytes,5,opt,name=src_tx_hash,json=srcTxHash,proto3" json:"src_tx_hash,omitempty"`
	Type               TransferType  `protobuf:"varint,6,opt,name=type,proto3,enum=sgn.gateway.v1.TransferType" json:"type,omitempty"`
}

func (m *MarkTransferRequest) Reset()         { *m = MarkTransferRequest{} }
func (m *MarkTransferRequest) String() string { return proto.CompactTextString(m) }
func (*MarkTransferRequest) ProtoMessage()    {}
func (*MarkTransferRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{15}
}
func (m *MarkTransferRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkTransferRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkTransferRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkTransferRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkTransferRequest.Merge(m, src)
}
func (m *MarkTransferRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkTransferRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkTransferRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkTransferRequest proto.InternalMessageInfo

func (m *MarkTransferRequest) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

func (m *MarkTransferRequest) GetSrcSendInfo() *TransferInfo {
	if m != nil {
		return m.SrcSendInfo
	}
	return nil
}

func (m *MarkTransferRequest) GetDstMinReceivedInfo() *TransferInfo {
	if m != nil {
		return m.DstMinReceivedInfo
	}
	return nil
}

func (m *MarkTransferRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *MarkTransferRequest) GetSrcTxHash() string {
	if m != nil {
		return m.SrcTxHash
	}
	return ""
}

func (m *MarkTransferRequest) GetType() TransferType {
	if m != nil {
		return m.Type
	}
	return TransferType_TRANSFER_TYPE_UNKNOWN
}

type MarkTransferResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *MarkTransferResponse) Reset()         { *m = MarkTransferResponse{} }
func (m *MarkTransferResponse) String() string { return proto.CompactTextString(m) }
func (*MarkTransferResponse) ProtoMessage()    {}
func (*MarkTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{16}
}
func (m *MarkTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkTransferResponse.Merge(m, src)
}
func (m *MarkTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkTransferResponse proto.InternalMessageInfo

func (m *MarkTransferResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetLPInfoListRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetLPInfoListRequest) Reset()         { *m = GetLPInfoListRequest{} }
func (m *GetLPInfoListRequest) String() string { return proto.CompactTextString(m) }
func (*GetLPInfoListRequest) ProtoMessage()    {}
func (*GetLPInfoListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{17}
}
func (m *GetLPInfoListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLPInfoListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLPInfoListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLPInfoListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLPInfoListRequest.Merge(m, src)
}
func (m *GetLPInfoListRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLPInfoListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLPInfoListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLPInfoListRequest proto.InternalMessageInfo

func (m *GetLPInfoListRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type LPInfo struct {
	Chain                *Chain     `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token                *TokenInfo `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Liquidity            float64    `protobuf:"fixed64,3,opt,name=liquidity,proto3" json:"liquidity,omitempty"`
	LiquidityAmt         string     `protobuf:"bytes,4,opt,name=liquidity_amt,json=liquidityAmt,proto3" json:"liquidity_amt,omitempty"`
	HasFarmingSessions   bool       `protobuf:"varint,5,opt,name=has_farming_sessions,json=hasFarmingSessions,proto3" json:"has_farming_sessions,omitempty"`
	LpFeeEarning         float64    `protobuf:"fixed64,6,opt,name=lp_fee_earning,json=lpFeeEarning,proto3" json:"lp_fee_earning,omitempty"`
	FarmingRewardEarning float64    `protobuf:"fixed64,7,opt,name=farming_reward_earning,json=farmingRewardEarning,proto3" json:"farming_reward_earning,omitempty"`
	Volume_24H           float64    `protobuf:"fixed64,8,opt,name=volume_24h,json=volume24h,proto3" json:"volume_24h,omitempty"`
	TotalLiquidity       float64    `protobuf:"fixed64,9,opt,name=total_liquidity,json=totalLiquidity,proto3" json:"total_liquidity,omitempty"`
	TotalLiquidityAmt    string     `protobuf:"bytes,10,opt,name=total_liquidity_amt,json=totalLiquidityAmt,proto3" json:"total_liquidity_amt,omitempty"`
	LpFeeEarningApy      float64    `protobuf:"fixed64,11,opt,name=lp_fee_earning_apy,json=lpFeeEarningApy,proto3" json:"lp_fee_earning_apy,omitempty"`
	FarmingApy           float64    `protobuf:"fixed64,12,opt,name=farming_apy,json=farmingApy,proto3" json:"farming_apy,omitempty"`
}

func (m *LPInfo) Reset()         { *m = LPInfo{} }
func (m *LPInfo) String() string { return proto.CompactTextString(m) }
func (*LPInfo) ProtoMessage()    {}
func (*LPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{18}
}
func (m *LPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPInfo.Merge(m, src)
}
func (m *LPInfo) XXX_Size() int {
	return m.Size()
}
func (m *LPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LPInfo proto.InternalMessageInfo

func (m *LPInfo) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *LPInfo) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *LPInfo) GetLiquidity() float64 {
	if m != nil {
		return m.Liquidity
	}
	return 0
}

func (m *LPInfo) GetLiquidityAmt() string {
	if m != nil {
		return m.LiquidityAmt
	}
	return ""
}

func (m *LPInfo) GetHasFarmingSessions() bool {
	if m != nil {
		return m.HasFarmingSessions
	}
	return false
}

func (m *LPInfo) GetLpFeeEarning() float64 {
	if m != nil {
		return m.LpFeeEarning
	}
	return 0
}

func (m *LPInfo) GetFarmingRewardEarning() float64 {
	if m != nil {
		return m.FarmingRewardEarning
	}
	return 0
}

func (m *LPInfo) GetVolume_24H() float64 {
	if m != nil {
		return m.Volume_24H
	}
	return 0
}

func (m *LPInfo) GetTotalLiquidity() float64 {
	if m != nil {
		return m.TotalLiquidity
	}
	return 0
}

func (m *LPInfo) GetTotalLiquidityAmt() string {
	if m != nil {
		return m.TotalLiquidityAmt
	}
	return ""
}

func (m *LPInfo) GetLpFeeEarningApy() float64 {
	if m != nil {
		return m.LpFeeEarningApy
	}
	return 0
}

func (m *LPInfo) GetFarmingApy() float64 {
	if m != nil {
		return m.FarmingApy
	}
	return 0
}

type GetLPInfoListResponse struct {
	Err    *ErrMsg   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	LpInfo []*LPInfo `protobuf:"bytes,2,rep,name=lp_info,json=lpInfo,proto3" json:"lp_info,omitempty"`
}

func (m *GetLPInfoListResponse) Reset()         { *m = GetLPInfoListResponse{} }
func (m *GetLPInfoListResponse) String() string { return proto.CompactTextString(m) }
func (*GetLPInfoListResponse) ProtoMessage()    {}
func (*GetLPInfoListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{19}
}
func (m *GetLPInfoListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLPInfoListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLPInfoListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLPInfoListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLPInfoListResponse.Merge(m, src)
}
func (m *GetLPInfoListResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLPInfoListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLPInfoListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLPInfoListResponse proto.InternalMessageInfo

func (m *GetLPInfoListResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetLPInfoListResponse) GetLpInfo() []*LPInfo {
	if m != nil {
		return m.LpInfo
	}
	return nil
}

type WithdrawLiquidityRequest struct {
	TransferId string `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	// lp withdraw, only set if xfer_id is nil
	ReceiverAddr string `protobuf:"bytes,2,opt,name=receiver_addr,json=receiverAddr,proto3" json:"receiver_addr,omitempty"`
	Amount       string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	TokenAddr    string `protobuf:"bytes,4,opt,name=token_addr,json=tokenAddr,proto3" json:"token_addr,omitempty"`
	ChainId      uint32 `protobuf:"varint,5,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// unique req id from client and sig to avoid dos attack
	Reqid uint64 `protobuf:"varint,6,opt,name=reqid,proto3" json:"reqid,omitempty"`
	Sig   []byte `protobuf:"bytes,7,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *WithdrawLiquidityRequest) Reset()         { *m = WithdrawLiquidityRequest{} }
func (m *WithdrawLiquidityRequest) String() string { return proto.CompactTextString(m) }
func (*WithdrawLiquidityRequest) ProtoMessage()    {}
func (*WithdrawLiquidityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{20}
}
func (m *WithdrawLiquidityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawLiquidityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawLiquidityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawLiquidityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawLiquidityRequest.Merge(m, src)
}
func (m *WithdrawLiquidityRequest) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawLiquidityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawLiquidityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawLiquidityRequest proto.InternalMessageInfo

func (m *WithdrawLiquidityRequest) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

func (m *WithdrawLiquidityRequest) GetReceiverAddr() string {
	if m != nil {
		return m.ReceiverAddr
	}
	return ""
}

func (m *WithdrawLiquidityRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *WithdrawLiquidityRequest) GetTokenAddr() string {
	if m != nil {
		return m.TokenAddr
	}
	return ""
}

func (m *WithdrawLiquidityRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *WithdrawLiquidityRequest) GetReqid() uint64 {
	if m != nil {
		return m.Reqid
	}
	return 0
}

func (m *WithdrawLiquidityRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

type WithdrawLiquidityResponse struct {
	Err    *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	SeqNum uint64  `protobuf:"varint,2,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
}

func (m *WithdrawLiquidityResponse) Reset()         { *m = WithdrawLiquidityResponse{} }
func (m *WithdrawLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*WithdrawLiquidityResponse) ProtoMessage()    {}
func (*WithdrawLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{21}
}
func (m *WithdrawLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawLiquidityResponse.Merge(m, src)
}
func (m *WithdrawLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawLiquidityResponse proto.InternalMessageInfo

func (m *WithdrawLiquidityResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *WithdrawLiquidityResponse) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

type MarkLiquidityRequest struct {
	LpAddr    string `protobuf:"bytes,1,opt,name=lp_addr,json=lpAddr,proto3" json:"lp_addr,omitempty"`
	Amt       string `protobuf:"bytes,2,opt,name=amt,proto3" json:"amt,omitempty"`
	TokenAddr string `protobuf:"bytes,3,opt,name=token_addr,json=tokenAddr,proto3" json:"token_addr,omitempty"`
	ChainId   uint32 `protobuf:"varint,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	SeqNum    uint64 `protobuf:"varint,5,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	TxHash    string `protobuf:"bytes,6,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	Type      LPType `protobuf:"varint,7,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
}

func (m *MarkLiquidityRequest) Reset()         { *m = MarkLiquidityRequest{} }
func (m *MarkLiquidityRequest) String() string { return proto.CompactTextString(m) }
func (*MarkLiquidityRequest) ProtoMessage()    {}
func (*MarkLiquidityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{22}
}
func (m *MarkLiquidityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkLiquidityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkLiquidityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkLiquidityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkLiquidityRequest.Merge(m, src)
}
func (m *MarkLiquidityRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkLiquidityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkLiquidityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkLiquidityRequest proto.InternalMessageInfo

func (m *MarkLiquidityRequest) GetLpAddr() string {
	if m != nil {
		return m.LpAddr
	}
	return ""
}

func (m *MarkLiquidityRequest) GetAmt() string {
	if m != nil {
		return m.Amt
	}
	return ""
}

func (m *MarkLiquidityRequest) GetTokenAddr() string {
	if m != nil {
		return m.TokenAddr
	}
	return ""
}

func (m *MarkLiquidityRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *MarkLiquidityRequest) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *MarkLiquidityRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *MarkLiquidityRequest) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

type MarkLiquidityResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *MarkLiquidityResponse) Reset()         { *m = MarkLiquidityResponse{} }
func (m *MarkLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*MarkLiquidityResponse) ProtoMessage()    {}
func (*MarkLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{23}
}
func (m *MarkLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkLiquidityResponse.Merge(m, src)
}
func (m *MarkLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkLiquidityResponse proto.InternalMessageInfo

func (m *MarkLiquidityResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type ClaimWithdrawRewardRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *ClaimWithdrawRewardRequest) Reset()         { *m = ClaimWithdrawRewardRequest{} }
func (m *ClaimWithdrawRewardRequest) String() string { return proto.CompactTextString(m) }
func (*ClaimWithdrawRewardRequest) ProtoMessage()    {}
func (*ClaimWithdrawRewardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{24}
}
func (m *ClaimWithdrawRewardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimWithdrawRewardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimWithdrawRewardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimWithdrawRewardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimWithdrawRewardRequest.Merge(m, src)
}
func (m *ClaimWithdrawRewardRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClaimWithdrawRewardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimWithdrawRewardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimWithdrawRewardRequest proto.InternalMessageInfo

func (m *ClaimWithdrawRewardRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type ClaimWithdrawRewardResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ClaimWithdrawRewardResponse) Reset()         { *m = ClaimWithdrawRewardResponse{} }
func (m *ClaimWithdrawRewardResponse) String() string { return proto.CompactTextString(m) }
func (*ClaimWithdrawRewardResponse) ProtoMessage()    {}
func (*ClaimWithdrawRewardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{25}
}
func (m *ClaimWithdrawRewardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimWithdrawRewardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimWithdrawRewardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimWithdrawRewardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimWithdrawRewardResponse.Merge(m, src)
}
func (m *ClaimWithdrawRewardResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClaimWithdrawRewardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimWithdrawRewardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimWithdrawRewardResponse proto.InternalMessageInfo

func (m *ClaimWithdrawRewardResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type ClaimRewardDetailsRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *ClaimRewardDetailsRequest) Reset()         { *m = ClaimRewardDetailsRequest{} }
func (m *ClaimRewardDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*ClaimRewardDetailsRequest) ProtoMessage()    {}
func (*ClaimRewardDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{26}
}
func (m *ClaimRewardDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimRewardDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimRewardDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimRewardDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimRewardDetailsRequest.Merge(m, src)
}
func (m *ClaimRewardDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClaimRewardDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimRewardDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimRewardDetailsRequest proto.InternalMessageInfo

func (m *ClaimRewardDetailsRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type ClaimRewardDetailsResponse struct {
	Err     *ErrMsg                      `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Details []*types1.RewardClaimDetails `protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty"`
}

func (m *ClaimRewardDetailsResponse) Reset()         { *m = ClaimRewardDetailsResponse{} }
func (m *ClaimRewardDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*ClaimRewardDetailsResponse) ProtoMessage()    {}
func (*ClaimRewardDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{27}
}
func (m *ClaimRewardDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimRewardDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimRewardDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimRewardDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimRewardDetailsResponse.Merge(m, src)
}
func (m *ClaimRewardDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClaimRewardDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimRewardDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimRewardDetailsResponse proto.InternalMessageInfo

func (m *ClaimRewardDetailsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *ClaimRewardDetailsResponse) GetDetails() []*types1.RewardClaimDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type QueryLiquidityStatusRequest struct {
	SeqNum  uint64 `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	LpAddr  string `protobuf:"bytes,2,opt,name=lp_addr,json=lpAddr,proto3" json:"lp_addr,omitempty"`
	ChainId uint32 `protobuf:"varint,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Type    LPType `protobuf:"varint,4,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
}

func (m *QueryLiquidityStatusRequest) Reset()         { *m = QueryLiquidityStatusRequest{} }
func (m *QueryLiquidityStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidityStatusRequest) ProtoMessage()    {}
func (*QueryLiquidityStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{28}
}
func (m *QueryLiquidityStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidityStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidityStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidityStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidityStatusRequest.Merge(m, src)
}
func (m *QueryLiquidityStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidityStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidityStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidityStatusRequest proto.InternalMessageInfo

func (m *QueryLiquidityStatusRequest) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *QueryLiquidityStatusRequest) GetLpAddr() string {
	if m != nil {
		return m.LpAddr
	}
	return ""
}

func (m *QueryLiquidityStatusRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *QueryLiquidityStatusRequest) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

type TransferHistory struct {
	TransferId      string                      `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	SrcSendInfo     *TransferInfo               `protobuf:"bytes,2,opt,name=src_send_info,json=srcSendInfo,proto3" json:"src_send_info,omitempty"`
	DstReceivedInfo *TransferInfo               `protobuf:"bytes,3,opt,name=dst_received_info,json=dstReceivedInfo,proto3" json:"dst_received_info,omitempty"`
	Ts              uint64                      `protobuf:"varint,4,opt,name=ts,proto3" json:"ts,omitempty"`
	SrcBlockTxLink  string                      `protobuf:"bytes,5,opt,name=src_block_tx_link,json=srcBlockTxLink,proto3" json:"src_block_tx_link,omitempty"`
	DstBlockTxLink  string                      `protobuf:"bytes,6,opt,name=dst_block_tx_link,json=dstBlockTxLink,proto3" json:"dst_block_tx_link,omitempty"`
	Status          types.TransferHistoryStatus `protobuf:"varint,7,opt,name=status,proto3,enum=sgn.cbridge.v1.TransferHistoryStatus" json:"status,omitempty"`
	RefundReason    types.XferStatus            `protobuf:"varint,8,opt,name=refund_reason,json=refundReason,proto3,enum=sgn.cbridge.v1.XferStatus" json:"refund_reason,omitempty"`
}

func (m *TransferHistory) Reset()         { *m = TransferHistory{} }
func (m *TransferHistory) String() string { return proto.CompactTextString(m) }
func (*TransferHistory) ProtoMessage()    {}
func (*TransferHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{29}
}
func (m *TransferHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistory.Merge(m, src)
}
func (m *TransferHistory) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistory.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistory proto.InternalMessageInfo

func (m *TransferHistory) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

func (m *TransferHistory) GetSrcSendInfo() *TransferInfo {
	if m != nil {
		return m.SrcSendInfo
	}
	return nil
}

func (m *TransferHistory) GetDstReceivedInfo() *TransferInfo {
	if m != nil {
		return m.DstReceivedInfo
	}
	return nil
}

func (m *TransferHistory) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *TransferHistory) GetSrcBlockTxLink() string {
	if m != nil {
		return m.SrcBlockTxLink
	}
	return ""
}

func (m *TransferHistory) GetDstBlockTxLink() string {
	if m != nil {
		return m.DstBlockTxLink
	}
	return ""
}

func (m *TransferHistory) GetStatus() types.TransferHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.TransferHistoryStatus_TRANSFER_UNKNOWN
}

func (m *TransferHistory) GetRefundReason() types.XferStatus {
	if m != nil {
		return m.RefundReason
	}
	return types.XferStatus_UNKNOWN
}

type LPHistory struct {
	Chain       *Chain                `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token       *TokenInfo            `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Amount      string                `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Ts          uint64                `protobuf:"varint,4,opt,name=ts,proto3" json:"ts,omitempty"`
	BlockTxLink string                `protobuf:"bytes,5,opt,name=block_tx_link,json=blockTxLink,proto3" json:"block_tx_link,omitempty"`
	Status      types.LPHistoryStatus `protobuf:"varint,6,opt,name=status,proto3,enum=sgn.cbridge.v1.LPHistoryStatus" json:"status,omitempty"`
	Type        LPType                `protobuf:"varint,7,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
	SeqNum      uint64                `protobuf:"varint,8,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
}

func (m *LPHistory) Reset()         { *m = LPHistory{} }
func (m *LPHistory) String() string { return proto.CompactTextString(m) }
func (*LPHistory) ProtoMessage()    {}
func (*LPHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{30}
}
func (m *LPHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistory.Merge(m, src)
}
func (m *LPHistory) XXX_Size() int {
	return m.Size()
}
func (m *LPHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistory.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistory proto.InternalMessageInfo

func (m *LPHistory) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *LPHistory) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *LPHistory) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *LPHistory) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *LPHistory) GetBlockTxLink() string {
	if m != nil {
		return m.BlockTxLink
	}
	return ""
}

func (m *LPHistory) GetStatus() types.LPHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.LPHistoryStatus_LP_UNKNOWN
}

func (m *LPHistory) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

func (m *LPHistory) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

type TransferHistoryRequest struct {
	NextPageToken string `protobuf:"bytes,1,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	PageSize      uint64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Addr          string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *TransferHistoryRequest) Reset()         { *m = TransferHistoryRequest{} }
func (m *TransferHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*TransferHistoryRequest) ProtoMessage()    {}
func (*TransferHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{31}
}
func (m *TransferHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistoryRequest.Merge(m, src)
}
func (m *TransferHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistoryRequest proto.InternalMessageInfo

func (m *TransferHistoryRequest) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *TransferHistoryRequest) GetPageSize() uint64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *TransferHistoryRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type TransferHistoryResponse struct {
	Err           *ErrMsg            `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	History       []*TransferHistory `protobuf:"bytes,2,rep,name=history,proto3" json:"history,omitempty"`
	NextPageToken string             `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	CurrentSize   uint64             `protobuf:"varint,4,opt,name=current_size,json=currentSize,proto3" json:"current_size,omitempty"`
}

func (m *TransferHistoryResponse) Reset()         { *m = TransferHistoryResponse{} }
func (m *TransferHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*TransferHistoryResponse) ProtoMessage()    {}
func (*TransferHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{32}
}
func (m *TransferHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistoryResponse.Merge(m, src)
}
func (m *TransferHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistoryResponse proto.InternalMessageInfo

func (m *TransferHistoryResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *TransferHistoryResponse) GetHistory() []*TransferHistory {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *TransferHistoryResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *TransferHistoryResponse) GetCurrentSize() uint64 {
	if m != nil {
		return m.CurrentSize
	}
	return 0
}

type LPHistoryRequest struct {
	NextPageToken string `protobuf:"bytes,1,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	PageSize      uint64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Addr          string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *LPHistoryRequest) Reset()         { *m = LPHistoryRequest{} }
func (m *LPHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*LPHistoryRequest) ProtoMessage()    {}
func (*LPHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{33}
}
func (m *LPHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistoryRequest.Merge(m, src)
}
func (m *LPHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *LPHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistoryRequest proto.InternalMessageInfo

func (m *LPHistoryRequest) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *LPHistoryRequest) GetPageSize() uint64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *LPHistoryRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type LPHistoryResponse struct {
	Err           *ErrMsg      `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	History       []*LPHistory `protobuf:"bytes,2,rep,name=history,proto3" json:"history,omitempty"`
	NextPageToken string       `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	CurrentSize   uint64       `protobuf:"varint,4,opt,name=current_size,json=currentSize,proto3" json:"current_size,omitempty"`
}

func (m *LPHistoryResponse) Reset()         { *m = LPHistoryResponse{} }
func (m *LPHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*LPHistoryResponse) ProtoMessage()    {}
func (*LPHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{34}
}
func (m *LPHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistoryResponse.Merge(m, src)
}
func (m *LPHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *LPHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistoryResponse proto.InternalMessageInfo

func (m *LPHistoryResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *LPHistoryResponse) GetHistory() []*LPHistory {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *LPHistoryResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *LPHistoryResponse) GetCurrentSize() uint64 {
	if m != nil {
		return m.CurrentSize
	}
	return 0
}

type RewardingDataRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *RewardingDataRequest) Reset()         { *m = RewardingDataRequest{} }
func (m *RewardingDataRequest) String() string { return proto.CompactTextString(m) }
func (*RewardingDataRequest) ProtoMessage()    {}
func (*RewardingDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{35}
}
func (m *RewardingDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardingDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardingDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardingDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardingDataRequest.Merge(m, src)
}
func (m *RewardingDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *RewardingDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardingDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RewardingDataRequest proto.InternalMessageInfo

func (m *RewardingDataRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type Reward struct {
	Amt   float64      `protobuf:"fixed64,1,opt,name=amt,proto3" json:"amt,omitempty"`
	Token *types.Token `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *Reward) Reset()         { *m = Reward{} }
func (m *Reward) String() string { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()    {}
func (*Reward) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{36}
}
func (m *Reward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reward.Merge(m, src)
}
func (m *Reward) XXX_Size() int {
	return m.Size()
}
func (m *Reward) XXX_DiscardUnknown() {
	xxx_messageInfo_Reward.DiscardUnknown(m)
}

var xxx_messageInfo_Reward proto.InternalMessageInfo

func (m *Reward) GetAmt() float64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *Reward) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type RewardingDataResponse struct {
	Err                         *ErrMsg   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	TotalFarmingRewards         float64   `protobuf:"fixed64,2,opt,name=total_farming_rewards,json=totalFarmingRewards,proto3" json:"total_farming_rewards,omitempty"`
	HistoricalCumulativeRewards []*Reward `protobuf:"bytes,3,rep,name=historical_cumulative_rewards,json=historicalCumulativeRewards,proto3" json:"historical_cumulative_rewards,omitempty"`
	UnlockedCumulativeRewards   []*Reward `protobuf:"bytes,4,rep,name=unlocked_cumulative_rewards,json=unlockedCumulativeRewards,proto3" json:"unlocked_cumulative_rewards,omitempty"`
}

func (m *RewardingDataResponse) Reset()         { *m = RewardingDataResponse{} }
func (m *RewardingDataResponse) String() string { return proto.CompactTextString(m) }
func (*RewardingDataResponse) ProtoMessage()    {}
func (*RewardingDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{37}
}
func (m *RewardingDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardingDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardingDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardingDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardingDataResponse.Merge(m, src)
}
func (m *RewardingDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *RewardingDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardingDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RewardingDataResponse proto.InternalMessageInfo

func (m *RewardingDataResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *RewardingDataResponse) GetTotalFarmingRewards() float64 {
	if m != nil {
		return m.TotalFarmingRewards
	}
	return 0
}

func (m *RewardingDataResponse) GetHistoricalCumulativeRewards() []*Reward {
	if m != nil {
		return m.HistoricalCumulativeRewards
	}
	return nil
}

func (m *RewardingDataResponse) GetUnlockedCumulativeRewards() []*Reward {
	if m != nil {
		return m.UnlockedCumulativeRewards
	}
	return nil
}

type ErrMsg struct {
	Code ErrCode `protobuf:"varint,1,opt,name=code,proto3,enum=sgn.gateway.v1.ErrCode" json:"code,omitempty"`
	Msg  string  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ErrMsg) Reset()         { *m = ErrMsg{} }
func (m *ErrMsg) String() string { return proto.CompactTextString(m) }
func (*ErrMsg) ProtoMessage()    {}
func (*ErrMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{38}
}
func (m *ErrMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrMsg.Merge(m, src)
}
func (m *ErrMsg) XXX_Size() int {
	return m.Size()
}
func (m *ErrMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ErrMsg proto.InternalMessageInfo

func (m *ErrMsg) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_ERROR_CODE_UNDEFINED
}

func (m *ErrMsg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("sgn.gateway.v1.TransferType", TransferType_name, TransferType_value)
	proto.RegisterEnum("sgn.gateway.v1.LPType", LPType_name, LPType_value)
	proto.RegisterEnum("sgn.gateway.v1.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterType((*QueryLiquidityStatusResponse)(nil), "sgn.gateway.v1.QueryLiquidityStatusResponse")
	proto.RegisterType((*Chain)(nil), "sgn.gateway.v1.Chain")
	proto.RegisterType((*ChainTokenInfo)(nil), "sgn.gateway.v1.ChainTokenInfo")
	proto.RegisterType((*TokenInfo)(nil), "sgn.gateway.v1.TokenInfo")
	proto.RegisterType((*TransferInfo)(nil), "sgn.gateway.v1.TransferInfo")
	proto.RegisterType((*SetAdvancedInfoRequest)(nil), "sgn.gateway.v1.SetAdvancedInfoRequest")
	proto.RegisterType((*SetAdvancedInfoResponse)(nil), "sgn.gateway.v1.SetAdvancedInfoResponse")
	proto.RegisterType((*GetAdvancedInfoRequest)(nil), "sgn.gateway.v1.GetAdvancedInfoRequest")
	proto.RegisterType((*GetAdvancedInfoResponse)(nil), "sgn.gateway.v1.GetAdvancedInfoResponse")
	proto.RegisterType((*GetTransferStatusRequest)(nil), "sgn.gateway.v1.GetTransferStatusRequest")
	proto.RegisterType((*GetTransferStatusResponse)(nil), "sgn.gateway.v1.GetTransferStatusResponse")
	proto.RegisterType((*GetTransferConfigsRequest)(nil), "sgn.gateway.v1.GetTransferConfigsRequest")
	proto.RegisterType((*GetTransferConfigsResponse)(nil), "sgn.gateway.v1.GetTransferConfigsResponse")
	proto.RegisterMapType((map[uint32]*ChainTokenInfo)(nil), "sgn.gateway.v1.GetTransferConfigsResponse.ChainTokenEntry")
	proto.RegisterType((*EstimateAmtRequest)(nil), "sgn.gateway.v1.EstimateAmtRequest")
	proto.RegisterType((*EstimateAmtResponse)(nil), "sgn.gateway.v1.EstimateAmtResponse")
	proto.RegisterType((*MarkTransferRequest)(nil), "sgn.gateway.v1.MarkTransferRequest")
	proto.RegisterType((*MarkTransferResponse)(nil), "sgn.gateway.v1.MarkTransferResponse")
	proto.RegisterType((*GetLPInfoListRequest)(nil), "sgn.gateway.v1.GetLPInfoListRequest")
	proto.RegisterType((*LPInfo)(nil), "sgn.gateway.v1.LPInfo")
	proto.RegisterType((*GetLPInfoListResponse)(nil), "sgn.gateway.v1.GetLPInfoListResponse")
	proto.RegisterType((*WithdrawLiquidityRequest)(nil), "sgn.gateway.v1.WithdrawLiquidityRequest")
	proto.RegisterType((*WithdrawLiquidityResponse)(nil), "sgn.gateway.v1.WithdrawLiquidityResponse")
	proto.RegisterType((*MarkLiquidityRequest)(nil), "sgn.gateway.v1.MarkLiquidityRequest")
	proto.RegisterType((*MarkLiquidityResponse)(nil), "sgn.gateway.v1.MarkLiquidityResponse")
	proto.RegisterType((*ClaimWithdrawRewardRequest)(nil), "sgn.gateway.v1.ClaimWithdrawRewardRequest")
	proto.RegisterType((*ClaimWithdrawRewardResponse)(nil), "sgn.gateway.v1.ClaimWithdrawRewardResponse")
	proto.RegisterType((*ClaimRewardDetailsRequest)(nil), "sgn.gateway.v1.ClaimRewardDetailsRequest")
	proto.RegisterType((*ClaimRewardDetailsResponse)(nil), "sgn.gateway.v1.ClaimRewardDetailsResponse")
	proto.RegisterType((*QueryLiquidityStatusRequest)(nil), "sgn.gateway.v1.QueryLiquidityStatusRequest")
	proto.RegisterType((*TransferHistory)(nil), "sgn.gateway.v1.TransferHistory")
	proto.RegisterType((*LPHistory)(nil), "sgn.gateway.v1.LPHistory")
	proto.RegisterType((*TransferHistoryRequest)(nil), "sgn.gateway.v1.TransferHistoryRequest")
	proto.RegisterType((*TransferHistoryResponse)(nil), "sgn.gateway.v1.TransferHistoryResponse")
	proto.RegisterType((*LPHistoryRequest)(nil), "sgn.gateway.v1.LPHistoryRequest")
	proto.RegisterType((*LPHistoryResponse)(nil), "sgn.gateway.v1.LPHistoryResponse")
	proto.RegisterType((*RewardingDataRequest)(nil), "sgn.gateway.v1.RewardingDataRequest")
	proto.RegisterType((*Reward)(nil), "sgn.gateway.v1.Reward")
	proto.RegisterType((*RewardingDataResponse)(nil), "sgn.gateway.v1.RewardingDataResponse")
	proto.RegisterType((*ErrMsg)(nil), "sgn.gateway.v1.ErrMsg")
}

func init() { proto.RegisterFile("sgn/gateway/v1/gateway.proto", fileDescriptor_4ec1f1e4252d2467) }

var fileDescriptor_4ec1f1e4252d2467 = []byte{
	// 2583 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xcb, 0x6f, 0x63, 0x57,
	0x19, 0x9f, 0x6b, 0x3b, 0x76, 0xfc, 0xd9, 0xb1, 0x93, 0x93, 0x97, 0xe3, 0xa4, 0x99, 0xcc, 0xed,
	0x2b, 0xcd, 0xb4, 0x71, 0x27, 0x1d, 0x09, 0x28, 0xa0, 0x36, 0x4d, 0x3c, 0x99, 0x51, 0x13, 0x67,
	0xb8, 0x49, 0x5b, 0x68, 0x55, 0xae, 0x6e, 0x7c, 0x4f, 0x9c, 0xab, 0xd8, 0xf7, 0x3a, 0xf7, 0x1c,
	0x3b, 0x49, 0x37, 0xa0, 0x0a, 0x36, 0x20, 0x21, 0x44, 0x25, 0xfe, 0x02, 0x16, 0xb0, 0x42, 0x08,
	0xb6, 0xec, 0x61, 0x57, 0x89, 0x4d, 0x61, 0x85, 0x5a, 0x36, 0x2c, 0x11, 0x6c, 0x91, 0xd0, 0x79,
	0xd9, 0xf7, 0x61, 0x67, 0xec, 0xa2, 0x41, 0xac, 0xe6, 0xfa, 0x3b, 0xbf, 0xf3, 0x3d, 0xcf, 0xf9,
	0x9d, 0xef, 0x9c, 0x09, 0xac, 0x90, 0x86, 0x5b, 0x69, 0x58, 0x14, 0x5f, 0x5a, 0xd7, 0x95, 0xee,
	0x3d, 0xf5, 0xb9, 0xd9, 0xf6, 0x3d, 0xea, 0xa1, 0x02, 0x69, 0xb8, 0x9b, 0x4a, 0xd4, 0xbd, 0x57,
	0x5e, 0x69, 0x78, 0x5e, 0xa3, 0x89, 0x2b, 0x56, 0xdb, 0xa9, 0x58, 0xae, 0xeb, 0x51, 0x8b, 0x3a,
	0x9e, 0x4b, 0x04, 0xba, 0x5c, 0x66, 0xba, 0xea, 0x27, 0xbe, 0x63, 0x37, 0x30, 0xd3, 0x75, 0xd1,
	0xc1, 0xbe, 0xd4, 0x54, 0x5e, 0x89, 0x8c, 0xc9, 0xcf, 0xe0, 0xe8, 0xa9, 0xe5, 0xb7, 0x1c, 0xb7,
	0xc1, 0x46, 0xe5, 0xa7, 0x1c, 0x5d, 0xad, 0x7b, 0xa4, 0xe5, 0x91, 0xca, 0x89, 0x45, 0xd8, 0xdc,
	0x13, 0x4c, 0xad, 0x7b, 0x95, 0xba, 0xe7, 0xb8, 0x62, 0x5c, 0xff, 0xa7, 0x06, 0x2b, 0xdf, 0x62,
	0xb6, 0xf6, 0x9d, 0x8b, 0x8e, 0x63, 0x3b, 0xf4, 0xfa, 0x88, 0x5a, 0xb4, 0x43, 0x0c, 0x4c, 0xda,
	0x9e, 0x4b, 0x30, 0x5a, 0x87, 0x24, 0xf6, 0xfd, 0x92, 0xb6, 0xa6, 0xad, 0xe7, 0xb6, 0x16, 0x36,
	0xc3, 0x41, 0x6d, 0x56, 0x7d, 0xff, 0x80, 0x34, 0x0c, 0x06, 0x41, 0x5f, 0x81, 0x34, 0xe1, 0x73,
	0x4b, 0x89, 0x35, 0x6d, 0xbd, 0xb0, 0x75, 0x9b, 0x83, 0x95, 0xb3, 0xdd, 0x7b, 0x9b, 0xfb, 0x8f,
	0x1f, 0x3a, 0x84, 0x7a, 0xbe, 0x32, 0x21, 0xe1, 0xe8, 0x19, 0x80, 0x4b, 0xdb, 0xf4, 0xdc, 0xfa,
	0x99, 0xe5, 0xb8, 0xa5, 0xe4, 0x9a, 0xb6, 0x9e, 0x37, 0xb2, 0x97, 0xf6, 0xa1, 0x10, 0xa0, 0xdb,
	0x90, 0x23, 0x9e, 0x4f, 0xb1, 0x6d, 0x12, 0xa7, 0x41, 0x4a, 0xa9, 0xb5, 0xe4, 0x7a, 0xde, 0x00,
	0x21, 0x3a, 0x72, 0x1a, 0x04, 0x95, 0x20, 0x43, 0x9c, 0x86, 0x8b, 0x7d, 0x52, 0x9a, 0xe0, 0x83,
	0xea, 0x27, 0x5a, 0x80, 0x74, 0xdb, 0xbb, 0x64, 0x03, 0x69, 0x3e, 0x20, 0x7f, 0xe9, 0x6f, 0xc0,
	0xc4, 0x0e, 0xd7, 0x5d, 0x80, 0x84, 0x63, 0xf3, 0xe0, 0xa6, 0x8c, 0x84, 0x63, 0x23, 0x04, 0x29,
	0xd7, 0x6a, 0x61, 0x1e, 0x41, 0xd6, 0xe0, 0xdf, 0x4c, 0xe6, 0xd4, 0x3d, 0xe1, 0x58, 0xd6, 0xe0,
	0xdf, 0xfa, 0x36, 0x14, 0xb8, 0x82, 0x63, 0xef, 0x1c, 0xbb, 0x8f, 0xdc, 0x53, 0x0f, 0x55, 0x60,
	0x82, 0xb2, 0x1f, 0x25, 0x6d, 0x2d, 0xb9, 0x9e, 0xdb, 0x5a, 0x8a, 0x66, 0xaa, 0x87, 0x34, 0x04,
	0x4e, 0xff, 0xa1, 0x06, 0xd9, 0xfe, 0xf4, 0xbb, 0xfd, 0xe9, 0x2c, 0xd1, 0xf3, 0xd1, 0xdc, 0x71,
	0xa4, 0x9c, 0x3a, 0xaa, 0x97, 0xe8, 0x59, 0x98, 0xaa, 0x7b, 0x2e, 0xf5, 0xad, 0x3a, 0x35, 0x2d,
	0xdb, 0xf6, 0x4b, 0x29, 0x3e, 0x98, 0x57, 0xc2, 0x6d, 0xdb, 0xf6, 0xf5, 0xef, 0x6b, 0x90, 0x3f,
	0xf6, 0x2d, 0x97, 0x9c, 0x62, 0x5f, 0xb9, 0x22, 0x2a, 0x11, 0x74, 0x25, 0x10, 0x09, 0x0f, 0xdc,
	0x10, 0x98, 0xbe, 0xdf, 0x89, 0x11, 0xfc, 0x5e, 0x80, 0xb4, 0xd5, 0xf2, 0x3a, 0x2e, 0x95, 0x5e,
	0xca, 0x5f, 0xfa, 0x07, 0xb0, 0x70, 0x84, 0xe9, 0xb6, 0xdd, 0xb5, 0xdc, 0x3a, 0xb6, 0x79, 0x92,
	0xf0, 0x45, 0x07, 0x13, 0xca, 0xa2, 0xe2, 0x8e, 0x6b, 0x22, 0x2a, 0xf6, 0x8d, 0x5e, 0x01, 0x44,
	0x9a, 0x4e, 0xbb, 0x6d, 0x35, 0xb0, 0x49, 0xbd, 0x26, 0xf6, 0xd9, 0x2c, 0x6e, 0x7f, 0xca, 0x98,
	0x51, 0x23, 0xc7, 0x6a, 0x40, 0xdf, 0x81, 0xc5, 0x98, 0xf2, 0x71, 0xd7, 0xb6, 0xfe, 0x32, 0x2c,
	0xec, 0x8d, 0xec, 0xa1, 0xee, 0xc3, 0xe2, 0xde, 0x7f, 0x6b, 0x72, 0xdc, 0x30, 0xbf, 0x0e, 0xa5,
	0x3d, 0x4c, 0x55, 0x21, 0xd5, 0x26, 0x16, 0x3e, 0xde, 0x86, 0x1c, 0x95, 0x03, 0xa6, 0x5c, 0xee,
	0x59, 0x03, 0x94, 0xe8, 0x91, 0xad, 0x7f, 0x96, 0x80, 0xa5, 0x01, 0xb3, 0xc7, 0xf6, 0xf9, 0x9b,
	0x11, 0x0a, 0x78, 0x3e, 0xb6, 0x1c, 0xa4, 0x85, 0xff, 0x13, 0x22, 0x40, 0x6f, 0xc0, 0x94, 0x8f,
	0x4f, 0x3b, 0xae, 0x6d, 0xfa, 0xd8, 0x22, 0x9e, 0x5b, 0xca, 0x70, 0xbf, 0xcb, 0x51, 0xbf, 0xbf,
	0xdd, 0xcf, 0x4a, 0x5e, 0x4c, 0x30, 0x38, 0x9e, 0xf9, 0x74, 0xd2, 0xf4, 0xea, 0xe7, 0xa6, 0x8d,
	0x9b, 0xd6, 0x75, 0x69, 0x92, 0x97, 0x07, 0xb8, 0x68, 0x97, 0x49, 0xf4, 0xe5, 0x50, 0x66, 0x77,
	0x3c, 0xf7, 0xd4, 0x69, 0xa8, 0xc2, 0xe8, 0xbf, 0x49, 0x40, 0x79, 0xd0, 0xe8, 0x97, 0x58, 0x2c,
	0x69, 0x9e, 0x23, 0x96, 0xf8, 0xe4, 0xf0, 0x4d, 0x2b, 0x41, 0xe8, 0x03, 0xc8, 0xf1, 0x2f, 0x53,
	0xec, 0xdd, 0x24, 0x9f, 0xf3, 0x7a, 0x74, 0xce, 0x70, 0xcf, 0x36, 0xfb, 0xe4, 0x57, 0x75, 0xa9,
	0x7f, 0x6d, 0x40, 0xbd, 0x27, 0x28, 0x7f, 0x08, 0xc5, 0xc8, 0x30, 0x9a, 0x86, 0xe4, 0x39, 0xbe,
	0x96, 0x3c, 0xcb, 0x3e, 0xd1, 0x7d, 0x98, 0xe8, 0x5a, 0xcd, 0x0e, 0x96, 0xbc, 0xb1, 0x3a, 0xd0,
	0xdf, 0x00, 0x67, 0x72, 0xf0, 0xeb, 0x89, 0xaf, 0x6a, 0xfa, 0x2f, 0x35, 0x40, 0x55, 0x42, 0x9d,
	0x96, 0x45, 0xf1, 0x76, 0x8b, 0xaa, 0x35, 0xbe, 0x06, 0x79, 0xe2, 0xd7, 0x4d, 0x11, 0x56, 0x8f,
	0xd3, 0x81, 0xf8, 0x75, 0xae, 0xea, 0x91, 0xcd, 0x10, 0x36, 0xa1, 0x7d, 0x84, 0xd8, 0x4a, 0x60,
	0x13, 0xaa, 0x10, 0x77, 0x20, 0xcf, 0x13, 0x62, 0x92, 0xeb, 0xd6, 0x89, 0xd7, 0x94, 0x2c, 0x95,
	0xe3, 0xb2, 0x23, 0x2e, 0x62, 0x91, 0x58, 0x2d, 0x2a, 0x89, 0x94, 0x7d, 0xa2, 0x25, 0x98, 0xec,
	0x10, 0x5f, 0xf0, 0xeb, 0x04, 0x17, 0x67, 0x3a, 0xc4, 0xe7, 0xd4, 0xfa, 0x0f, 0x0d, 0x66, 0x43,
	0xae, 0x8e, 0x5d, 0xd7, 0xbb, 0x80, 0xf0, 0x85, 0xc9, 0x83, 0x17, 0xb5, 0x32, 0x99, 0x75, 0xc1,
	0xfb, 0x45, 0x7c, 0xf1, 0x2e, 0x1b, 0xe0, 0x59, 0xda, 0x6e, 0xf1, 0x6d, 0x2e, 0x56, 0xac, 0xe9,
	0x5b, 0x14, 0x73, 0xef, 0x13, 0x06, 0x08, 0x91, 0x61, 0x51, 0xcc, 0x9c, 0x3f, 0xc5, 0x58, 0x39,
	0x7f, 0x8a, 0xf1, 0x10, 0x92, 0x99, 0x18, 0x42, 0x32, 0x2c, 0x41, 0x2d, 0xeb, 0xca, 0x54, 0x03,
	0xa5, 0x34, 0x07, 0xe6, 0x5a, 0xd6, 0xd5, 0x91, 0x14, 0xe9, 0xbf, 0x4e, 0xc0, 0xec, 0x81, 0xe5,
	0x9f, 0xab, 0x95, 0x33, 0x2a, 0x07, 0xa1, 0x37, 0x61, 0x8a, 0x15, 0x90, 0x60, 0xd7, 0x36, 0x1d,
	0xf7, 0xd4, 0x93, 0x2b, 0x63, 0x25, 0x76, 0x90, 0x06, 0xce, 0x2a, 0x23, 0x47, 0xfc, 0xfa, 0x11,
	0x76, 0x39, 0xc7, 0xa2, 0x43, 0x98, 0x67, 0x05, 0x6e, 0x39, 0xae, 0xe9, 0xe3, 0x3a, 0x76, 0xba,
	0x58, 0x6a, 0x4a, 0x8e, 0xa0, 0x09, 0xd9, 0x84, 0x1e, 0x38, 0xae, 0x21, 0x27, 0x72, 0x85, 0x8a,
	0xdb, 0x53, 0x81, 0xd3, 0x67, 0x15, 0x98, 0x4d, 0x93, 0x5e, 0x99, 0x67, 0x16, 0x39, 0x93, 0x15,
	0xcf, 0x12, 0xbf, 0x7e, 0x7c, 0xf5, 0xd0, 0x22, 0x67, 0xe8, 0x55, 0x48, 0xd1, 0xeb, 0xb6, 0x48,
	0x4d, 0x61, 0xb8, 0xcd, 0xe3, 0xeb, 0x36, 0x36, 0x38, 0x52, 0x7f, 0x13, 0xe6, 0xc2, 0x09, 0x1b,
	0xfb, 0x74, 0xda, 0x80, 0xb9, 0x3d, 0x4c, 0xf7, 0x1f, 0x33, 0xa7, 0xf7, 0x1d, 0x42, 0x6f, 0x3a,
	0x9b, 0xfe, 0x9d, 0x84, 0xb4, 0x40, 0x8e, 0x77, 0xd0, 0x57, 0xc2, 0x07, 0xfd, 0x13, 0xfb, 0x1b,
	0xb4, 0x02, 0xd9, 0xa6, 0xea, 0x29, 0x79, 0x05, 0x34, 0xa3, 0x2f, 0x60, 0xad, 0x49, 0xef, 0x87,
	0xd9, 0xdf, 0x51, 0xf9, 0x9e, 0x90, 0x2d, 0xe8, 0x57, 0x61, 0xee, 0xcc, 0x22, 0xa6, 0xec, 0x68,
	0x4d, 0x82, 0x09, 0x61, 0x2d, 0x33, 0x4f, 0xfa, 0xa4, 0x81, 0xce, 0x2c, 0xf2, 0x40, 0x0c, 0x1d,
	0xc9, 0x11, 0xf4, 0x1c, 0x14, 0x9a, 0x6d, 0xf3, 0x14, 0x63, 0x13, 0x5b, 0xbe, 0xeb, 0xb8, 0x0d,
	0x5e, 0x07, 0xcd, 0xc8, 0x37, 0xdb, 0x0f, 0x30, 0xae, 0x0a, 0x19, 0xba, 0x0f, 0x0b, 0x4a, 0xa7,
	0x8f, 0x2f, 0x2d, 0xdf, 0xee, 0xa1, 0x33, 0x1c, 0x3d, 0x27, 0x47, 0x0d, 0x3e, 0xa8, 0x66, 0x3d,
	0x03, 0xd0, 0xf5, 0x9a, 0x9d, 0x16, 0x36, 0xb7, 0xee, 0x9f, 0x71, 0xa6, 0xd7, 0x8c, 0xac, 0x90,
	0x6c, 0xdd, 0x3f, 0x43, 0x2f, 0x42, 0x91, 0x7a, 0xd4, 0x6a, 0x9a, 0xfd, 0xa8, 0xb3, 0x1c, 0x53,
	0xe0, 0xe2, 0x5e, 0x7f, 0x8d, 0x36, 0x61, 0x36, 0x02, 0xe4, 0x09, 0x00, 0x9e, 0x80, 0x99, 0x30,
	0x98, 0x65, 0xe1, 0x2e, 0xa0, 0x70, 0x4c, 0xa6, 0xd5, 0xbe, 0x2e, 0xe5, 0xb8, 0xee, 0x62, 0x30,
	0xae, 0xed, 0xf6, 0x35, 0xdb, 0x66, 0x2a, 0x34, 0x86, 0xca, 0x73, 0x14, 0x48, 0xd1, 0x76, 0xfb,
	0x5a, 0xf7, 0x61, 0x3e, 0xb2, 0x56, 0xc6, 0x26, 0xa5, 0x0a, 0x64, 0x9a, 0x6d, 0xb5, 0x47, 0x93,
	0x83, 0xd0, 0x42, 0xbd, 0x91, 0x6e, 0xb6, 0xd9, 0xbf, 0xfa, 0x5f, 0x34, 0x28, 0xbd, 0xe7, 0xd0,
	0x33, 0xdb, 0xb7, 0x2e, 0x7b, 0xa1, 0x8d, 0x4c, 0x0c, 0xcf, 0xb2, 0x33, 0x9a, 0xef, 0x4a, 0xc9,
	0xb2, 0x82, 0xfe, 0xf2, 0x4a, 0xc8, 0xa8, 0x76, 0x58, 0x6b, 0xc9, 0x8a, 0x26, 0x79, 0xb3, 0xbf,
	0x91, 0xb3, 0x5c, 0xc2, 0xa7, 0x2d, 0xc1, 0x64, 0xef, 0x3c, 0x10, 0xac, 0x97, 0xa9, 0xcb, 0xc3,
	0x60, 0x0e, 0x26, 0x7c, 0x7c, 0xe1, 0xd8, 0x7c, 0x05, 0xa5, 0x0c, 0xf1, 0x83, 0x51, 0x28, 0x71,
	0xc4, 0x3a, 0xc9, 0x1b, 0xec, 0x53, 0xff, 0x2e, 0x2c, 0x0d, 0x88, 0x6d, 0xec, 0xa4, 0x2e, 0x42,
	0x86, 0xe0, 0x0b, 0xd3, 0xed, 0xb4, 0x78, 0x7c, 0x29, 0x23, 0x4d, 0xf0, 0x45, 0xad, 0xd3, 0xd2,
	0xff, 0xac, 0x09, 0x7e, 0x88, 0x25, 0x6e, 0x91, 0x97, 0x21, 0xb0, 0xc1, 0xd3, 0xcd, 0x36, 0x0f,
	0x4a, 0x9e, 0x51, 0x89, 0xfe, 0x19, 0x15, 0xce, 0x42, 0xf2, 0xa6, 0x2c, 0xa4, 0xc2, 0x59, 0x08,
	0xb8, 0x35, 0x11, 0x74, 0x8b, 0x0d, 0x28, 0x0e, 0x4c, 0x0b, 0xeb, 0x54, 0x10, 0xe0, 0x86, 0x24,
	0x40, 0xd1, 0x49, 0x0d, 0x58, 0x1a, 0x01, 0xea, 0xdb, 0x86, 0xf9, 0x48, 0x68, 0x63, 0x73, 0xdf,
	0xab, 0x50, 0xde, 0x69, 0x5a, 0x4e, 0x4b, 0xd5, 0x40, 0xec, 0xd9, 0x9b, 0x18, 0x70, 0x0f, 0x96,
	0x07, 0xce, 0x18, 0xdb, 0x74, 0x05, 0x96, 0xb8, 0x22, 0xa1, 0x60, 0x17, 0x53, 0xcb, 0x69, 0x92,
	0x9b, 0x2c, 0xff, 0x40, 0x93, 0xce, 0x46, 0x66, 0x8c, 0xbd, 0x58, 0xbe, 0x01, 0x19, 0x5b, 0x4c,
	0x96, 0x3b, 0x50, 0xe7, 0x68, 0x75, 0xf5, 0xef, 0xde, 0xdb, 0x14, 0x16, 0xb8, 0x31, 0x65, 0x46,
	0x4d, 0xd1, 0x7f, 0xae, 0xc1, 0xf2, 0xe0, 0x3b, 0x7f, 0x6f, 0x61, 0xa9, 0x9a, 0x6b, 0xd1, 0x9a,
	0xab, 0x15, 0x97, 0x08, 0xad, 0xb8, 0xe0, 0x02, 0x4a, 0x86, 0x17, 0x90, 0x5a, 0x0e, 0xa9, 0x11,
	0x96, 0xc3, 0x2f, 0x92, 0x50, 0x8c, 0xdc, 0x10, 0xfe, 0x17, 0x7d, 0xc3, 0x43, 0x98, 0x61, 0x7d,
	0xc3, 0xf8, 0x3d, 0x43, 0xd1, 0x66, 0xfc, 0x19, 0x68, 0x18, 0x0a, 0x90, 0xa0, 0x84, 0x87, 0x9a,
	0x32, 0x12, 0x94, 0xa0, 0x97, 0x60, 0x86, 0xf9, 0x26, 0x6e, 0x08, 0xf4, 0xca, 0x6c, 0x3a, 0xee,
	0xb9, 0x6c, 0x19, 0x0a, 0xc4, 0xaf, 0xbf, 0xc5, 0xe4, 0xc7, 0x57, 0xfb, 0x8e, 0x7b, 0xce, 0xa0,
	0xcc, 0x89, 0x30, 0x54, 0xec, 0xac, 0x82, 0x4d, 0x68, 0x10, 0xda, 0xbf, 0x65, 0x65, 0xbe, 0xcc,
	0x2d, 0x2b, 0x76, 0xe7, 0x99, 0x1c, 0xef, 0xce, 0xa3, 0xff, 0x36, 0x01, 0xd9, 0xde, 0x5b, 0xce,
	0x53, 0xee, 0x22, 0x86, 0xf1, 0x7a, 0x34, 0xd3, 0x3a, 0x4c, 0x0d, 0xca, 0xb2, 0xb8, 0x9c, 0xc9,
	0xbc, 0xf5, 0x1f, 0xa8, 0xd2, 0xe3, 0x3d, 0x50, 0x8d, 0x41, 0x69, 0xc1, 0xcd, 0x33, 0x19, 0xe2,
	0xf1, 0x0b, 0x58, 0x88, 0xd4, 0x45, 0xed, 0xb7, 0x17, 0xa0, 0xe8, 0xe2, 0x2b, 0x6a, 0xca, 0x2e,
	0x5c, 0xbd, 0x02, 0x65, 0x8d, 0x29, 0x26, 0x7e, 0xcc, 0x3b, 0x70, 0x96, 0x8b, 0x65, 0xc8, 0x72,
	0x08, 0x71, 0x3e, 0xc2, 0xf2, 0x90, 0x98, 0x64, 0x82, 0x23, 0xe7, 0x23, 0xdc, 0xe3, 0x9b, 0x64,
	0x80, 0x6f, 0xfe, 0xa8, 0xc1, 0x62, 0xcc, 0xe6, 0xd8, 0x64, 0xf3, 0x35, 0xc8, 0x9c, 0x89, 0xc9,
	0x92, 0x6c, 0x6e, 0x0f, 0xdb, 0x14, 0xca, 0x86, 0xc2, 0x0f, 0x8a, 0x2c, 0x39, 0x28, 0xb2, 0x3b,
	0x90, 0xaf, 0x77, 0x7c, 0x1f, 0xbb, 0x54, 0x04, 0x27, 0xea, 0x9a, 0x93, 0x32, 0x16, 0x9f, 0x7e,
	0x0e, 0xd3, 0xbd, 0xf2, 0x3c, 0xf5, 0xc4, 0xfd, 0x5e, 0x83, 0x99, 0x80, 0xb5, 0xb1, 0x53, 0xf6,
	0x5a, 0x34, 0x65, 0x4b, 0xf1, 0x35, 0xf3, 0x34, 0x93, 0xb5, 0x01, 0x73, 0xe2, 0x00, 0x70, 0xdc,
	0xc6, 0xae, 0x45, 0xad, 0x9b, 0x8f, 0xc3, 0xb4, 0xc0, 0xaa, 0xbe, 0x41, 0xe3, 0x3d, 0x23, 0xef,
	0x1b, 0xc6, 0x79, 0xdd, 0xd3, 0x7f, 0x95, 0x80, 0xf9, 0x88, 0xd5, 0xb1, 0x13, 0xb7, 0x05, 0xf3,
	0xa2, 0x37, 0x0e, 0xf7, 0xe7, 0xe2, 0x3d, 0x49, 0x33, 0x44, 0xe3, 0xfc, 0x20, 0xd8, 0x9d, 0x13,
	0xf4, 0x3e, 0x3c, 0x23, 0x52, 0xe8, 0xd4, 0xad, 0xa6, 0x59, 0xef, 0xb4, 0x3a, 0x4d, 0x8b, 0x3a,
	0x5d, 0xdc, 0x9b, 0x9b, 0x1c, 0xdc, 0xa4, 0xca, 0x73, 0x7f, 0xb9, 0x3f, 0x79, 0xa7, 0x37, 0x57,
	0xe9, 0x7e, 0x17, 0x96, 0x3b, 0x2e, 0xa3, 0x10, 0x6c, 0x0f, 0xd2, 0x9c, 0xba, 0x51, 0xf3, 0x92,
	0x9a, 0x1a, 0xd3, 0xcb, 0x92, 0x2e, 0xc2, 0x46, 0x77, 0x21, 0x55, 0xf7, 0x6c, 0xcc, 0x93, 0x53,
	0xd8, 0x5a, 0x1c, 0x90, 0x9c, 0x1d, 0xcf, 0xc6, 0x06, 0x07, 0xb1, 0x0a, 0xb5, 0x48, 0x43, 0x75,
	0x76, 0x2d, 0xd2, 0xd8, 0xf8, 0xa0, 0xff, 0x78, 0xcb, 0x48, 0x08, 0x2d, 0xc1, 0xfc, 0xb1, 0xb1,
	0x5d, 0x3b, 0x7a, 0x50, 0x35, 0xcc, 0xe3, 0xef, 0x3c, 0xae, 0x9a, 0xef, 0xd4, 0xde, 0xae, 0x1d,
	0xbe, 0x57, 0x9b, 0xbe, 0x85, 0x16, 0x00, 0x85, 0x87, 0x8e, 0xaa, 0xb5, 0xdd, 0x69, 0x0d, 0x95,
	0x60, 0x2e, 0x2c, 0x37, 0xaa, 0x0f, 0xde, 0xa9, 0xed, 0x4e, 0x27, 0x36, 0xde, 0x62, 0x57, 0x45,
	0xae, 0x76, 0x16, 0x8a, 0xfb, 0x8f, 0xa3, 0x0a, 0x8b, 0x90, 0x53, 0xc2, 0xed, 0x5d, 0xa6, 0x09,
	0x41, 0x41, 0x09, 0x8c, 0xea, 0xc1, 0xe1, 0xbb, 0xd5, 0xe9, 0xc4, 0xc6, 0x87, 0x90, 0x91, 0x31,
	0x30, 0x43, 0x55, 0xc3, 0x38, 0x34, 0xcc, 0x9d, 0xc3, 0x5d, 0xa6, 0x67, 0xb7, 0xfa, 0xe0, 0x51,
	0xad, 0xba, 0xcb, 0x5d, 0x9b, 0x09, 0x8c, 0xec, 0x1c, 0x1e, 0x1c, 0x1c, 0xd6, 0xa6, 0xff, 0x95,
	0x44, 0x6b, 0xb0, 0x2c, 0xe4, 0xb5, 0x43, 0xf3, 0xf8, 0xf0, 0xed, 0x6a, 0xcd, 0x3c, 0xac, 0x99,
	0xbb, 0x47, 0xc7, 0xe6, 0xce, 0xc3, 0xed, 0x47, 0xb5, 0xe9, 0xbf, 0x67, 0xb6, 0x7e, 0x57, 0x84,
	0xe4, 0x7b, 0xf8, 0x04, 0x7d, 0xac, 0x41, 0x31, 0xf2, 0xcc, 0x8b, 0x5e, 0x88, 0x26, 0x73, 0xf0,
	0x23, 0x73, 0xf9, 0xc5, 0x27, 0xe2, 0xc4, 0x3a, 0xd6, 0x57, 0x3f, 0xfe, 0xd3, 0xdf, 0x3e, 0x49,
	0x94, 0xf4, 0xd9, 0x4a, 0xf7, 0x5e, 0x85, 0x84, 0x41, 0xaf, 0x6b, 0x1b, 0xdc, 0x89, 0xbd, 0x27,
	0x39, 0xb1, 0x37, 0xa2, 0x13, 0x7b, 0xa3, 0x38, 0xd1, 0x88, 0x3b, 0xf1, 0x63, 0x0d, 0x50, 0xfc,
	0xe5, 0x0e, 0xbd, 0x34, 0xca, 0xeb, 0x9e, 0x70, 0x65, 0x63, 0xf4, 0x87, 0x40, 0xe5, 0x0d, 0x5a,
	0x90, 0xde, 0x44, 0xcd, 0x7a, 0x90, 0x0b, 0xbc, 0x80, 0x21, 0x3d, 0xb6, 0xbe, 0x63, 0x2f, 0x79,
	0xe5, 0x67, 0x6f, 0xc4, 0x48, 0xbb, 0x8b, 0xdc, 0xee, 0x0c, 0x2a, 0x32, 0xbb, 0x38, 0x60, 0xa1,
	0x0b, 0xf9, 0xe0, 0x6b, 0x0a, 0x8a, 0x69, 0x1b, 0xf0, 0x38, 0x55, 0x7e, 0xee, 0x66, 0x90, 0xb4,
	0xb9, 0xcc, 0x6d, 0xce, 0xeb, 0xd3, 0xcc, 0x66, 0x2b, 0x80, 0x60, 0x69, 0xff, 0x91, 0x06, 0x33,
	0xb1, 0x27, 0x74, 0xb4, 0x7e, 0x43, 0x2a, 0x43, 0x4d, 0x77, 0xf9, 0xa5, 0x11, 0x90, 0xd2, 0x8f,
	0x35, 0xee, 0x47, 0x59, 0x9f, 0x8f, 0xe4, 0x5c, 0xc0, 0x98, 0x33, 0x97, 0x30, 0x15, 0xba, 0xe4,
	0xa3, 0xe7, 0x06, 0x68, 0x8f, 0xbd, 0x17, 0x95, 0x9f, 0x7f, 0x02, 0x4a, 0xda, 0x5f, 0xe2, 0xf6,
	0x67, 0xd1, 0x8c, 0xb4, 0x1f, 0xb0, 0xf3, 0x11, 0x4c, 0x85, 0x2e, 0x74, 0x68, 0x60, 0x66, 0xa3,
	0x57, 0xd9, 0xb8, 0xe1, 0x81, 0xb7, 0x42, 0x7d, 0x85, 0x1b, 0x5e, 0xd0, 0x67, 0x54, 0x01, 0x7a,
	0x10, 0x55, 0x81, 0xd8, 0x4d, 0x3c, 0x5e, 0x81, 0x61, 0x0f, 0x11, 0xf1, 0x0a, 0x0c, 0xbd, 0xd6,
	0x87, 0x2b, 0x70, 0x19, 0x85, 0x31, 0x67, 0x3e, 0xd1, 0x60, 0x6e, 0xd0, 0x1d, 0x0b, 0xdd, 0x8d,
	0x5a, 0xb9, 0xe1, 0x26, 0x56, 0x7e, 0x79, 0x34, 0x70, 0xd8, 0x2b, 0x54, 0xea, 0xfd, 0x07, 0x72,
	0xd4, 0xf8, 0xcf, 0x34, 0x98, 0x1d, 0x70, 0xf7, 0x45, 0xb1, 0x1d, 0x3f, 0xfc, 0x4a, 0x5d, 0xbe,
	0x3b, 0x12, 0x56, 0xba, 0xa4, 0x73, 0x97, 0x56, 0xf4, 0x45, 0xfe, 0xff, 0xd6, 0x71, 0x20, 0x4b,
	0xd5, 0x4f, 0x34, 0x40, 0xf1, 0x5b, 0x71, 0x9c, 0xb0, 0x86, 0xde, 0xb5, 0xcb, 0x1b, 0xa3, 0x40,
	0xa5, 0x47, 0x77, 0xb8, 0x47, 0xcb, 0xfa, 0x42, 0xcf, 0xa3, 0x10, 0x8e, 0x39, 0xf4, 0xbd, 0xf8,
	0x2d, 0xf4, 0x85, 0x27, 0xb5, 0xbc, 0xc3, 0x58, 0x7c, 0x48, 0xfb, 0xad, 0xb8, 0x04, 0x71, 0x16,
	0xa7, 0x11, 0x6b, 0x8d, 0xe0, 0xfd, 0x6a, 0x6d, 0x78, 0xeb, 0x28, 0x8d, 0xde, 0xb9, 0x01, 0x21,
	0xcd, 0xcd, 0x73, 0x73, 0x45, 0x34, 0xc5, 0xcc, 0x35, 0xdb, 0x4a, 0xf7, 0x25, 0x4c, 0x85, 0x3a,
	0xb6, 0xf8, 0x76, 0x1d, 0xd4, 0x46, 0xc6, 0xb7, 0xeb, 0xc0, 0xb6, 0x2f, 0xcc, 0x13, 0x7e, 0x10,
	0xf2, 0xd6, 0xc3, 0x3f, 0x7c, 0xbe, 0xaa, 0x7d, 0xfa, 0xf9, 0xaa, 0xf6, 0xd7, 0xcf, 0x57, 0xb5,
	0x9f, 0x7e, 0xb1, 0x7a, 0xeb, 0xd3, 0x2f, 0x56, 0x6f, 0x7d, 0xf6, 0xc5, 0xea, 0xad, 0xf7, 0x37,
	0x1b, 0x0e, 0x3d, 0xeb, 0x9c, 0x6c, 0xd6, 0xbd, 0x56, 0xa5, 0x8e, 0x9b, 0xd8, 0x7f, 0xc5, 0xc5,
	0xf4, 0xd2, 0xf3, 0xcf, 0x2b, 0xa4, 0xe1, 0xbe, 0xd2, 0xdd, 0xea, 0xfd, 0xc1, 0xc5, 0x25, 0x3e,
	0xb1, 0xda, 0xce, 0x49, 0x9a, 0xff, 0x1d, 0xc3, 0x6b, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x23,
	0x7e, 0xa4, 0xd4, 0x8d, 0x21, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WebClient is the client API for Web service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WebClient interface {
	// current only for slippage_tolerance setting
	SetAdvancedInfo(ctx context.Context, in *SetAdvancedInfoRequest, opts ...grpc.CallOption) (*SetAdvancedInfoResponse, error)
	// current only for slippage_tolerance setting
	GetAdvancedInfo(ctx context.Context, in *GetAdvancedInfoRequest, opts ...grpc.CallOption) (*GetAdvancedInfoResponse, error)
	// get chain and token selector
	// after getting these info, remember to record them(especially decimal)
	GetTransferConfigs(ctx context.Context, in *GetTransferConfigsRequest, opts ...grpc.CallOption) (*GetTransferConfigsResponse, error)
	// estimate transfer fee
	EstimateAmt(ctx context.Context, in *EstimateAmtRequest, opts ...grpc.CallOption) (*EstimateAmtResponse, error)
	// same as V1, call this api after user confirm transfer on metamask
	MarkTransfer(ctx context.Context, in *MarkTransferRequest, opts ...grpc.CallOption) (*MarkTransferResponse, error)
	GetTransferStatus(ctx context.Context, in *GetTransferStatusRequest, opts ...grpc.CallOption) (*GetTransferStatusResponse, error)
	//LP
	// get LP table info
	GetLPInfoList(ctx context.Context, in *GetLPInfoListRequest, opts ...grpc.CallOption) (*GetLPInfoListResponse, error)
	MarkLiquidity(ctx context.Context, in *MarkLiquidityRequest, opts ...grpc.CallOption) (*MarkLiquidityResponse, error)
	//https://github.com/celer-network/sgn-v2/blob/main/proto/sgn/cbridge/v1/tx.proto#L10
	// remove liquidity or refund transfer calling this api
	WithdrawLiquidity(ctx context.Context, in *WithdrawLiquidityRequest, opts ...grpc.CallOption) (*WithdrawLiquidityResponse, error)
	// bcz it's time cost for sgn voting, so we need a polling api to check the status
	QueryLiquidityStatus(ctx context.Context, in *QueryLiquidityStatusRequest, opts ...grpc.CallOption) (*QueryLiquidityStatusResponse, error)
	// web will use this api to init reward cliam
	ClaimWithdrawReward(ctx context.Context, in *ClaimWithdrawRewardRequest, opts ...grpc.CallOption) (*ClaimWithdrawRewardResponse, error)
	// web polling this api after ClaimWithdrawReward
	ClaimRewardDetails(ctx context.Context, in *ClaimRewardDetailsRequest, opts ...grpc.CallOption) (*ClaimRewardDetailsResponse, error)
	//History
	TransferHistory(ctx context.Context, in *TransferHistoryRequest, opts ...grpc.CallOption) (*TransferHistoryResponse, error)
	LPHistory(ctx context.Context, in *LPHistoryRequest, opts ...grpc.CallOption) (*LPHistoryResponse, error)
	RewardingData(ctx context.Context, in *RewardingDataRequest, opts ...grpc.CallOption) (*RewardingDataResponse, error)
}

type webClient struct {
	cc grpc1.ClientConn
}

func NewWebClient(cc grpc1.ClientConn) WebClient {
	return &webClient{cc}
}

func (c *webClient) SetAdvancedInfo(ctx context.Context, in *SetAdvancedInfoRequest, opts ...grpc.CallOption) (*SetAdvancedInfoResponse, error) {
	out := new(SetAdvancedInfoResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/SetAdvancedInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetAdvancedInfo(ctx context.Context, in *GetAdvancedInfoRequest, opts ...grpc.CallOption) (*GetAdvancedInfoResponse, error) {
	out := new(GetAdvancedInfoResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetAdvancedInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTransferConfigs(ctx context.Context, in *GetTransferConfigsRequest, opts ...grpc.CallOption) (*GetTransferConfigsResponse, error) {
	out := new(GetTransferConfigsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTransferConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) EstimateAmt(ctx context.Context, in *EstimateAmtRequest, opts ...grpc.CallOption) (*EstimateAmtResponse, error) {
	out := new(EstimateAmtResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/EstimateAmt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) MarkTransfer(ctx context.Context, in *MarkTransferRequest, opts ...grpc.CallOption) (*MarkTransferResponse, error) {
	out := new(MarkTransferResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/MarkTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTransferStatus(ctx context.Context, in *GetTransferStatusRequest, opts ...grpc.CallOption) (*GetTransferStatusResponse, error) {
	out := new(GetTransferStatusResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTransferStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetLPInfoList(ctx context.Context, in *GetLPInfoListRequest, opts ...grpc.CallOption) (*GetLPInfoListResponse, error) {
	out := new(GetLPInfoListResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetLPInfoList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) MarkLiquidity(ctx context.Context, in *MarkLiquidityRequest, opts ...grpc.CallOption) (*MarkLiquidityResponse, error) {
	out := new(MarkLiquidityResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/MarkLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) WithdrawLiquidity(ctx context.Context, in *WithdrawLiquidityRequest, opts ...grpc.CallOption) (*WithdrawLiquidityResponse, error) {
	out := new(WithdrawLiquidityResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/WithdrawLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) QueryLiquidityStatus(ctx context.Context, in *QueryLiquidityStatusRequest, opts ...grpc.CallOption) (*QueryLiquidityStatusResponse, error) {
	out := new(QueryLiquidityStatusResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/QueryLiquidityStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) ClaimWithdrawReward(ctx context.Context, in *ClaimWithdrawRewardRequest, opts ...grpc.CallOption) (*ClaimWithdrawRewardResponse, error) {
	out := new(ClaimWithdrawRewardResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/ClaimWithdrawReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) ClaimRewardDetails(ctx context.Context, in *ClaimRewardDetailsRequest, opts ...grpc.CallOption) (*ClaimRewardDetailsResponse, error) {
	out := new(ClaimRewardDetailsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/ClaimRewardDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) TransferHistory(ctx context.Context, in *TransferHistoryRequest, opts ...grpc.CallOption) (*TransferHistoryResponse, error) {
	out := new(TransferHistoryResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/TransferHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) LPHistory(ctx context.Context, in *LPHistoryRequest, opts ...grpc.CallOption) (*LPHistoryResponse, error) {
	out := new(LPHistoryResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/LPHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) RewardingData(ctx context.Context, in *RewardingDataRequest, opts ...grpc.CallOption) (*RewardingDataResponse, error) {
	out := new(RewardingDataResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/RewardingData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebServer is the server API for Web service.
type WebServer interface {
	// current only for slippage_tolerance setting
	SetAdvancedInfo(context.Context, *SetAdvancedInfoRequest) (*SetAdvancedInfoResponse, error)
	// current only for slippage_tolerance setting
	GetAdvancedInfo(context.Context, *GetAdvancedInfoRequest) (*GetAdvancedInfoResponse, error)
	// get chain and token selector
	// after getting these info, remember to record them(especially decimal)
	GetTransferConfigs(context.Context, *GetTransferConfigsRequest) (*GetTransferConfigsResponse, error)
	// estimate transfer fee
	EstimateAmt(context.Context, *EstimateAmtRequest) (*EstimateAmtResponse, error)
	// same as V1, call this api after user confirm transfer on metamask
	MarkTransfer(context.Context, *MarkTransferRequest) (*MarkTransferResponse, error)
	GetTransferStatus(context.Context, *GetTransferStatusRequest) (*GetTransferStatusResponse, error)
	//LP
	// get LP table info
	GetLPInfoList(context.Context, *GetLPInfoListRequest) (*GetLPInfoListResponse, error)
	MarkLiquidity(context.Context, *MarkLiquidityRequest) (*MarkLiquidityResponse, error)
	//https://github.com/celer-network/sgn-v2/blob/main/proto/sgn/cbridge/v1/tx.proto#L10
	// remove liquidity or refund transfer calling this api
	WithdrawLiquidity(context.Context, *WithdrawLiquidityRequest) (*WithdrawLiquidityResponse, error)
	// bcz it's time cost for sgn voting, so we need a polling api to check the status
	QueryLiquidityStatus(context.Context, *QueryLiquidityStatusRequest) (*QueryLiquidityStatusResponse, error)
	// web will use this api to init reward cliam
	ClaimWithdrawReward(context.Context, *ClaimWithdrawRewardRequest) (*ClaimWithdrawRewardResponse, error)
	// web polling this api after ClaimWithdrawReward
	ClaimRewardDetails(context.Context, *ClaimRewardDetailsRequest) (*ClaimRewardDetailsResponse, error)
	//History
	TransferHistory(context.Context, *TransferHistoryRequest) (*TransferHistoryResponse, error)
	LPHistory(context.Context, *LPHistoryRequest) (*LPHistoryResponse, error)
	RewardingData(context.Context, *RewardingDataRequest) (*RewardingDataResponse, error)
}

// UnimplementedWebServer can be embedded to have forward compatible implementations.
type UnimplementedWebServer struct {
}

func (*UnimplementedWebServer) SetAdvancedInfo(ctx context.Context, req *SetAdvancedInfoRequest) (*SetAdvancedInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAdvancedInfo not implemented")
}
func (*UnimplementedWebServer) GetAdvancedInfo(ctx context.Context, req *GetAdvancedInfoRequest) (*GetAdvancedInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdvancedInfo not implemented")
}
func (*UnimplementedWebServer) GetTransferConfigs(ctx context.Context, req *GetTransferConfigsRequest) (*GetTransferConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransferConfigs not implemented")
}
func (*UnimplementedWebServer) EstimateAmt(ctx context.Context, req *EstimateAmtRequest) (*EstimateAmtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateAmt not implemented")
}
func (*UnimplementedWebServer) MarkTransfer(ctx context.Context, req *MarkTransferRequest) (*MarkTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkTransfer not implemented")
}
func (*UnimplementedWebServer) GetTransferStatus(ctx context.Context, req *GetTransferStatusRequest) (*GetTransferStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransferStatus not implemented")
}
func (*UnimplementedWebServer) GetLPInfoList(ctx context.Context, req *GetLPInfoListRequest) (*GetLPInfoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLPInfoList not implemented")
}
func (*UnimplementedWebServer) MarkLiquidity(ctx context.Context, req *MarkLiquidityRequest) (*MarkLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkLiquidity not implemented")
}
func (*UnimplementedWebServer) WithdrawLiquidity(ctx context.Context, req *WithdrawLiquidityRequest) (*WithdrawLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawLiquidity not implemented")
}
func (*UnimplementedWebServer) QueryLiquidityStatus(ctx context.Context, req *QueryLiquidityStatusRequest) (*QueryLiquidityStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryLiquidityStatus not implemented")
}
func (*UnimplementedWebServer) ClaimWithdrawReward(ctx context.Context, req *ClaimWithdrawRewardRequest) (*ClaimWithdrawRewardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimWithdrawReward not implemented")
}
func (*UnimplementedWebServer) ClaimRewardDetails(ctx context.Context, req *ClaimRewardDetailsRequest) (*ClaimRewardDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimRewardDetails not implemented")
}
func (*UnimplementedWebServer) TransferHistory(ctx context.Context, req *TransferHistoryRequest) (*TransferHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferHistory not implemented")
}
func (*UnimplementedWebServer) LPHistory(ctx context.Context, req *LPHistoryRequest) (*LPHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LPHistory not implemented")
}
func (*UnimplementedWebServer) RewardingData(ctx context.Context, req *RewardingDataRequest) (*RewardingDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardingData not implemented")
}

func RegisterWebServer(s grpc1.Server, srv WebServer) {
	s.RegisterService(&_Web_serviceDesc, srv)
}

func _Web_SetAdvancedInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAdvancedInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).SetAdvancedInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/SetAdvancedInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).SetAdvancedInfo(ctx, req.(*SetAdvancedInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetAdvancedInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdvancedInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetAdvancedInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetAdvancedInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetAdvancedInfo(ctx, req.(*GetAdvancedInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTransferConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransferConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTransferConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTransferConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTransferConfigs(ctx, req.(*GetTransferConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_EstimateAmt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateAmtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).EstimateAmt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/EstimateAmt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).EstimateAmt(ctx, req.(*EstimateAmtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_MarkTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).MarkTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/MarkTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).MarkTransfer(ctx, req.(*MarkTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTransferStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransferStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTransferStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTransferStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTransferStatus(ctx, req.(*GetTransferStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetLPInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLPInfoListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetLPInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetLPInfoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetLPInfoList(ctx, req.(*GetLPInfoListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_MarkLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).MarkLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/MarkLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).MarkLiquidity(ctx, req.(*MarkLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_WithdrawLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).WithdrawLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/WithdrawLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).WithdrawLiquidity(ctx, req.(*WithdrawLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_QueryLiquidityStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLiquidityStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).QueryLiquidityStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/QueryLiquidityStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).QueryLiquidityStatus(ctx, req.(*QueryLiquidityStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_ClaimWithdrawReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimWithdrawRewardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).ClaimWithdrawReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/ClaimWithdrawReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).ClaimWithdrawReward(ctx, req.(*ClaimWithdrawRewardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_ClaimRewardDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimRewardDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).ClaimRewardDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/ClaimRewardDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).ClaimRewardDetails(ctx, req.(*ClaimRewardDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_TransferHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).TransferHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/TransferHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).TransferHistory(ctx, req.(*TransferHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_LPHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LPHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).LPHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/LPHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).LPHistory(ctx, req.(*LPHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_RewardingData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardingDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).RewardingData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/RewardingData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).RewardingData(ctx, req.(*RewardingDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Web_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sgn.gateway.v1.Web",
	HandlerType: (*WebServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetAdvancedInfo",
			Handler:    _Web_SetAdvancedInfo_Handler,
		},
		{
			MethodName: "GetAdvancedInfo",
			Handler:    _Web_GetAdvancedInfo_Handler,
		},
		{
			MethodName: "GetTransferConfigs",
			Handler:    _Web_GetTransferConfigs_Handler,
		},
		{
			MethodName: "EstimateAmt",
			Handler:    _Web_EstimateAmt_Handler,
		},
		{
			MethodName: "MarkTransfer",
			Handler:    _Web_MarkTransfer_Handler,
		},
		{
			MethodName: "GetTransferStatus",
			Handler:    _Web_GetTransferStatus_Handler,
		},
		{
			MethodName: "GetLPInfoList",
			Handler:    _Web_GetLPInfoList_Handler,
		},
		{
			MethodName: "MarkLiquidity",
			Handler:    _Web_MarkLiquidity_Handler,
		},
		{
			MethodName: "WithdrawLiquidity",
			Handler:    _Web_WithdrawLiquidity_Handler,
		},
		{
			MethodName: "QueryLiquidityStatus",
			Handler:    _Web_QueryLiquidityStatus_Handler,
		},
		{
			MethodName: "ClaimWithdrawReward",
			Handler:    _Web_ClaimWithdrawReward_Handler,
		},
		{
			MethodName: "ClaimRewardDetails",
			Handler:    _Web_ClaimRewardDetails_Handler,
		},
		{
			MethodName: "TransferHistory",
			Handler:    _Web_TransferHistory_Handler,
		},
		{
			MethodName: "LPHistory",
			Handler:    _Web_LPHistory_Handler,
		},
		{
			MethodName: "RewardingData",
			Handler:    _Web_RewardingData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sgn/gateway/v1/gateway.proto",
}

func (m *QueryLiquidityStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidityStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidityStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Powers) > 0 {
		for iNdEx := len(m.Powers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Powers[iNdEx])
			copy(dAtA[i:], m.Powers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Powers[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SortedSigs[iNdEx])
			copy(dAtA[i:], m.SortedSigs[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.SortedSigs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.WdOnchain) > 0 {
		i -= len(m.WdOnchain)
		copy(dAtA[i:], m.WdOnchain)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WdOnchain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Chain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChainTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		for iNdEx := len(m.Token) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Token[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractAddr) > 0 {
		i -= len(m.ContractAddr)
		copy(dAtA[i:], m.ContractAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ContractAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetAdvancedInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAdvancedInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetAdvancedInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetAdvancedInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetAdvancedInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetAdvancedInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAdvancedInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdvancedInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdvancedInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetAdvancedInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAdvancedInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAdvancedInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockDelay != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BlockDelay))
		i--
		dAtA[i] = 0x40
	}
	if m.RefundReason != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RefundReason))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Powers) > 0 {
		for iNdEx := len(m.Powers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Powers[iNdEx])
			copy(dAtA[i:], m.Powers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Powers[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SortedSigs[iNdEx])
			copy(dAtA[i:], m.SortedSigs[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.SortedSigs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.WdOnchain) > 0 {
		i -= len(m.WdOnchain)
		copy(dAtA[i:], m.WdOnchain)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WdOnchain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTransferConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainToken) > 0 {
		for k := range m.ChainToken {
			v := m.ChainToken[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGateway(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Chains) > 0 {
		for iNdEx := len(m.Chains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstimateAmtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateAmtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateAmtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsrAddr) > 0 {
		i -= len(m.UsrAddr)
		copy(dAtA[i:], m.UsrAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.UsrAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Amt) > 0 {
		i -= len(m.Amt)
		copy(dAtA[i:], m.Amt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amt)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DstChainId))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SrcChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EstimateAmtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateAmtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateAmtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSlippage != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MaxSlippage))
		i--
		dAtA[i] = 0x30
	}
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Fee) > 0 {
		i -= len(m.Fee)
		copy(dAtA[i:], m.Fee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Fee)))
		i--
		dAtA[i] = 0x22
	}
	if m.BridgeRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BridgeRate))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.EqValueTokenAmt) > 0 {
		i -= len(m.EqValueTokenAmt)
		copy(dAtA[i:], m.EqValueTokenAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EqValueTokenAmt)))
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkTransferRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkTransferRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkTransferRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SrcTxHash) > 0 {
		i -= len(m.SrcTxHash)
		copy(dAtA[i:], m.SrcTxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SrcTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x22
	}
	if m.DstMinReceivedInfo != nil {
		{
			size, err := m.DstMinReceivedInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcSendInfo != nil {
		{
			size, err := m.SrcSendInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLPInfoListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLPInfoListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLPInfoListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FarmingApy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FarmingApy))))
		i--
		dAtA[i] = 0x61
	}
	if m.LpFeeEarningApy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LpFeeEarningApy))))
		i--
		dAtA[i] = 0x59
	}
	if len(m.TotalLiquidityAmt) > 0 {
		i -= len(m.TotalLiquidityAmt)
		copy(dAtA[i:], m.TotalLiquidityAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TotalLiquidityAmt)))
		i--
		dAtA[i] = 0x52
	}
	if m.TotalLiquidity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalLiquidity))))
		i--
		dAtA[i] = 0x49
	}
	if m.Volume_24H != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume_24H))))
		i--
		dAtA[i] = 0x41
	}
	if m.FarmingRewardEarning != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FarmingRewardEarning))))
		i--
		dAtA[i] = 0x39
	}
	if m.LpFeeEarning != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LpFeeEarning))))
		i--
		dAtA[i] = 0x31
	}
	if m.HasFarmingSessions {
		i--
		if m.HasFarmingSessions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.LiquidityAmt) > 0 {
		i -= len(m.LiquidityAmt)
		copy(dAtA[i:], m.LiquidityAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LiquidityAmt)))
		i--
		dAtA[i] = 0x22
	}
	if m.Liquidity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Liquidity))))
		i--
		dAtA[i] = 0x19
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLPInfoListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLPInfoListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLPInfoListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LpInfo) > 0 {
		for iNdEx := len(m.LpInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LpInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawLiquidityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawLiquidityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawLiquidityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Reqid != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Reqid))
		i--
		dAtA[i] = 0x30
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TokenAddr) > 0 {
		i -= len(m.TokenAddr)
		copy(dAtA[i:], m.TokenAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReceiverAddr) > 0 {
		i -= len(m.ReceiverAddr)
		copy(dAtA[i:], m.ReceiverAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ReceiverAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkLiquidityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkLiquidityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkLiquidityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x28
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TokenAddr) > 0 {
		i -= len(m.TokenAddr)
		copy(dAtA[i:], m.TokenAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amt) > 0 {
		i -= len(m.Amt)
		copy(dAtA[i:], m.Amt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amt)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LpAddr) > 0 {
		i -= len(m.LpAddr)
		copy(dAtA[i:], m.LpAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LpAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimWithdrawRewardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimWithdrawRewardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimWithdrawRewardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimWithdrawRewardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimWithdrawRewardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimWithdrawRewardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimRewardDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimRewardDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimRewardDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimRewardDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimRewardDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimRewardDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		for iNdEx := len(m.Details) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Details[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLiquidityStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidityStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidityStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LpAddr) > 0 {
		i -= len(m.LpAddr)
		copy(dAtA[i:], m.LpAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LpAddr)))
		i--
		dAtA[i] = 0x12
	}
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefundReason != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RefundReason))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DstBlockTxLink) > 0 {
		i -= len(m.DstBlockTxLink)
		copy(dAtA[i:], m.DstBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DstBlockTxLink)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SrcBlockTxLink) > 0 {
		i -= len(m.SrcBlockTxLink)
		copy(dAtA[i:], m.SrcBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SrcBlockTxLink)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ts != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Ts))
		i--
		dAtA[i] = 0x20
	}
	if m.DstReceivedInfo != nil {
		{
			size, err := m.DstReceivedInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcSendInfo != nil {
		{
			size, err := m.SrcSendInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x40
	}
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BlockTxLink) > 0 {
		i -= len(m.BlockTxLink)
		copy(dAtA[i:], m.BlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BlockTxLink)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ts != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Ts))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.CurrentSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.History) > 0 {
		for iNdEx := len(m.History) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.History[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.CurrentSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.History) > 0 {
		for iNdEx := len(m.History) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.History[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardingDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardingDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardingDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Amt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amt))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *RewardingDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardingDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardingDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnlockedCumulativeRewards) > 0 {
		for iNdEx := len(m.UnlockedCumulativeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnlockedCumulativeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.HistoricalCumulativeRewards) > 0 {
		for iNdEx := len(m.HistoricalCumulativeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoricalCumulativeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalFarmingRewards != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalFarmingRewards))))
		i--
		dAtA[i] = 0x11
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ErrMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGateway(dAtA []byte, offset int, v uint64) int {
	offset -= sovGateway(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryLiquidityStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	l = len(m.WdOnchain)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, b := range m.SortedSigs {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, b := range m.Signers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Powers) > 0 {
		for _, b := range m.Powers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *Chain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGateway(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ChainTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Token) > 0 {
		for _, e := range m.Token {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *TokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ContractAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *SetAdvancedInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	return n
}

func (m *SetAdvancedInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetAdvancedInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetAdvancedInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	return n
}

func (m *GetTransferStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTransferStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	l = len(m.WdOnchain)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, b := range m.SortedSigs {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, b := range m.Signers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Powers) > 0 {
		for _, b := range m.Powers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.RefundReason != 0 {
		n += 1 + sovGateway(uint64(m.RefundReason))
	}
	if m.BlockDelay != 0 {
		n += 1 + sovGateway(uint64(m.BlockDelay))
	}
	return n
}

func (m *GetTransferConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTransferConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.Chains) > 0 {
		for _, e := range m.Chains {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.ChainToken) > 0 {
		for k, v := range m.ChainToken {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGateway(uint64(l))
			}
			mapEntrySize := 1 + sovGateway(uint64(k)) + l
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EstimateAmtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcChainId != 0 {
		n += 1 + sovGateway(uint64(m.SrcChainId))
	}
	if m.DstChainId != 0 {
		n += 1 + sovGateway(uint64(m.DstChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.UsrAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EstimateAmtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.EqValueTokenAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BridgeRate != 0 {
		n += 5
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	if m.MaxSlippage != 0 {
		n += 1 + sovGateway(uint64(m.MaxSlippage))
	}
	return n
}

func (m *MarkTransferRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SrcSendInfo != nil {
		l = m.SrcSendInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DstMinReceivedInfo != nil {
		l = m.DstMinReceivedInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.SrcTxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	return n
}

func (m *MarkTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetLPInfoListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *LPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Liquidity != 0 {
		n += 9
	}
	l = len(m.LiquidityAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.HasFarmingSessions {
		n += 2
	}
	if m.LpFeeEarning != 0 {
		n += 9
	}
	if m.FarmingRewardEarning != 0 {
		n += 9
	}
	if m.Volume_24H != 0 {
		n += 9
	}
	if m.TotalLiquidity != 0 {
		n += 9
	}
	l = len(m.TotalLiquidityAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.LpFeeEarningApy != 0 {
		n += 9
	}
	if m.FarmingApy != 0 {
		n += 9
	}
	return n
}

func (m *GetLPInfoListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.LpInfo) > 0 {
		for _, e := range m.LpInfo {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *WithdrawLiquidityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ReceiverAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TokenAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	if m.Reqid != 0 {
		n += 1 + sovGateway(uint64(m.Reqid))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *WithdrawLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	return n
}

func (m *MarkLiquidityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LpAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TokenAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	return n
}

func (m *MarkLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ClaimWithdrawRewardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ClaimWithdrawRewardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ClaimRewardDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ClaimRewardDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *QueryLiquidityStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	l = len(m.LpAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	return n
}

func (m *TransferHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SrcSendInfo != nil {
		l = m.SrcSendInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DstReceivedInfo != nil {
		l = m.DstReceivedInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovGateway(uint64(m.Ts))
	}
	l = len(m.SrcBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DstBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	if m.RefundReason != 0 {
		n += 1 + sovGateway(uint64(m.RefundReason))
	}
	return n
}

func (m *LPHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovGateway(uint64(m.Ts))
	}
	l = len(m.BlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	return n
}

func (m *TransferHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGateway(uint64(m.PageSize))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TransferHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CurrentSize != 0 {
		n += 1 + sovGateway(uint64(m.CurrentSize))
	}
	return n
}

func (m *LPHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGateway(uint64(m.PageSize))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *LPHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CurrentSize != 0 {
		n += 1 + sovGateway(uint64(m.CurrentSize))
	}
	return n
}

func (m *RewardingDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *Reward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amt != 0 {
		n += 9
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *RewardingDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.TotalFarmingRewards != 0 {
		n += 9
	}
	if len(m.HistoricalCumulativeRewards) > 0 {
		for _, e := range m.HistoricalCumulativeRewards {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.UnlockedCumulativeRewards) > 0 {
		for _, e := range m.UnlockedCumulativeRewards {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *ErrMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGateway(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func sovGateway(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryLiquidityStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidityStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidityStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.LPHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdOnchain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WdOnchain = append(m.WdOnchain[:0], dAtA[iNdEx:postIndex]...)
			if m.WdOnchain == nil {
				m.WdOnchain = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, make([]byte, postIndex-iNdEx))
			copy(m.SortedSigs[len(m.SortedSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, make([]byte, postIndex-iNdEx))
			copy(m.Signers[len(m.Signers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Powers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Powers = append(m.Powers, make([]byte, postIndex-iNdEx))
			copy(m.Powers[len(m.Powers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token, &TokenInfo{})
			if err := m.Token[len(m.Token)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAdvancedInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAdvancedInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAdvancedInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAdvancedInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAdvancedInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAdvancedInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAdvancedInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAdvancedInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAdvancedInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAdvancedInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAdvancedInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAdvancedInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.TransferHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdOnchain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WdOnchain = append(m.WdOnchain[:0], dAtA[iNdEx:postIndex]...)
			if m.WdOnchain == nil {
				m.WdOnchain = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, make([]byte, postIndex-iNdEx))
			copy(m.SortedSigs[len(m.SortedSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, make([]byte, postIndex-iNdEx))
			copy(m.Signers[len(m.Signers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Powers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Powers = append(m.Powers, make([]byte, postIndex-iNdEx))
			copy(m.Powers[len(m.Powers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundReason", wireType)
			}
			m.RefundReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundReason |= types.XferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDelay", wireType)
			}
			m.BlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chains = append(m.Chains, &Chain{})
			if err := m.Chains[len(m.Chains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainToken == nil {
				m.ChainToken = make(map[uint32]*ChainTokenInfo)
			}
			var mapkey uint32
			var mapvalue *ChainTokenInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGateway
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGateway
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChainTokenInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChainToken[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateAmtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateAmtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateAmtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcChainId", wireType)
			}
			m.SrcChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstChainId", wireType)
			}
			m.DstChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateAmtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateAmtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateAmtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqValueTokenAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqValueTokenAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BridgeRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSlippage", wireType)
			}
			m.MaxSlippage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSlippage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkTransferRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkTransferRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkTransferRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSendInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcSendInfo == nil {
				m.SrcSendInfo = &TransferInfo{}
			}
			if err := m.SrcSendInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMinReceivedInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstMinReceivedInfo == nil {
				m.DstMinReceivedInfo = &TransferInfo{}
			}
			if err := m.DstMinReceivedInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TransferType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLPInfoListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLPInfoListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLPInfoListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Liquidity = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiquidityAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFarmingSessions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFarmingSessions = bool(v != 0)
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpFeeEarning", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LpFeeEarning = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingRewardEarning", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FarmingRewardEarning = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume_24H", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume_24H = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiquidity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalLiquidity = float64(math.Float64frombits(v))
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiquidityAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalLiquidityAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpFeeEarningApy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LpFeeEarningApy = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingApy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FarmingApy = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLPInfoListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLPInfoListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLPInfoListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpInfo = append(m.LpInfo, &LPInfo{})
			if err := m.LpInfo[len(m.LpInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawLiquidityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawLiquidityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawLiquidityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiverAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceiverAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqid", wireType)
			}
			m.Reqid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reqid |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkLiquidityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkLiquidityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkLiquidityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimWithdrawRewardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimWithdrawRewardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimWithdrawRewardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimWithdrawRewardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimWithdrawRewardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimWithdrawRewardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimRewardDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimRewardDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimRewardDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimRewardDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimRewardDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimRewardDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &types1.RewardClaimDetails{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLiquidityStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidityStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidityStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSendInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcSendInfo == nil {
				m.SrcSendInfo = &TransferInfo{}
			}
			if err := m.SrcSendInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstReceivedInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstReceivedInfo == nil {
				m.DstReceivedInfo = &TransferInfo{}
			}
			if err := m.DstReceivedInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.TransferHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundReason", wireType)
			}
			m.RefundReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundReason |= types.XferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.LPHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &TransferHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSize", wireType)
			}
			m.CurrentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &LPHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSize", wireType)
			}
			m.CurrentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardingDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardingDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardingDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amt = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardingDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardingDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardingDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFarmingRewards", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalFarmingRewards = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalCumulativeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoricalCumulativeRewards = append(m.HistoricalCumulativeRewards, &Reward{})
			if err := m.HistoricalCumulativeRewards[len(m.HistoricalCumulativeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockedCumulativeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockedCumulativeRewards = append(m.UnlockedCumulativeRewards, &Reward{})
			if err := m.UnlockedCumulativeRewards[len(m.UnlockedCumulativeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGateway
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGateway
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGateway        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGateway = fmt.Errorf("proto: unexpected end of group")
)
