// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/gateway/v1/gateway.proto

package webapi

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	types3 "github.com/celer-network/sgn-v2/common/types"
	types "github.com/celer-network/sgn-v2/x/cbridge/types"
	types2 "github.com/celer-network/sgn-v2/x/distribution/types"
	types1 "github.com/celer-network/sgn-v2/x/farming/types"
	_ "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LPType int32

const (
	LPType_LP_TYPE_UNKNOWN LPType = 0
	LPType_LP_TYPE_ADD     LPType = 1
	LPType_LP_TYPE_REMOVE  LPType = 2
)

var LPType_name = map[int32]string{
	0: "LP_TYPE_UNKNOWN",
	1: "LP_TYPE_ADD",
	2: "LP_TYPE_REMOVE",
}

var LPType_value = map[string]int32{
	"LP_TYPE_UNKNOWN": 0,
	"LP_TYPE_ADD":     1,
	"LP_TYPE_REMOVE":  2,
}

func (x LPType) String() string {
	return proto.EnumName(LPType_name, int32(x))
}

func (LPType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{0}
}

type CSType int32

const (
	CSType_CT_UNKNOWN CSType = 0
	CSType_CT_TX      CSType = 1
	CSType_CT_LP_ADD  CSType = 2
	CSType_CT_LP_RM   CSType = 3
)

var CSType_name = map[int32]string{
	0: "CT_UNKNOWN",
	1: "CT_TX",
	2: "CT_LP_ADD",
	3: "CT_LP_RM",
}

var CSType_value = map[string]int32{
	"CT_UNKNOWN": 0,
	"CT_TX":      1,
	"CT_LP_ADD":  2,
	"CT_LP_RM":   3,
}

func (x CSType) String() string {
	return proto.EnumName(CSType_name, int32(x))
}

func (CSType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{1}
}

type CSOperation int32

const (
	CSOperation_CA_UNKNOWN           CSOperation = 0
	CSOperation_CA_NORMAL            CSOperation = 1
	CSOperation_CA_WAITING           CSOperation = 2
	CSOperation_CA_REPORT            CSOperation = 3
	CSOperation_CA_USE_RESYNC_TOOL   CSOperation = 4
	CSOperation_CA_USE_RESIGN_TOOL   CSOperation = 5
	CSOperation_CA_USE_RESUMBIT_TOOL CSOperation = 6
	CSOperation_CA_MORE_INFO_NEEDED  CSOperation = 7
)

var CSOperation_name = map[int32]string{
	0: "CA_UNKNOWN",
	1: "CA_NORMAL",
	2: "CA_WAITING",
	3: "CA_REPORT",
	4: "CA_USE_RESYNC_TOOL",
	5: "CA_USE_RESIGN_TOOL",
	6: "CA_USE_RESUMBIT_TOOL",
	7: "CA_MORE_INFO_NEEDED",
}

var CSOperation_value = map[string]int32{
	"CA_UNKNOWN":           0,
	"CA_NORMAL":            1,
	"CA_WAITING":           2,
	"CA_REPORT":            3,
	"CA_USE_RESYNC_TOOL":   4,
	"CA_USE_RESIGN_TOOL":   5,
	"CA_USE_RESUMBIT_TOOL": 6,
	"CA_MORE_INFO_NEEDED":  7,
}

func (x CSOperation) String() string {
	return proto.EnumName(CSOperation_name, int32(x))
}

func (CSOperation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{2}
}

type UserCaseStatus int32

const (
	UserCaseStatus_CC_UNKNOWN UserCaseStatus = 0
	// transfer related cases
	UserCaseStatus_CC_TRANSFER_NO_HISTORY                   UserCaseStatus = 1
	UserCaseStatus_CC_TRANSFER_SUBMITTING                   UserCaseStatus = 2
	UserCaseStatus_CC_TRANSFER_WAITING_FOR_SGN_CONFIRMATION UserCaseStatus = 3
	UserCaseStatus_CC_TRANSFER_WAITING_FOR_FUND_RELEASE     UserCaseStatus = 4
	UserCaseStatus_CC_TRANSFER_REQUESTING_REFUND            UserCaseStatus = 5
	UserCaseStatus_CC_TRANSFER_CONFIRMING_YOUR_REFUND       UserCaseStatus = 6
	// add related cases
	UserCaseStatus_CC_ADD_NO_HISTORY      UserCaseStatus = 7
	UserCaseStatus_CC_ADD_SUBMITTING      UserCaseStatus = 8
	UserCaseStatus_CC_ADD_WAITING_FOR_SGN UserCaseStatus = 9
	// withdraw related cases
	UserCaseStatus_CC_WAITING_FOR_LP           UserCaseStatus = 10
	UserCaseStatus_CC_WITHDRAW_SUBMITTING      UserCaseStatus = 11
	UserCaseStatus_CC_WITHDRAW_WAITING_FOR_SGN UserCaseStatus = 12
)

var UserCaseStatus_name = map[int32]string{
	0:  "CC_UNKNOWN",
	1:  "CC_TRANSFER_NO_HISTORY",
	2:  "CC_TRANSFER_SUBMITTING",
	3:  "CC_TRANSFER_WAITING_FOR_SGN_CONFIRMATION",
	4:  "CC_TRANSFER_WAITING_FOR_FUND_RELEASE",
	5:  "CC_TRANSFER_REQUESTING_REFUND",
	6:  "CC_TRANSFER_CONFIRMING_YOUR_REFUND",
	7:  "CC_ADD_NO_HISTORY",
	8:  "CC_ADD_SUBMITTING",
	9:  "CC_ADD_WAITING_FOR_SGN",
	10: "CC_WAITING_FOR_LP",
	11: "CC_WITHDRAW_SUBMITTING",
	12: "CC_WITHDRAW_WAITING_FOR_SGN",
}

var UserCaseStatus_value = map[string]int32{
	"CC_UNKNOWN":                               0,
	"CC_TRANSFER_NO_HISTORY":                   1,
	"CC_TRANSFER_SUBMITTING":                   2,
	"CC_TRANSFER_WAITING_FOR_SGN_CONFIRMATION": 3,
	"CC_TRANSFER_WAITING_FOR_FUND_RELEASE":     4,
	"CC_TRANSFER_REQUESTING_REFUND":            5,
	"CC_TRANSFER_CONFIRMING_YOUR_REFUND":       6,
	"CC_ADD_NO_HISTORY":                        7,
	"CC_ADD_SUBMITTING":                        8,
	"CC_ADD_WAITING_FOR_SGN":                   9,
	"CC_WAITING_FOR_LP":                        10,
	"CC_WITHDRAW_SUBMITTING":                   11,
	"CC_WITHDRAW_WAITING_FOR_SGN":              12,
}

func (x UserCaseStatus) String() string {
	return proto.EnumName(UserCaseStatus_name, int32(x))
}

func (UserCaseStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{3}
}

type WithdrawMethodType int32

const (
	WithdrawMethodType_WD_METHOD_TYPE_UNDEFINED     WithdrawMethodType = 0
	WithdrawMethodType_WD_METHOD_TYPE_ONE_RM        WithdrawMethodType = 1
	WithdrawMethodType_WD_METHOD_TYPE_ALL_IN_ONE    WithdrawMethodType = 2
	WithdrawMethodType_WD_METHOD_TYPE_STAKING_CLAIM WithdrawMethodType = 3
)

var WithdrawMethodType_name = map[int32]string{
	0: "WD_METHOD_TYPE_UNDEFINED",
	1: "WD_METHOD_TYPE_ONE_RM",
	2: "WD_METHOD_TYPE_ALL_IN_ONE",
	3: "WD_METHOD_TYPE_STAKING_CLAIM",
}

var WithdrawMethodType_value = map[string]int32{
	"WD_METHOD_TYPE_UNDEFINED":     0,
	"WD_METHOD_TYPE_ONE_RM":        1,
	"WD_METHOD_TYPE_ALL_IN_ONE":    2,
	"WD_METHOD_TYPE_STAKING_CLAIM": 3,
}

func (x WithdrawMethodType) String() string {
	return proto.EnumName(WithdrawMethodType_name, int32(x))
}

func (WithdrawMethodType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{4}
}

type ErrCode int32

const (
	ErrCode_ERROR_CODE_UNDEFINED                    ErrCode = 0
	ErrCode_ERROR_CODE_COMMON                       ErrCode = 500
	ErrCode_ERROR_NO_TOKEN_ON_DST_CHAIN             ErrCode = 1001
	ErrCode_ERROR_NO_TOKEN_ON_SRC_CHAIN             ErrCode = 1002
	ErrCode_ERROR_INIT_WITHDRAW_FAILED              ErrCode = 1003
	ErrCode_ERROR_CODE_NO_ENOUGH_TOKEN_ON_DST_CHAIN ErrCode = 1004
)

var ErrCode_name = map[int32]string{
	0:    "ERROR_CODE_UNDEFINED",
	500:  "ERROR_CODE_COMMON",
	1001: "ERROR_NO_TOKEN_ON_DST_CHAIN",
	1002: "ERROR_NO_TOKEN_ON_SRC_CHAIN",
	1003: "ERROR_INIT_WITHDRAW_FAILED",
	1004: "ERROR_CODE_NO_ENOUGH_TOKEN_ON_DST_CHAIN",
}

var ErrCode_value = map[string]int32{
	"ERROR_CODE_UNDEFINED":                    0,
	"ERROR_CODE_COMMON":                       500,
	"ERROR_NO_TOKEN_ON_DST_CHAIN":             1001,
	"ERROR_NO_TOKEN_ON_SRC_CHAIN":             1002,
	"ERROR_INIT_WITHDRAW_FAILED":              1003,
	"ERROR_CODE_NO_ENOUGH_TOKEN_ON_DST_CHAIN": 1004,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{5}
}

type GetCampaignScoresRequest struct {
	Date       uint32 `protobuf:"varint,1,opt,name=date,proto3" json:"date,omitempty"`
	BeginBlock uint64 `protobuf:"varint,2,opt,name=begin_block,json=beginBlock,proto3" json:"begin_block,omitempty"`
	EndBlock   uint64 `protobuf:"varint,3,opt,name=end_block,json=endBlock,proto3" json:"end_block,omitempty"`
}

func (m *GetCampaignScoresRequest) Reset()         { *m = GetCampaignScoresRequest{} }
func (m *GetCampaignScoresRequest) String() string { return proto.CompactTextString(m) }
func (*GetCampaignScoresRequest) ProtoMessage()    {}
func (*GetCampaignScoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{0}
}
func (m *GetCampaignScoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCampaignScoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCampaignScoresRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCampaignScoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCampaignScoresRequest.Merge(m, src)
}
func (m *GetCampaignScoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCampaignScoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCampaignScoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCampaignScoresRequest proto.InternalMessageInfo

func (m *GetCampaignScoresRequest) GetDate() uint32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *GetCampaignScoresRequest) GetBeginBlock() uint64 {
	if m != nil {
		return m.BeginBlock
	}
	return 0
}

func (m *GetCampaignScoresRequest) GetEndBlock() uint64 {
	if m != nil {
		return m.EndBlock
	}
	return 0
}

type GetCampaignScoresResponse struct {
	Scores []*CampaignScore `protobuf:"bytes,1,rep,name=scores,proto3" json:"scores,omitempty"`
	Err    *ErrMsg          `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
	Begin  uint64           `protobuf:"varint,3,opt,name=begin,proto3" json:"begin,omitempty"`
}

func (m *GetCampaignScoresResponse) Reset()         { *m = GetCampaignScoresResponse{} }
func (m *GetCampaignScoresResponse) String() string { return proto.CompactTextString(m) }
func (*GetCampaignScoresResponse) ProtoMessage()    {}
func (*GetCampaignScoresResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{1}
}
func (m *GetCampaignScoresResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCampaignScoresResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCampaignScoresResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCampaignScoresResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCampaignScoresResponse.Merge(m, src)
}
func (m *GetCampaignScoresResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCampaignScoresResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCampaignScoresResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCampaignScoresResponse proto.InternalMessageInfo

func (m *GetCampaignScoresResponse) GetScores() []*CampaignScore {
	if m != nil {
		return m.Scores
	}
	return nil
}

func (m *GetCampaignScoresResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetCampaignScoresResponse) GetBegin() uint64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

type CampaignScore struct {
	UsrAddr string `protobuf:"bytes,1,opt,name=usr_addr,json=usrAddr,proto3" json:"usr_addr,omitempty"`
	Score   uint64 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *CampaignScore) Reset()         { *m = CampaignScore{} }
func (m *CampaignScore) String() string { return proto.CompactTextString(m) }
func (*CampaignScore) ProtoMessage()    {}
func (*CampaignScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{2}
}
func (m *CampaignScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CampaignScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CampaignScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CampaignScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CampaignScore.Merge(m, src)
}
func (m *CampaignScore) XXX_Size() int {
	return m.Size()
}
func (m *CampaignScore) XXX_DiscardUnknown() {
	xxx_messageInfo_CampaignScore.DiscardUnknown(m)
}

var xxx_messageInfo_CampaignScore proto.InternalMessageInfo

func (m *CampaignScore) GetUsrAddr() string {
	if m != nil {
		return m.UsrAddr
	}
	return ""
}

func (m *CampaignScore) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

type QueryLiquidityStatusResponse struct {
	Err         *ErrMsg              `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Status      types.WithdrawStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sgn.cbridge.v1.WithdrawStatus" json:"status,omitempty"`
	WdOnchain   []byte               `protobuf:"bytes,3,opt,name=wd_onchain,json=wdOnchain,proto3" json:"wd_onchain,omitempty"`
	SortedSigs  [][]byte             `protobuf:"bytes,4,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	Signers     [][]byte             `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
	Powers      [][]byte             `protobuf:"bytes,6,rep,name=powers,proto3" json:"powers,omitempty"`
	BlockTxLink string               `protobuf:"bytes,7,opt,name=block_tx_link,json=blockTxLink,proto3" json:"block_tx_link,omitempty"`
	BlockDelay  uint32               `protobuf:"varint,8,opt,name=block_delay,json=blockDelay,proto3" json:"block_delay,omitempty"`
}

func (m *QueryLiquidityStatusResponse) Reset()         { *m = QueryLiquidityStatusResponse{} }
func (m *QueryLiquidityStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidityStatusResponse) ProtoMessage()    {}
func (*QueryLiquidityStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{3}
}
func (m *QueryLiquidityStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidityStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidityStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidityStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidityStatusResponse.Merge(m, src)
}
func (m *QueryLiquidityStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidityStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidityStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidityStatusResponse proto.InternalMessageInfo

func (m *QueryLiquidityStatusResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetStatus() types.WithdrawStatus {
	if m != nil {
		return m.Status
	}
	return types.WithdrawStatus_WD_UNKNOWN
}

func (m *QueryLiquidityStatusResponse) GetWdOnchain() []byte {
	if m != nil {
		return m.WdOnchain
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetSortedSigs() [][]byte {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetSigners() [][]byte {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetPowers() [][]byte {
	if m != nil {
		return m.Powers
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetBlockTxLink() string {
	if m != nil {
		return m.BlockTxLink
	}
	return ""
}

func (m *QueryLiquidityStatusResponse) GetBlockDelay() uint32 {
	if m != nil {
		return m.BlockDelay
	}
	return 0
}

type Chain struct {
	Id               uint32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name             string  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon             string  `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	BlockDelay       uint32  `protobuf:"varint,4,opt,name=block_delay,json=blockDelay,proto3" json:"block_delay,omitempty"`
	GasTokenSymbol   string  `protobuf:"bytes,5,opt,name=gas_token_symbol,json=gasTokenSymbol,proto3" json:"gas_token_symbol,omitempty"`
	ExploreUrl       string  `protobuf:"bytes,6,opt,name=explore_url,json=exploreUrl,proto3" json:"explore_url,omitempty"`
	ContractAddr     string  `protobuf:"bytes,8,opt,name=contract_addr,json=contractAddr,proto3" json:"contract_addr,omitempty"`
	DropGasAmt       string  `protobuf:"bytes,9,opt,name=drop_gas_amt,json=dropGasAmt,proto3" json:"drop_gas_amt,omitempty"`
	SuggestedBaseFee float64 `protobuf:"fixed64,10,opt,name=suggested_base_fee,json=suggestedBaseFee,proto3" json:"suggested_base_fee,omitempty"`
}

func (m *Chain) Reset()         { *m = Chain{} }
func (m *Chain) String() string { return proto.CompactTextString(m) }
func (*Chain) ProtoMessage()    {}
func (*Chain) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{4}
}
func (m *Chain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chain.Merge(m, src)
}
func (m *Chain) XXX_Size() int {
	return m.Size()
}
func (m *Chain) XXX_DiscardUnknown() {
	xxx_messageInfo_Chain.DiscardUnknown(m)
}

var xxx_messageInfo_Chain proto.InternalMessageInfo

func (m *Chain) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Chain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Chain) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *Chain) GetBlockDelay() uint32 {
	if m != nil {
		return m.BlockDelay
	}
	return 0
}

func (m *Chain) GetGasTokenSymbol() string {
	if m != nil {
		return m.GasTokenSymbol
	}
	return ""
}

func (m *Chain) GetExploreUrl() string {
	if m != nil {
		return m.ExploreUrl
	}
	return ""
}

func (m *Chain) GetContractAddr() string {
	if m != nil {
		return m.ContractAddr
	}
	return ""
}

func (m *Chain) GetDropGasAmt() string {
	if m != nil {
		return m.DropGasAmt
	}
	return ""
}

func (m *Chain) GetSuggestedBaseFee() float64 {
	if m != nil {
		return m.SuggestedBaseFee
	}
	return 0
}

type ChainTokenInfo struct {
	Token []*TokenInfo `protobuf:"bytes,1,rep,name=token,proto3" json:"token,omitempty"`
}

func (m *ChainTokenInfo) Reset()         { *m = ChainTokenInfo{} }
func (m *ChainTokenInfo) String() string { return proto.CompactTextString(m) }
func (*ChainTokenInfo) ProtoMessage()    {}
func (*ChainTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{5}
}
func (m *ChainTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainTokenInfo.Merge(m, src)
}
func (m *ChainTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChainTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChainTokenInfo proto.InternalMessageInfo

func (m *ChainTokenInfo) GetToken() []*TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

type TokenInfo struct {
	Token *types.Token `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Name  string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon  string       `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *TokenInfo) Reset()         { *m = TokenInfo{} }
func (m *TokenInfo) String() string { return proto.CompactTextString(m) }
func (*TokenInfo) ProtoMessage()    {}
func (*TokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{6}
}
func (m *TokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenInfo.Merge(m, src)
}
func (m *TokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *TokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenInfo proto.InternalMessageInfo

func (m *TokenInfo) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *TokenInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TokenInfo) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type TransferInfo struct {
	Chain  *Chain       `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token  *types.Token `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Amount string       `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *TransferInfo) Reset()         { *m = TransferInfo{} }
func (m *TransferInfo) String() string { return proto.CompactTextString(m) }
func (*TransferInfo) ProtoMessage()    {}
func (*TransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{7}
}
func (m *TransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferInfo.Merge(m, src)
}
func (m *TransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *TransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TransferInfo proto.InternalMessageInfo

func (m *TransferInfo) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *TransferInfo) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *TransferInfo) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type GetTransferStatusRequest struct {
	TransferId string `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
}

func (m *GetTransferStatusRequest) Reset()         { *m = GetTransferStatusRequest{} }
func (m *GetTransferStatusRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransferStatusRequest) ProtoMessage()    {}
func (*GetTransferStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{8}
}
func (m *GetTransferStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferStatusRequest.Merge(m, src)
}
func (m *GetTransferStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferStatusRequest proto.InternalMessageInfo

func (m *GetTransferStatusRequest) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

type GetTransferStatusResponse struct {
	Err            *ErrMsg                     `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Status         types.TransferHistoryStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sgn.cbridge.v1.TransferHistoryStatus" json:"status,omitempty"`
	WdOnchain      []byte                      `protobuf:"bytes,3,opt,name=wd_onchain,json=wdOnchain,proto3" json:"wd_onchain,omitempty"`
	SortedSigs     [][]byte                    `protobuf:"bytes,4,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	Signers        [][]byte                    `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
	Powers         [][]byte                    `protobuf:"bytes,6,rep,name=powers,proto3" json:"powers,omitempty"`
	RefundReason   types.XferStatus            `protobuf:"varint,7,opt,name=refund_reason,json=refundReason,proto3,enum=sgn.cbridge.v1.XferStatus" json:"refund_reason,omitempty"`
	BlockDelay     uint32                      `protobuf:"varint,8,opt,name=block_delay,json=blockDelay,proto3" json:"block_delay,omitempty"`
	SrcBlockTxLink string                      `protobuf:"bytes,9,opt,name=src_block_tx_link,json=srcBlockTxLink,proto3" json:"src_block_tx_link,omitempty"`
	DstBlockTxLink string                      `protobuf:"bytes,10,opt,name=dst_block_tx_link,json=dstBlockTxLink,proto3" json:"dst_block_tx_link,omitempty"`
}

func (m *GetTransferStatusResponse) Reset()         { *m = GetTransferStatusResponse{} }
func (m *GetTransferStatusResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransferStatusResponse) ProtoMessage()    {}
func (*GetTransferStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{9}
}
func (m *GetTransferStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferStatusResponse.Merge(m, src)
}
func (m *GetTransferStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferStatusResponse proto.InternalMessageInfo

func (m *GetTransferStatusResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTransferStatusResponse) GetStatus() types.TransferHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.TransferHistoryStatus_TRANSFER_UNKNOWN
}

func (m *GetTransferStatusResponse) GetWdOnchain() []byte {
	if m != nil {
		return m.WdOnchain
	}
	return nil
}

func (m *GetTransferStatusResponse) GetSortedSigs() [][]byte {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *GetTransferStatusResponse) GetSigners() [][]byte {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *GetTransferStatusResponse) GetPowers() [][]byte {
	if m != nil {
		return m.Powers
	}
	return nil
}

func (m *GetTransferStatusResponse) GetRefundReason() types.XferStatus {
	if m != nil {
		return m.RefundReason
	}
	return types.XferStatus_UNKNOWN
}

func (m *GetTransferStatusResponse) GetBlockDelay() uint32 {
	if m != nil {
		return m.BlockDelay
	}
	return 0
}

func (m *GetTransferStatusResponse) GetSrcBlockTxLink() string {
	if m != nil {
		return m.SrcBlockTxLink
	}
	return ""
}

func (m *GetTransferStatusResponse) GetDstBlockTxLink() string {
	if m != nil {
		return m.DstBlockTxLink
	}
	return ""
}

type GetTransferConfigsRequest struct {
}

func (m *GetTransferConfigsRequest) Reset()         { *m = GetTransferConfigsRequest{} }
func (m *GetTransferConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransferConfigsRequest) ProtoMessage()    {}
func (*GetTransferConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{10}
}
func (m *GetTransferConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferConfigsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferConfigsRequest.Merge(m, src)
}
func (m *GetTransferConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferConfigsRequest proto.InternalMessageInfo

type GetTransferConfigsResponse struct {
	Err                       *ErrMsg                    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Chains                    []*Chain                   `protobuf:"bytes,2,rep,name=chains,proto3" json:"chains,omitempty"`
	ChainToken                map[uint32]*ChainTokenInfo `protobuf:"bytes,3,rep,name=chain_token,json=chainToken,proto3" json:"chain_token,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FarmingRewardContractAddr string                     `protobuf:"bytes,4,opt,name=farming_reward_contract_addr,json=farmingRewardContractAddr,proto3" json:"farming_reward_contract_addr,omitempty"`
	PeggedPairConfigs         []*PeggedPairConfig        `protobuf:"bytes,5,rep,name=pegged_pair_configs,json=peggedPairConfigs,proto3" json:"pegged_pair_configs,omitempty"`
}

func (m *GetTransferConfigsResponse) Reset()         { *m = GetTransferConfigsResponse{} }
func (m *GetTransferConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransferConfigsResponse) ProtoMessage()    {}
func (*GetTransferConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{11}
}
func (m *GetTransferConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferConfigsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferConfigsResponse.Merge(m, src)
}
func (m *GetTransferConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferConfigsResponse proto.InternalMessageInfo

func (m *GetTransferConfigsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetChains() []*Chain {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetChainToken() map[uint32]*ChainTokenInfo {
	if m != nil {
		return m.ChainToken
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetFarmingRewardContractAddr() string {
	if m != nil {
		return m.FarmingRewardContractAddr
	}
	return ""
}

func (m *GetTransferConfigsResponse) GetPeggedPairConfigs() []*PeggedPairConfig {
	if m != nil {
		return m.PeggedPairConfigs
	}
	return nil
}

type PeggedPairConfig struct {
	OrgChainId                uint32     `protobuf:"varint,1,opt,name=org_chain_id,json=orgChainId,proto3" json:"org_chain_id,omitempty"`
	OrgToken                  *TokenInfo `protobuf:"bytes,2,opt,name=org_token,json=orgToken,proto3" json:"org_token,omitempty"`
	PeggedChainId             uint32     `protobuf:"varint,3,opt,name=pegged_chain_id,json=peggedChainId,proto3" json:"pegged_chain_id,omitempty"`
	PeggedToken               *TokenInfo `protobuf:"bytes,4,opt,name=pegged_token,json=peggedToken,proto3" json:"pegged_token,omitempty"`
	PeggedDepositContractAddr string     `protobuf:"bytes,5,opt,name=pegged_deposit_contract_addr,json=peggedDepositContractAddr,proto3" json:"pegged_deposit_contract_addr,omitempty"`
	PeggedBurnContractAddr    string     `protobuf:"bytes,6,opt,name=pegged_burn_contract_addr,json=peggedBurnContractAddr,proto3" json:"pegged_burn_contract_addr,omitempty"`
}

func (m *PeggedPairConfig) Reset()         { *m = PeggedPairConfig{} }
func (m *PeggedPairConfig) String() string { return proto.CompactTextString(m) }
func (*PeggedPairConfig) ProtoMessage()    {}
func (*PeggedPairConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{12}
}
func (m *PeggedPairConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeggedPairConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeggedPairConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeggedPairConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeggedPairConfig.Merge(m, src)
}
func (m *PeggedPairConfig) XXX_Size() int {
	return m.Size()
}
func (m *PeggedPairConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PeggedPairConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PeggedPairConfig proto.InternalMessageInfo

func (m *PeggedPairConfig) GetOrgChainId() uint32 {
	if m != nil {
		return m.OrgChainId
	}
	return 0
}

func (m *PeggedPairConfig) GetOrgToken() *TokenInfo {
	if m != nil {
		return m.OrgToken
	}
	return nil
}

func (m *PeggedPairConfig) GetPeggedChainId() uint32 {
	if m != nil {
		return m.PeggedChainId
	}
	return 0
}

func (m *PeggedPairConfig) GetPeggedToken() *TokenInfo {
	if m != nil {
		return m.PeggedToken
	}
	return nil
}

func (m *PeggedPairConfig) GetPeggedDepositContractAddr() string {
	if m != nil {
		return m.PeggedDepositContractAddr
	}
	return ""
}

func (m *PeggedPairConfig) GetPeggedBurnContractAddr() string {
	if m != nil {
		return m.PeggedBurnContractAddr
	}
	return ""
}

type GetTokenInfoRequest struct {
	ChainId     uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TokenSymbol string `protobuf:"bytes,2,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
}

func (m *GetTokenInfoRequest) Reset()         { *m = GetTokenInfoRequest{} }
func (m *GetTokenInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetTokenInfoRequest) ProtoMessage()    {}
func (*GetTokenInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{13}
}
func (m *GetTokenInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenInfoRequest.Merge(m, src)
}
func (m *GetTokenInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenInfoRequest proto.InternalMessageInfo

func (m *GetTokenInfoRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *GetTokenInfoRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

type GetTokenInfoResponse struct {
	Err       *ErrMsg    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	TokenInfo *TokenInfo `protobuf:"bytes,2,opt,name=token_info,json=tokenInfo,proto3" json:"token_info,omitempty"`
}

func (m *GetTokenInfoResponse) Reset()         { *m = GetTokenInfoResponse{} }
func (m *GetTokenInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetTokenInfoResponse) ProtoMessage()    {}
func (*GetTokenInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{14}
}
func (m *GetTokenInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenInfoResponse.Merge(m, src)
}
func (m *GetTokenInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenInfoResponse proto.InternalMessageInfo

func (m *GetTokenInfoResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTokenInfoResponse) GetTokenInfo() *TokenInfo {
	if m != nil {
		return m.TokenInfo
	}
	return nil
}

type EstimateAmtRequest struct {
	SrcChainId        uint32 `protobuf:"varint,1,opt,name=src_chain_id,json=srcChainId,proto3" json:"src_chain_id,omitempty"`
	DstChainId        uint32 `protobuf:"varint,2,opt,name=dst_chain_id,json=dstChainId,proto3" json:"dst_chain_id,omitempty"`
	TokenSymbol       string `protobuf:"bytes,3,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
	Amt               string `protobuf:"bytes,4,opt,name=amt,proto3" json:"amt,omitempty"`
	UsrAddr           string `protobuf:"bytes,5,opt,name=usr_addr,json=usrAddr,proto3" json:"usr_addr,omitempty"`
	SlippageTolerance uint32 `protobuf:"varint,6,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	IsPegged          bool   `protobuf:"varint,7,opt,name=is_pegged,json=isPegged,proto3" json:"is_pegged,omitempty"`
}

func (m *EstimateAmtRequest) Reset()         { *m = EstimateAmtRequest{} }
func (m *EstimateAmtRequest) String() string { return proto.CompactTextString(m) }
func (*EstimateAmtRequest) ProtoMessage()    {}
func (*EstimateAmtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{15}
}
func (m *EstimateAmtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateAmtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateAmtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateAmtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateAmtRequest.Merge(m, src)
}
func (m *EstimateAmtRequest) XXX_Size() int {
	return m.Size()
}
func (m *EstimateAmtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateAmtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateAmtRequest proto.InternalMessageInfo

func (m *EstimateAmtRequest) GetSrcChainId() uint32 {
	if m != nil {
		return m.SrcChainId
	}
	return 0
}

func (m *EstimateAmtRequest) GetDstChainId() uint32 {
	if m != nil {
		return m.DstChainId
	}
	return 0
}

func (m *EstimateAmtRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

func (m *EstimateAmtRequest) GetAmt() string {
	if m != nil {
		return m.Amt
	}
	return ""
}

func (m *EstimateAmtRequest) GetUsrAddr() string {
	if m != nil {
		return m.UsrAddr
	}
	return ""
}

func (m *EstimateAmtRequest) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *EstimateAmtRequest) GetIsPegged() bool {
	if m != nil {
		return m.IsPegged
	}
	return false
}

type EstimateAmtResponse struct {
	Err               *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	EqValueTokenAmt   string  `protobuf:"bytes,2,opt,name=eq_value_token_amt,json=eqValueTokenAmt,proto3" json:"eq_value_token_amt,omitempty"`
	BridgeRate        float32 `protobuf:"fixed32,3,opt,name=bridge_rate,json=bridgeRate,proto3" json:"bridge_rate,omitempty"`
	PercFee           string  `protobuf:"bytes,4,opt,name=perc_fee,json=percFee,proto3" json:"perc_fee,omitempty"`
	BaseFee           string  `protobuf:"bytes,7,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
	SlippageTolerance uint32  `protobuf:"varint,5,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	MaxSlippage       uint32  `protobuf:"varint,6,opt,name=max_slippage,json=maxSlippage,proto3" json:"max_slippage,omitempty"`
}

func (m *EstimateAmtResponse) Reset()         { *m = EstimateAmtResponse{} }
func (m *EstimateAmtResponse) String() string { return proto.CompactTextString(m) }
func (*EstimateAmtResponse) ProtoMessage()    {}
func (*EstimateAmtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{16}
}
func (m *EstimateAmtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateAmtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateAmtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateAmtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateAmtResponse.Merge(m, src)
}
func (m *EstimateAmtResponse) XXX_Size() int {
	return m.Size()
}
func (m *EstimateAmtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateAmtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateAmtResponse proto.InternalMessageInfo

func (m *EstimateAmtResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *EstimateAmtResponse) GetEqValueTokenAmt() string {
	if m != nil {
		return m.EqValueTokenAmt
	}
	return ""
}

func (m *EstimateAmtResponse) GetBridgeRate() float32 {
	if m != nil {
		return m.BridgeRate
	}
	return 0
}

func (m *EstimateAmtResponse) GetPercFee() string {
	if m != nil {
		return m.PercFee
	}
	return ""
}

func (m *EstimateAmtResponse) GetBaseFee() string {
	if m != nil {
		return m.BaseFee
	}
	return ""
}

func (m *EstimateAmtResponse) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *EstimateAmtResponse) GetMaxSlippage() uint32 {
	if m != nil {
		return m.MaxSlippage
	}
	return 0
}

type WithdrawInfo struct {
	ChainId           uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Amount            string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	SlippageTolerance uint32 `protobuf:"varint,3,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
}

func (m *WithdrawInfo) Reset()         { *m = WithdrawInfo{} }
func (m *WithdrawInfo) String() string { return proto.CompactTextString(m) }
func (*WithdrawInfo) ProtoMessage()    {}
func (*WithdrawInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{17}
}
func (m *WithdrawInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawInfo.Merge(m, src)
}
func (m *WithdrawInfo) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawInfo proto.InternalMessageInfo

func (m *WithdrawInfo) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *WithdrawInfo) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *WithdrawInfo) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

type EstimateWithdrawAmtRequest struct {
	SrcWithdraws []*WithdrawInfo `protobuf:"bytes,1,rep,name=src_withdraws,json=srcWithdraws,proto3" json:"src_withdraws,omitempty"`
	DstChainId   uint32          `protobuf:"varint,2,opt,name=dst_chain_id,json=dstChainId,proto3" json:"dst_chain_id,omitempty"`
	TokenSymbol  string          `protobuf:"bytes,3,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
	UsrAddr      string          `protobuf:"bytes,4,opt,name=usr_addr,json=usrAddr,proto3" json:"usr_addr,omitempty"`
}

func (m *EstimateWithdrawAmtRequest) Reset()         { *m = EstimateWithdrawAmtRequest{} }
func (m *EstimateWithdrawAmtRequest) String() string { return proto.CompactTextString(m) }
func (*EstimateWithdrawAmtRequest) ProtoMessage()    {}
func (*EstimateWithdrawAmtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{18}
}
func (m *EstimateWithdrawAmtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateWithdrawAmtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateWithdrawAmtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateWithdrawAmtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateWithdrawAmtRequest.Merge(m, src)
}
func (m *EstimateWithdrawAmtRequest) XXX_Size() int {
	return m.Size()
}
func (m *EstimateWithdrawAmtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateWithdrawAmtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateWithdrawAmtRequest proto.InternalMessageInfo

func (m *EstimateWithdrawAmtRequest) GetSrcWithdraws() []*WithdrawInfo {
	if m != nil {
		return m.SrcWithdraws
	}
	return nil
}

func (m *EstimateWithdrawAmtRequest) GetDstChainId() uint32 {
	if m != nil {
		return m.DstChainId
	}
	return 0
}

func (m *EstimateWithdrawAmtRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

func (m *EstimateWithdrawAmtRequest) GetUsrAddr() string {
	if m != nil {
		return m.UsrAddr
	}
	return ""
}

type EstimateWithdrawAmtResponse struct {
	Err    *ErrMsg                         `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	ReqAmt map[uint32]*EstimateWithdrawAmt `protobuf:"bytes,2,rep,name=req_amt,json=reqAmt,proto3" json:"req_amt,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EstimateWithdrawAmtResponse) Reset()         { *m = EstimateWithdrawAmtResponse{} }
func (m *EstimateWithdrawAmtResponse) String() string { return proto.CompactTextString(m) }
func (*EstimateWithdrawAmtResponse) ProtoMessage()    {}
func (*EstimateWithdrawAmtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{19}
}
func (m *EstimateWithdrawAmtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateWithdrawAmtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateWithdrawAmtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateWithdrawAmtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateWithdrawAmtResponse.Merge(m, src)
}
func (m *EstimateWithdrawAmtResponse) XXX_Size() int {
	return m.Size()
}
func (m *EstimateWithdrawAmtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateWithdrawAmtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateWithdrawAmtResponse proto.InternalMessageInfo

func (m *EstimateWithdrawAmtResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *EstimateWithdrawAmtResponse) GetReqAmt() map[uint32]*EstimateWithdrawAmt {
	if m != nil {
		return m.ReqAmt
	}
	return nil
}

type EstimateWithdrawAmt struct {
	EqValueTokenAmt   string  `protobuf:"bytes,1,opt,name=eq_value_token_amt,json=eqValueTokenAmt,proto3" json:"eq_value_token_amt,omitempty"`
	BridgeRate        float32 `protobuf:"fixed32,2,opt,name=bridge_rate,json=bridgeRate,proto3" json:"bridge_rate,omitempty"`
	PercFee           string  `protobuf:"bytes,3,opt,name=perc_fee,json=percFee,proto3" json:"perc_fee,omitempty"`
	BaseFee           string  `protobuf:"bytes,4,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
	SlippageTolerance uint32  `protobuf:"varint,5,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	MaxSlippage       uint32  `protobuf:"varint,6,opt,name=max_slippage,json=maxSlippage,proto3" json:"max_slippage,omitempty"`
}

func (m *EstimateWithdrawAmt) Reset()         { *m = EstimateWithdrawAmt{} }
func (m *EstimateWithdrawAmt) String() string { return proto.CompactTextString(m) }
func (*EstimateWithdrawAmt) ProtoMessage()    {}
func (*EstimateWithdrawAmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{20}
}
func (m *EstimateWithdrawAmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateWithdrawAmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateWithdrawAmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateWithdrawAmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateWithdrawAmt.Merge(m, src)
}
func (m *EstimateWithdrawAmt) XXX_Size() int {
	return m.Size()
}
func (m *EstimateWithdrawAmt) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateWithdrawAmt.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateWithdrawAmt proto.InternalMessageInfo

func (m *EstimateWithdrawAmt) GetEqValueTokenAmt() string {
	if m != nil {
		return m.EqValueTokenAmt
	}
	return ""
}

func (m *EstimateWithdrawAmt) GetBridgeRate() float32 {
	if m != nil {
		return m.BridgeRate
	}
	return 0
}

func (m *EstimateWithdrawAmt) GetPercFee() string {
	if m != nil {
		return m.PercFee
	}
	return ""
}

func (m *EstimateWithdrawAmt) GetBaseFee() string {
	if m != nil {
		return m.BaseFee
	}
	return ""
}

func (m *EstimateWithdrawAmt) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *EstimateWithdrawAmt) GetMaxSlippage() uint32 {
	if m != nil {
		return m.MaxSlippage
	}
	return 0
}

type GetLPInfoListRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetLPInfoListRequest) Reset()         { *m = GetLPInfoListRequest{} }
func (m *GetLPInfoListRequest) String() string { return proto.CompactTextString(m) }
func (*GetLPInfoListRequest) ProtoMessage()    {}
func (*GetLPInfoListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{21}
}
func (m *GetLPInfoListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLPInfoListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLPInfoListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLPInfoListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLPInfoListRequest.Merge(m, src)
}
func (m *GetLPInfoListRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLPInfoListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLPInfoListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLPInfoListRequest proto.InternalMessageInfo

func (m *GetLPInfoListRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type LPInfo struct {
	Chain                *Chain       `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token                *TokenInfo   `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Liquidity            float64      `protobuf:"fixed64,3,opt,name=liquidity,proto3" json:"liquidity,omitempty"`
	LiquidityAmt         string       `protobuf:"bytes,4,opt,name=liquidity_amt,json=liquidityAmt,proto3" json:"liquidity_amt,omitempty"`
	HasFarmingSessions   bool         `protobuf:"varint,5,opt,name=has_farming_sessions,json=hasFarmingSessions,proto3" json:"has_farming_sessions,omitempty"`
	LpFeeEarning         float64      `protobuf:"fixed64,6,opt,name=lp_fee_earning,json=lpFeeEarning,proto3" json:"lp_fee_earning,omitempty"`
	FarmingRewardEarning float64      `protobuf:"fixed64,7,opt,name=farming_reward_earning,json=farmingRewardEarning,proto3" json:"farming_reward_earning,omitempty"`
	Volume_24H           float64      `protobuf:"fixed64,8,opt,name=volume_24h,json=volume24h,proto3" json:"volume_24h,omitempty"`
	TotalLiquidity       float64      `protobuf:"fixed64,9,opt,name=total_liquidity,json=totalLiquidity,proto3" json:"total_liquidity,omitempty"`
	TotalLiquidityAmt    string       `protobuf:"bytes,10,opt,name=total_liquidity_amt,json=totalLiquidityAmt,proto3" json:"total_liquidity_amt,omitempty"`
	LpFeeEarningApy      float64      `protobuf:"fixed64,11,opt,name=lp_fee_earning_apy,json=lpFeeEarningApy,proto3" json:"lp_fee_earning_apy,omitempty"`
	FarmingApy           float64      `protobuf:"fixed64,12,opt,name=farming_apy,json=farmingApy,proto3" json:"farming_apy,omitempty"`
	FarmingSessionTokens []*TokenInfo `protobuf:"bytes,13,rep,name=farming_session_tokens,json=farmingSessionTokens,proto3" json:"farming_session_tokens,omitempty"`
}

func (m *LPInfo) Reset()         { *m = LPInfo{} }
func (m *LPInfo) String() string { return proto.CompactTextString(m) }
func (*LPInfo) ProtoMessage()    {}
func (*LPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{22}
}
func (m *LPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPInfo.Merge(m, src)
}
func (m *LPInfo) XXX_Size() int {
	return m.Size()
}
func (m *LPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LPInfo proto.InternalMessageInfo

func (m *LPInfo) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *LPInfo) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *LPInfo) GetLiquidity() float64 {
	if m != nil {
		return m.Liquidity
	}
	return 0
}

func (m *LPInfo) GetLiquidityAmt() string {
	if m != nil {
		return m.LiquidityAmt
	}
	return ""
}

func (m *LPInfo) GetHasFarmingSessions() bool {
	if m != nil {
		return m.HasFarmingSessions
	}
	return false
}

func (m *LPInfo) GetLpFeeEarning() float64 {
	if m != nil {
		return m.LpFeeEarning
	}
	return 0
}

func (m *LPInfo) GetFarmingRewardEarning() float64 {
	if m != nil {
		return m.FarmingRewardEarning
	}
	return 0
}

func (m *LPInfo) GetVolume_24H() float64 {
	if m != nil {
		return m.Volume_24H
	}
	return 0
}

func (m *LPInfo) GetTotalLiquidity() float64 {
	if m != nil {
		return m.TotalLiquidity
	}
	return 0
}

func (m *LPInfo) GetTotalLiquidityAmt() string {
	if m != nil {
		return m.TotalLiquidityAmt
	}
	return ""
}

func (m *LPInfo) GetLpFeeEarningApy() float64 {
	if m != nil {
		return m.LpFeeEarningApy
	}
	return 0
}

func (m *LPInfo) GetFarmingApy() float64 {
	if m != nil {
		return m.FarmingApy
	}
	return 0
}

func (m *LPInfo) GetFarmingSessionTokens() []*TokenInfo {
	if m != nil {
		return m.FarmingSessionTokens
	}
	return nil
}

type GetLPInfoListResponse struct {
	Err    *ErrMsg   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	LpInfo []*LPInfo `protobuf:"bytes,2,rep,name=lp_info,json=lpInfo,proto3" json:"lp_info,omitempty"`
}

func (m *GetLPInfoListResponse) Reset()         { *m = GetLPInfoListResponse{} }
func (m *GetLPInfoListResponse) String() string { return proto.CompactTextString(m) }
func (*GetLPInfoListResponse) ProtoMessage()    {}
func (*GetLPInfoListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{23}
}
func (m *GetLPInfoListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLPInfoListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLPInfoListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLPInfoListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLPInfoListResponse.Merge(m, src)
}
func (m *GetLPInfoListResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLPInfoListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLPInfoListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLPInfoListResponse proto.InternalMessageInfo

func (m *GetLPInfoListResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetLPInfoListResponse) GetLpInfo() []*LPInfo {
	if m != nil {
		return m.LpInfo
	}
	return nil
}

type WithdrawLiquidityRequest struct {
	WithdrawReq          []byte             `protobuf:"bytes,1,opt,name=withdraw_req,json=withdrawReq,proto3" json:"withdraw_req,omitempty"`
	Sig                  []byte             `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
	EstimatedReceivedAmt string             `protobuf:"bytes,3,opt,name=estimated_received_amt,json=estimatedReceivedAmt,proto3" json:"estimated_received_amt,omitempty"`
	MethodType           WithdrawMethodType `protobuf:"varint,4,opt,name=method_type,json=methodType,proto3,enum=sgn.gateway.v1.WithdrawMethodType" json:"method_type,omitempty"`
}

func (m *WithdrawLiquidityRequest) Reset()         { *m = WithdrawLiquidityRequest{} }
func (m *WithdrawLiquidityRequest) String() string { return proto.CompactTextString(m) }
func (*WithdrawLiquidityRequest) ProtoMessage()    {}
func (*WithdrawLiquidityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{24}
}
func (m *WithdrawLiquidityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawLiquidityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawLiquidityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawLiquidityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawLiquidityRequest.Merge(m, src)
}
func (m *WithdrawLiquidityRequest) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawLiquidityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawLiquidityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawLiquidityRequest proto.InternalMessageInfo

func (m *WithdrawLiquidityRequest) GetWithdrawReq() []byte {
	if m != nil {
		return m.WithdrawReq
	}
	return nil
}

func (m *WithdrawLiquidityRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *WithdrawLiquidityRequest) GetEstimatedReceivedAmt() string {
	if m != nil {
		return m.EstimatedReceivedAmt
	}
	return ""
}

func (m *WithdrawLiquidityRequest) GetMethodType() WithdrawMethodType {
	if m != nil {
		return m.MethodType
	}
	return WithdrawMethodType_WD_METHOD_TYPE_UNDEFINED
}

type WithdrawLiquidityResponse struct {
	Err    *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	SeqNum uint64  `protobuf:"varint,2,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
}

func (m *WithdrawLiquidityResponse) Reset()         { *m = WithdrawLiquidityResponse{} }
func (m *WithdrawLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*WithdrawLiquidityResponse) ProtoMessage()    {}
func (*WithdrawLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{25}
}
func (m *WithdrawLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawLiquidityResponse.Merge(m, src)
}
func (m *WithdrawLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawLiquidityResponse proto.InternalMessageInfo

func (m *WithdrawLiquidityResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *WithdrawLiquidityResponse) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

type UnlockFarmingRewardRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *UnlockFarmingRewardRequest) Reset()         { *m = UnlockFarmingRewardRequest{} }
func (m *UnlockFarmingRewardRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockFarmingRewardRequest) ProtoMessage()    {}
func (*UnlockFarmingRewardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{26}
}
func (m *UnlockFarmingRewardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockFarmingRewardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockFarmingRewardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockFarmingRewardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockFarmingRewardRequest.Merge(m, src)
}
func (m *UnlockFarmingRewardRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockFarmingRewardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockFarmingRewardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockFarmingRewardRequest proto.InternalMessageInfo

func (m *UnlockFarmingRewardRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type UnlockFarmingRewardResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *UnlockFarmingRewardResponse) Reset()         { *m = UnlockFarmingRewardResponse{} }
func (m *UnlockFarmingRewardResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockFarmingRewardResponse) ProtoMessage()    {}
func (*UnlockFarmingRewardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{27}
}
func (m *UnlockFarmingRewardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockFarmingRewardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockFarmingRewardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockFarmingRewardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockFarmingRewardResponse.Merge(m, src)
}
func (m *UnlockFarmingRewardResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockFarmingRewardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockFarmingRewardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockFarmingRewardResponse proto.InternalMessageInfo

func (m *UnlockFarmingRewardResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetFarmingRewardDetailsRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetFarmingRewardDetailsRequest) Reset()         { *m = GetFarmingRewardDetailsRequest{} }
func (m *GetFarmingRewardDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*GetFarmingRewardDetailsRequest) ProtoMessage()    {}
func (*GetFarmingRewardDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{28}
}
func (m *GetFarmingRewardDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFarmingRewardDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFarmingRewardDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFarmingRewardDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFarmingRewardDetailsRequest.Merge(m, src)
}
func (m *GetFarmingRewardDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFarmingRewardDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFarmingRewardDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFarmingRewardDetailsRequest proto.InternalMessageInfo

func (m *GetFarmingRewardDetailsRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type GetFarmingRewardDetailsResponse struct {
	Err     *ErrMsg                      `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Details []*types1.RewardClaimDetails `protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty"`
}

func (m *GetFarmingRewardDetailsResponse) Reset()         { *m = GetFarmingRewardDetailsResponse{} }
func (m *GetFarmingRewardDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*GetFarmingRewardDetailsResponse) ProtoMessage()    {}
func (*GetFarmingRewardDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{29}
}
func (m *GetFarmingRewardDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFarmingRewardDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFarmingRewardDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFarmingRewardDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFarmingRewardDetailsResponse.Merge(m, src)
}
func (m *GetFarmingRewardDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetFarmingRewardDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFarmingRewardDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFarmingRewardDetailsResponse proto.InternalMessageInfo

func (m *GetFarmingRewardDetailsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetFarmingRewardDetailsResponse) GetDetails() []*types1.RewardClaimDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type QueryLiquidityStatusRequest struct {
	SeqNum  uint64 `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	TxHash  string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	LpAddr  string `protobuf:"bytes,3,opt,name=lp_addr,json=lpAddr,proto3" json:"lp_addr,omitempty"`
	ChainId uint32 `protobuf:"varint,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Type    LPType `protobuf:"varint,5,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
}

func (m *QueryLiquidityStatusRequest) Reset()         { *m = QueryLiquidityStatusRequest{} }
func (m *QueryLiquidityStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidityStatusRequest) ProtoMessage()    {}
func (*QueryLiquidityStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{30}
}
func (m *QueryLiquidityStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidityStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidityStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidityStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidityStatusRequest.Merge(m, src)
}
func (m *QueryLiquidityStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidityStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidityStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidityStatusRequest proto.InternalMessageInfo

func (m *QueryLiquidityStatusRequest) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *QueryLiquidityStatusRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *QueryLiquidityStatusRequest) GetLpAddr() string {
	if m != nil {
		return m.LpAddr
	}
	return ""
}

func (m *QueryLiquidityStatusRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *QueryLiquidityStatusRequest) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

type TransferHistory struct {
	TransferId      string                      `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	SrcSendInfo     *TransferInfo               `protobuf:"bytes,2,opt,name=src_send_info,json=srcSendInfo,proto3" json:"src_send_info,omitempty"`
	DstReceivedInfo *TransferInfo               `protobuf:"bytes,3,opt,name=dst_received_info,json=dstReceivedInfo,proto3" json:"dst_received_info,omitempty"`
	Ts              uint64                      `protobuf:"varint,4,opt,name=ts,proto3" json:"ts,omitempty"`
	SrcBlockTxLink  string                      `protobuf:"bytes,5,opt,name=src_block_tx_link,json=srcBlockTxLink,proto3" json:"src_block_tx_link,omitempty"`
	DstBlockTxLink  string                      `protobuf:"bytes,6,opt,name=dst_block_tx_link,json=dstBlockTxLink,proto3" json:"dst_block_tx_link,omitempty"`
	Status          types.TransferHistoryStatus `protobuf:"varint,7,opt,name=status,proto3,enum=sgn.cbridge.v1.TransferHistoryStatus" json:"status,omitempty"`
	RefundReason    types.XferStatus            `protobuf:"varint,8,opt,name=refund_reason,json=refundReason,proto3,enum=sgn.cbridge.v1.XferStatus" json:"refund_reason,omitempty"`
}

func (m *TransferHistory) Reset()         { *m = TransferHistory{} }
func (m *TransferHistory) String() string { return proto.CompactTextString(m) }
func (*TransferHistory) ProtoMessage()    {}
func (*TransferHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{31}
}
func (m *TransferHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistory.Merge(m, src)
}
func (m *TransferHistory) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistory.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistory proto.InternalMessageInfo

func (m *TransferHistory) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

func (m *TransferHistory) GetSrcSendInfo() *TransferInfo {
	if m != nil {
		return m.SrcSendInfo
	}
	return nil
}

func (m *TransferHistory) GetDstReceivedInfo() *TransferInfo {
	if m != nil {
		return m.DstReceivedInfo
	}
	return nil
}

func (m *TransferHistory) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *TransferHistory) GetSrcBlockTxLink() string {
	if m != nil {
		return m.SrcBlockTxLink
	}
	return ""
}

func (m *TransferHistory) GetDstBlockTxLink() string {
	if m != nil {
		return m.DstBlockTxLink
	}
	return ""
}

func (m *TransferHistory) GetStatus() types.TransferHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.TransferHistoryStatus_TRANSFER_UNKNOWN
}

func (m *TransferHistory) GetRefundReason() types.XferStatus {
	if m != nil {
		return m.RefundReason
	}
	return types.XferStatus_UNKNOWN
}

type LPHistory struct {
	Chain       *Chain               `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token       *TokenInfo           `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Amount      string               `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Ts          uint64               `protobuf:"varint,4,opt,name=ts,proto3" json:"ts,omitempty"`
	BlockTxLink string               `protobuf:"bytes,5,opt,name=block_tx_link,json=blockTxLink,proto3" json:"block_tx_link,omitempty"`
	Status      types.WithdrawStatus `protobuf:"varint,6,opt,name=status,proto3,enum=sgn.cbridge.v1.WithdrawStatus" json:"status,omitempty"`
	Type        LPType               `protobuf:"varint,7,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
	SeqNum      uint64               `protobuf:"varint,8,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	MethodType  WithdrawMethodType   `protobuf:"varint,9,opt,name=method_type,json=methodType,proto3,enum=sgn.gateway.v1.WithdrawMethodType" json:"method_type,omitempty"`
	Nonce       uint64               `protobuf:"varint,10,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *LPHistory) Reset()         { *m = LPHistory{} }
func (m *LPHistory) String() string { return proto.CompactTextString(m) }
func (*LPHistory) ProtoMessage()    {}
func (*LPHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{32}
}
func (m *LPHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistory.Merge(m, src)
}
func (m *LPHistory) XXX_Size() int {
	return m.Size()
}
func (m *LPHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistory.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistory proto.InternalMessageInfo

func (m *LPHistory) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *LPHistory) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *LPHistory) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *LPHistory) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *LPHistory) GetBlockTxLink() string {
	if m != nil {
		return m.BlockTxLink
	}
	return ""
}

func (m *LPHistory) GetStatus() types.WithdrawStatus {
	if m != nil {
		return m.Status
	}
	return types.WithdrawStatus_WD_UNKNOWN
}

func (m *LPHistory) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

func (m *LPHistory) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *LPHistory) GetMethodType() WithdrawMethodType {
	if m != nil {
		return m.MethodType
	}
	return WithdrawMethodType_WD_METHOD_TYPE_UNDEFINED
}

func (m *LPHistory) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type TransferHistoryRequest struct {
	NextPageToken string `protobuf:"bytes,1,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	PageSize      uint64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Addr          string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *TransferHistoryRequest) Reset()         { *m = TransferHistoryRequest{} }
func (m *TransferHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*TransferHistoryRequest) ProtoMessage()    {}
func (*TransferHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{33}
}
func (m *TransferHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistoryRequest.Merge(m, src)
}
func (m *TransferHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistoryRequest proto.InternalMessageInfo

func (m *TransferHistoryRequest) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *TransferHistoryRequest) GetPageSize() uint64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *TransferHistoryRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type TransferHistoryResponse struct {
	Err           *ErrMsg            `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	History       []*TransferHistory `protobuf:"bytes,2,rep,name=history,proto3" json:"history,omitempty"`
	NextPageToken string             `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	CurrentSize   uint64             `protobuf:"varint,4,opt,name=current_size,json=currentSize,proto3" json:"current_size,omitempty"`
}

func (m *TransferHistoryResponse) Reset()         { *m = TransferHistoryResponse{} }
func (m *TransferHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*TransferHistoryResponse) ProtoMessage()    {}
func (*TransferHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{34}
}
func (m *TransferHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistoryResponse.Merge(m, src)
}
func (m *TransferHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistoryResponse proto.InternalMessageInfo

func (m *TransferHistoryResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *TransferHistoryResponse) GetHistory() []*TransferHistory {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *TransferHistoryResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *TransferHistoryResponse) GetCurrentSize() uint64 {
	if m != nil {
		return m.CurrentSize
	}
	return 0
}

type LPHistoryRequest struct {
	NextPageToken string `protobuf:"bytes,1,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	PageSize      uint64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Addr          string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *LPHistoryRequest) Reset()         { *m = LPHistoryRequest{} }
func (m *LPHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*LPHistoryRequest) ProtoMessage()    {}
func (*LPHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{35}
}
func (m *LPHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistoryRequest.Merge(m, src)
}
func (m *LPHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *LPHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistoryRequest proto.InternalMessageInfo

func (m *LPHistoryRequest) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *LPHistoryRequest) GetPageSize() uint64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *LPHistoryRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type LPHistoryResponse struct {
	Err           *ErrMsg      `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	History       []*LPHistory `protobuf:"bytes,2,rep,name=history,proto3" json:"history,omitempty"`
	NextPageToken string       `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	CurrentSize   uint64       `protobuf:"varint,4,opt,name=current_size,json=currentSize,proto3" json:"current_size,omitempty"`
}

func (m *LPHistoryResponse) Reset()         { *m = LPHistoryResponse{} }
func (m *LPHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*LPHistoryResponse) ProtoMessage()    {}
func (*LPHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{36}
}
func (m *LPHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistoryResponse.Merge(m, src)
}
func (m *LPHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *LPHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistoryResponse proto.InternalMessageInfo

func (m *LPHistoryResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *LPHistoryResponse) GetHistory() []*LPHistory {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *LPHistoryResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *LPHistoryResponse) GetCurrentSize() uint64 {
	if m != nil {
		return m.CurrentSize
	}
	return 0
}

type RewardingDataRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *RewardingDataRequest) Reset()         { *m = RewardingDataRequest{} }
func (m *RewardingDataRequest) String() string { return proto.CompactTextString(m) }
func (*RewardingDataRequest) ProtoMessage()    {}
func (*RewardingDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{37}
}
func (m *RewardingDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardingDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardingDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardingDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardingDataRequest.Merge(m, src)
}
func (m *RewardingDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *RewardingDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardingDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RewardingDataRequest proto.InternalMessageInfo

func (m *RewardingDataRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type Reward struct {
	Amt   float64      `protobuf:"fixed64,1,opt,name=amt,proto3" json:"amt,omitempty"`
	Token *types.Token `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *Reward) Reset()         { *m = Reward{} }
func (m *Reward) String() string { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()    {}
func (*Reward) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{38}
}
func (m *Reward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reward.Merge(m, src)
}
func (m *Reward) XXX_Size() int {
	return m.Size()
}
func (m *Reward) XXX_DiscardUnknown() {
	xxx_messageInfo_Reward.DiscardUnknown(m)
}

var xxx_messageInfo_Reward proto.InternalMessageInfo

func (m *Reward) GetAmt() float64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *Reward) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type RewardingDataResponse struct {
	Err                         *ErrMsg            `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	UsdPrice                    map[string]float64 `protobuf:"bytes,2,rep,name=usd_price,json=usdPrice,proto3" json:"usd_price,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	HistoricalCumulativeRewards []*Reward          `protobuf:"bytes,3,rep,name=historical_cumulative_rewards,json=historicalCumulativeRewards,proto3" json:"historical_cumulative_rewards,omitempty"`
	UnlockedCumulativeRewards   []*Reward          `protobuf:"bytes,4,rep,name=unlocked_cumulative_rewards,json=unlockedCumulativeRewards,proto3" json:"unlocked_cumulative_rewards,omitempty"`
}

func (m *RewardingDataResponse) Reset()         { *m = RewardingDataResponse{} }
func (m *RewardingDataResponse) String() string { return proto.CompactTextString(m) }
func (*RewardingDataResponse) ProtoMessage()    {}
func (*RewardingDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{39}
}
func (m *RewardingDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardingDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardingDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardingDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardingDataResponse.Merge(m, src)
}
func (m *RewardingDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *RewardingDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardingDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RewardingDataResponse proto.InternalMessageInfo

func (m *RewardingDataResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *RewardingDataResponse) GetUsdPrice() map[string]float64 {
	if m != nil {
		return m.UsdPrice
	}
	return nil
}

func (m *RewardingDataResponse) GetHistoricalCumulativeRewards() []*Reward {
	if m != nil {
		return m.HistoricalCumulativeRewards
	}
	return nil
}

func (m *RewardingDataResponse) GetUnlockedCumulativeRewards() []*Reward {
	if m != nil {
		return m.UnlockedCumulativeRewards
	}
	return nil
}

type UpdateChainRequest struct {
	Chain       *Chain `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	TxUrlPrefix string `protobuf:"bytes,2,opt,name=tx_url_prefix,json=txUrlPrefix,proto3" json:"tx_url_prefix,omitempty"`
	Sig         []byte `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
	Addr        string `protobuf:"bytes,4,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *UpdateChainRequest) Reset()         { *m = UpdateChainRequest{} }
func (m *UpdateChainRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateChainRequest) ProtoMessage()    {}
func (*UpdateChainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{40}
}
func (m *UpdateChainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateChainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateChainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateChainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateChainRequest.Merge(m, src)
}
func (m *UpdateChainRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateChainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateChainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateChainRequest proto.InternalMessageInfo

func (m *UpdateChainRequest) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *UpdateChainRequest) GetTxUrlPrefix() string {
	if m != nil {
		return m.TxUrlPrefix
	}
	return ""
}

func (m *UpdateChainRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *UpdateChainRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type UpdateChainResponse struct {
	Err         *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Chain       *Chain  `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	TxUrlPrefix string  `protobuf:"bytes,3,opt,name=tx_url_prefix,json=txUrlPrefix,proto3" json:"tx_url_prefix,omitempty"`
}

func (m *UpdateChainResponse) Reset()         { *m = UpdateChainResponse{} }
func (m *UpdateChainResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateChainResponse) ProtoMessage()    {}
func (*UpdateChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{41}
}
func (m *UpdateChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateChainResponse.Merge(m, src)
}
func (m *UpdateChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateChainResponse proto.InternalMessageInfo

func (m *UpdateChainResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *UpdateChainResponse) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *UpdateChainResponse) GetTxUrlPrefix() string {
	if m != nil {
		return m.TxUrlPrefix
	}
	return ""
}

type UpdateTokenRequest struct {
	ChainId     uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TokenSymbol string `protobuf:"bytes,2,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
	TokenName   string `protobuf:"bytes,3,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`
	TokenIcon   string `protobuf:"bytes,4,opt,name=token_icon,json=tokenIcon,proto3" json:"token_icon,omitempty"`
	Sig         []byte `protobuf:"bytes,5,opt,name=sig,proto3" json:"sig,omitempty"`
	Addr        string `protobuf:"bytes,6,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *UpdateTokenRequest) Reset()         { *m = UpdateTokenRequest{} }
func (m *UpdateTokenRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateTokenRequest) ProtoMessage()    {}
func (*UpdateTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{42}
}
func (m *UpdateTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTokenRequest.Merge(m, src)
}
func (m *UpdateTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTokenRequest proto.InternalMessageInfo

func (m *UpdateTokenRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *UpdateTokenRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

func (m *UpdateTokenRequest) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

func (m *UpdateTokenRequest) GetTokenIcon() string {
	if m != nil {
		return m.TokenIcon
	}
	return ""
}

func (m *UpdateTokenRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *UpdateTokenRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type UpdateTokenResponse struct {
	Err   *ErrMsg    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Token *TokenInfo `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *UpdateTokenResponse) Reset()         { *m = UpdateTokenResponse{} }
func (m *UpdateTokenResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateTokenResponse) ProtoMessage()    {}
func (*UpdateTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{43}
}
func (m *UpdateTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTokenResponse.Merge(m, src)
}
func (m *UpdateTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTokenResponse proto.InternalMessageInfo

func (m *UpdateTokenResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *UpdateTokenResponse) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

type StakingConfigRequest struct {
}

func (m *StakingConfigRequest) Reset()         { *m = StakingConfigRequest{} }
func (m *StakingConfigRequest) String() string { return proto.CompactTextString(m) }
func (*StakingConfigRequest) ProtoMessage()    {}
func (*StakingConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{44}
}
func (m *StakingConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakingConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakingConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakingConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakingConfigRequest.Merge(m, src)
}
func (m *StakingConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *StakingConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StakingConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StakingConfigRequest proto.InternalMessageInfo

type StakingConfigResponse struct {
	ViewerContract        string `protobuf:"bytes,1,opt,name=viewer_contract,json=viewerContract,proto3" json:"viewer_contract,omitempty"`
	StakingContract       string `protobuf:"bytes,2,opt,name=staking_contract,json=stakingContract,proto3" json:"staking_contract,omitempty"`
	StakingRewardContract string `protobuf:"bytes,3,opt,name=staking_reward_contract,json=stakingRewardContract,proto3" json:"staking_reward_contract,omitempty"`
	CelrContract          string `protobuf:"bytes,4,opt,name=celr_contract,json=celrContract,proto3" json:"celr_contract,omitempty"`
}

func (m *StakingConfigResponse) Reset()         { *m = StakingConfigResponse{} }
func (m *StakingConfigResponse) String() string { return proto.CompactTextString(m) }
func (*StakingConfigResponse) ProtoMessage()    {}
func (*StakingConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{45}
}
func (m *StakingConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakingConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakingConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakingConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakingConfigResponse.Merge(m, src)
}
func (m *StakingConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *StakingConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StakingConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StakingConfigResponse proto.InternalMessageInfo

func (m *StakingConfigResponse) GetViewerContract() string {
	if m != nil {
		return m.ViewerContract
	}
	return ""
}

func (m *StakingConfigResponse) GetStakingContract() string {
	if m != nil {
		return m.StakingContract
	}
	return ""
}

func (m *StakingConfigResponse) GetStakingRewardContract() string {
	if m != nil {
		return m.StakingRewardContract
	}
	return ""
}

func (m *StakingConfigResponse) GetCelrContract() string {
	if m != nil {
		return m.CelrContract
	}
	return ""
}

type UnlockStakingRewardRequest struct {
	DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
}

func (m *UnlockStakingRewardRequest) Reset()         { *m = UnlockStakingRewardRequest{} }
func (m *UnlockStakingRewardRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockStakingRewardRequest) ProtoMessage()    {}
func (*UnlockStakingRewardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{46}
}
func (m *UnlockStakingRewardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockStakingRewardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockStakingRewardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockStakingRewardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockStakingRewardRequest.Merge(m, src)
}
func (m *UnlockStakingRewardRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockStakingRewardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockStakingRewardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockStakingRewardRequest proto.InternalMessageInfo

func (m *UnlockStakingRewardRequest) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

type UnlockStakingRewardResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *UnlockStakingRewardResponse) Reset()         { *m = UnlockStakingRewardResponse{} }
func (m *UnlockStakingRewardResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockStakingRewardResponse) ProtoMessage()    {}
func (*UnlockStakingRewardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{47}
}
func (m *UnlockStakingRewardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockStakingRewardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockStakingRewardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockStakingRewardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockStakingRewardResponse.Merge(m, src)
}
func (m *UnlockStakingRewardResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockStakingRewardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockStakingRewardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockStakingRewardResponse proto.InternalMessageInfo

func (m *UnlockStakingRewardResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetStakingRewardDetailsRequest struct {
	DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
}

func (m *GetStakingRewardDetailsRequest) Reset()         { *m = GetStakingRewardDetailsRequest{} }
func (m *GetStakingRewardDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*GetStakingRewardDetailsRequest) ProtoMessage()    {}
func (*GetStakingRewardDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{48}
}
func (m *GetStakingRewardDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStakingRewardDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStakingRewardDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStakingRewardDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStakingRewardDetailsRequest.Merge(m, src)
}
func (m *GetStakingRewardDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStakingRewardDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStakingRewardDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStakingRewardDetailsRequest proto.InternalMessageInfo

func (m *GetStakingRewardDetailsRequest) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

type GetStakingRewardDetailsResponse struct {
	Err    *ErrMsg                        `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Detail *types2.StakingRewardClaimInfo `protobuf:"bytes,2,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *GetStakingRewardDetailsResponse) Reset()         { *m = GetStakingRewardDetailsResponse{} }
func (m *GetStakingRewardDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*GetStakingRewardDetailsResponse) ProtoMessage()    {}
func (*GetStakingRewardDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{49}
}
func (m *GetStakingRewardDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStakingRewardDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStakingRewardDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStakingRewardDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStakingRewardDetailsResponse.Merge(m, src)
}
func (m *GetStakingRewardDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetStakingRewardDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStakingRewardDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStakingRewardDetailsResponse proto.InternalMessageInfo

func (m *GetStakingRewardDetailsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetStakingRewardDetailsResponse) GetDetail() *types2.StakingRewardClaimInfo {
	if m != nil {
		return m.Detail
	}
	return nil
}

type GetTotalLiquidityProviderTokenBalanceRequest struct {
	ChainIds    []uint32 `protobuf:"varint,1,rep,packed,name=chain_ids,json=chainIds,proto3" json:"chain_ids,omitempty"`
	TokenSymbol string   `protobuf:"bytes,2,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) Reset() {
	*m = GetTotalLiquidityProviderTokenBalanceRequest{}
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) String() string {
	return proto.CompactTextString(m)
}
func (*GetTotalLiquidityProviderTokenBalanceRequest) ProtoMessage() {}
func (*GetTotalLiquidityProviderTokenBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{50}
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest.Merge(m, src)
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest proto.InternalMessageInfo

func (m *GetTotalLiquidityProviderTokenBalanceRequest) GetChainIds() []uint32 {
	if m != nil {
		return m.ChainIds
	}
	return nil
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

type GetTotalLiquidityProviderTokenBalanceResponse struct {
	Err      *ErrMsg           `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	TotalLiq map[uint64]string `protobuf:"bytes,2,rep,name=total_liq,json=totalLiq,proto3" json:"total_liq,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) Reset() {
	*m = GetTotalLiquidityProviderTokenBalanceResponse{}
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) String() string {
	return proto.CompactTextString(m)
}
func (*GetTotalLiquidityProviderTokenBalanceResponse) ProtoMessage() {}
func (*GetTotalLiquidityProviderTokenBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{51}
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse.Merge(m, src)
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse proto.InternalMessageInfo

func (m *GetTotalLiquidityProviderTokenBalanceResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) GetTotalLiq() map[uint64]string {
	if m != nil {
		return m.TotalLiq
	}
	return nil
}

type GetInfoByTxHashRequest struct {
	ChainId uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TxHash  string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	Type    CSType `protobuf:"varint,3,opt,name=type,proto3,enum=sgn.gateway.v1.CSType" json:"type,omitempty"`
	Sig     []byte `protobuf:"bytes,4,opt,name=sig,proto3" json:"sig,omitempty"`
	Addr    string `protobuf:"bytes,5,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetInfoByTxHashRequest) Reset()         { *m = GetInfoByTxHashRequest{} }
func (m *GetInfoByTxHashRequest) String() string { return proto.CompactTextString(m) }
func (*GetInfoByTxHashRequest) ProtoMessage()    {}
func (*GetInfoByTxHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{52}
}
func (m *GetInfoByTxHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInfoByTxHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInfoByTxHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInfoByTxHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInfoByTxHashRequest.Merge(m, src)
}
func (m *GetInfoByTxHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetInfoByTxHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInfoByTxHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetInfoByTxHashRequest proto.InternalMessageInfo

func (m *GetInfoByTxHashRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *GetInfoByTxHashRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *GetInfoByTxHashRequest) GetType() CSType {
	if m != nil {
		return m.Type
	}
	return CSType_CT_UNKNOWN
}

func (m *GetInfoByTxHashRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *GetInfoByTxHashRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type GetInfoByTxHashResponse struct {
	Operation CSOperation    `protobuf:"varint,1,opt,name=operation,proto3,enum=sgn.gateway.v1.CSOperation" json:"operation,omitempty"`
	Status    UserCaseStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sgn.gateway.v1.UserCaseStatus" json:"status,omitempty"`
	Memo      string         `protobuf:"bytes,3,opt,name=memo,proto3" json:"memo,omitempty"`
	Info      string         `protobuf:"bytes,4,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *GetInfoByTxHashResponse) Reset()         { *m = GetInfoByTxHashResponse{} }
func (m *GetInfoByTxHashResponse) String() string { return proto.CompactTextString(m) }
func (*GetInfoByTxHashResponse) ProtoMessage()    {}
func (*GetInfoByTxHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{53}
}
func (m *GetInfoByTxHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetInfoByTxHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetInfoByTxHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetInfoByTxHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetInfoByTxHashResponse.Merge(m, src)
}
func (m *GetInfoByTxHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetInfoByTxHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetInfoByTxHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetInfoByTxHashResponse proto.InternalMessageInfo

func (m *GetInfoByTxHashResponse) GetOperation() CSOperation {
	if m != nil {
		return m.Operation
	}
	return CSOperation_CA_UNKNOWN
}

func (m *GetInfoByTxHashResponse) GetStatus() UserCaseStatus {
	if m != nil {
		return m.Status
	}
	return UserCaseStatus_CC_UNKNOWN
}

func (m *GetInfoByTxHashResponse) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *GetInfoByTxHashResponse) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

type FixEventMissRequest struct {
	ChainId uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TxHash  string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	Type    CSType `protobuf:"varint,3,opt,name=type,proto3,enum=sgn.gateway.v1.CSType" json:"type,omitempty"`
	Sig     []byte `protobuf:"bytes,4,opt,name=sig,proto3" json:"sig,omitempty"`
	Addr    string `protobuf:"bytes,5,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *FixEventMissRequest) Reset()         { *m = FixEventMissRequest{} }
func (m *FixEventMissRequest) String() string { return proto.CompactTextString(m) }
func (*FixEventMissRequest) ProtoMessage()    {}
func (*FixEventMissRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{54}
}
func (m *FixEventMissRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FixEventMissRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FixEventMissRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FixEventMissRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FixEventMissRequest.Merge(m, src)
}
func (m *FixEventMissRequest) XXX_Size() int {
	return m.Size()
}
func (m *FixEventMissRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FixEventMissRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FixEventMissRequest proto.InternalMessageInfo

func (m *FixEventMissRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *FixEventMissRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *FixEventMissRequest) GetType() CSType {
	if m != nil {
		return m.Type
	}
	return CSType_CT_UNKNOWN
}

func (m *FixEventMissRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *FixEventMissRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type FixEventMissResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *FixEventMissResponse) Reset()         { *m = FixEventMissResponse{} }
func (m *FixEventMissResponse) String() string { return proto.CompactTextString(m) }
func (*FixEventMissResponse) ProtoMessage()    {}
func (*FixEventMissResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{55}
}
func (m *FixEventMissResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FixEventMissResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FixEventMissResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FixEventMissResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FixEventMissResponse.Merge(m, src)
}
func (m *FixEventMissResponse) XXX_Size() int {
	return m.Size()
}
func (m *FixEventMissResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FixEventMissResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FixEventMissResponse proto.InternalMessageInfo

func (m *FixEventMissResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetRetentionRewardsInfoRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetRetentionRewardsInfoRequest) Reset()         { *m = GetRetentionRewardsInfoRequest{} }
func (m *GetRetentionRewardsInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetRetentionRewardsInfoRequest) ProtoMessage()    {}
func (*GetRetentionRewardsInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{56}
}
func (m *GetRetentionRewardsInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRetentionRewardsInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRetentionRewardsInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRetentionRewardsInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRetentionRewardsInfoRequest.Merge(m, src)
}
func (m *GetRetentionRewardsInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetRetentionRewardsInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRetentionRewardsInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRetentionRewardsInfoRequest proto.InternalMessageInfo

func (m *GetRetentionRewardsInfoRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type GetRetentionRewardsInfoResponse struct {
	Err     *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	EventId uint64  `protobuf:"varint,2,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// in millis
	EventEndTime uint64 `protobuf:"varint,3,opt,name=event_end_time,json=eventEndTime,proto3" json:"event_end_time,omitempty"`
	// in CELR
	MaxReward         string  `protobuf:"bytes,4,opt,name=max_reward,json=maxReward,proto3" json:"max_reward,omitempty"`
	MaxTransferVolume float64 `protobuf:"fixed64,5,opt,name=max_transfer_volume,json=maxTransferVolume,proto3" json:"max_transfer_volume,omitempty"`
	// in wei
	CurrentReward string  `protobuf:"bytes,6,opt,name=current_reward,json=currentReward,proto3" json:"current_reward,omitempty"`
	CelrUsdPrice  float64 `protobuf:"fixed64,7,opt,name=celr_usd_price,json=celrUsdPrice,proto3" json:"celr_usd_price,omitempty"`
	// if not 0 means already claimed
	ClaimTime uint64 `protobuf:"varint,8,opt,name=claim_time,json=claimTime,proto3" json:"claim_time,omitempty"`
	// signatures defines the signatures to be verified on Ethereum.
	Signature types3.Signature `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature" yaml:"signature"`
}

func (m *GetRetentionRewardsInfoResponse) Reset()         { *m = GetRetentionRewardsInfoResponse{} }
func (m *GetRetentionRewardsInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetRetentionRewardsInfoResponse) ProtoMessage()    {}
func (*GetRetentionRewardsInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{57}
}
func (m *GetRetentionRewardsInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetRetentionRewardsInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetRetentionRewardsInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetRetentionRewardsInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRetentionRewardsInfoResponse.Merge(m, src)
}
func (m *GetRetentionRewardsInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetRetentionRewardsInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRetentionRewardsInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetRetentionRewardsInfoResponse proto.InternalMessageInfo

func (m *GetRetentionRewardsInfoResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetRetentionRewardsInfoResponse) GetEventId() uint64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *GetRetentionRewardsInfoResponse) GetEventEndTime() uint64 {
	if m != nil {
		return m.EventEndTime
	}
	return 0
}

func (m *GetRetentionRewardsInfoResponse) GetMaxReward() string {
	if m != nil {
		return m.MaxReward
	}
	return ""
}

func (m *GetRetentionRewardsInfoResponse) GetMaxTransferVolume() float64 {
	if m != nil {
		return m.MaxTransferVolume
	}
	return 0
}

func (m *GetRetentionRewardsInfoResponse) GetCurrentReward() string {
	if m != nil {
		return m.CurrentReward
	}
	return ""
}

func (m *GetRetentionRewardsInfoResponse) GetCelrUsdPrice() float64 {
	if m != nil {
		return m.CelrUsdPrice
	}
	return 0
}

func (m *GetRetentionRewardsInfoResponse) GetClaimTime() uint64 {
	if m != nil {
		return m.ClaimTime
	}
	return 0
}

func (m *GetRetentionRewardsInfoResponse) GetSignature() types3.Signature {
	if m != nil {
		return m.Signature
	}
	return types3.Signature{}
}

type ClaimRetentionRewardsRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *ClaimRetentionRewardsRequest) Reset()         { *m = ClaimRetentionRewardsRequest{} }
func (m *ClaimRetentionRewardsRequest) String() string { return proto.CompactTextString(m) }
func (*ClaimRetentionRewardsRequest) ProtoMessage()    {}
func (*ClaimRetentionRewardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{58}
}
func (m *ClaimRetentionRewardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimRetentionRewardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimRetentionRewardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimRetentionRewardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimRetentionRewardsRequest.Merge(m, src)
}
func (m *ClaimRetentionRewardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClaimRetentionRewardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimRetentionRewardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimRetentionRewardsRequest proto.InternalMessageInfo

func (m *ClaimRetentionRewardsRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type ClaimRetentionRewardsResponse struct {
	Err     *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	EventId uint64  `protobuf:"varint,2,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// in wei
	CurrentReward string `protobuf:"bytes,3,opt,name=current_reward,json=currentReward,proto3" json:"current_reward,omitempty"`
	// signatures defines the signatures to be verified on Ethereum.
	Signature types3.Signature `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature" yaml:"signature"`
}

func (m *ClaimRetentionRewardsResponse) Reset()         { *m = ClaimRetentionRewardsResponse{} }
func (m *ClaimRetentionRewardsResponse) String() string { return proto.CompactTextString(m) }
func (*ClaimRetentionRewardsResponse) ProtoMessage()    {}
func (*ClaimRetentionRewardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{59}
}
func (m *ClaimRetentionRewardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimRetentionRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimRetentionRewardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimRetentionRewardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimRetentionRewardsResponse.Merge(m, src)
}
func (m *ClaimRetentionRewardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClaimRetentionRewardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimRetentionRewardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimRetentionRewardsResponse proto.InternalMessageInfo

func (m *ClaimRetentionRewardsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *ClaimRetentionRewardsResponse) GetEventId() uint64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *ClaimRetentionRewardsResponse) GetCurrentReward() string {
	if m != nil {
		return m.CurrentReward
	}
	return ""
}

func (m *ClaimRetentionRewardsResponse) GetSignature() types3.Signature {
	if m != nil {
		return m.Signature
	}
	return types3.Signature{}
}

type GetFeeRebateInfoRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetFeeRebateInfoRequest) Reset()         { *m = GetFeeRebateInfoRequest{} }
func (m *GetFeeRebateInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetFeeRebateInfoRequest) ProtoMessage()    {}
func (*GetFeeRebateInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{60}
}
func (m *GetFeeRebateInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFeeRebateInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFeeRebateInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFeeRebateInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFeeRebateInfoRequest.Merge(m, src)
}
func (m *GetFeeRebateInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFeeRebateInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFeeRebateInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFeeRebateInfoRequest proto.InternalMessageInfo

func (m *GetFeeRebateInfoRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type GetFeeRebateInfoResponse struct {
	Err     *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	EventId uint64  `protobuf:"varint,2,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// in millis
	EventEndTime  uint64  `protobuf:"varint,3,opt,name=event_end_time,json=eventEndTime,proto3" json:"event_end_time,omitempty"`
	RebatePortion float64 `protobuf:"fixed64,4,opt,name=rebate_portion,json=rebatePortion,proto3" json:"rebate_portion,omitempty"`
	// CELR in wei
	Reward       string  `protobuf:"bytes,5,opt,name=reward,proto3" json:"reward,omitempty"`
	CelrUsdPrice float64 `protobuf:"fixed64,6,opt,name=celr_usd_price,json=celrUsdPrice,proto3" json:"celr_usd_price,omitempty"`
	// if not 0 means already claimed
	ClaimTime uint64 `protobuf:"varint,7,opt,name=claim_time,json=claimTime,proto3" json:"claim_time,omitempty"`
	// signatures defines the signatures to be verified on Ethereum.
	Signature types3.Signature `protobuf:"bytes,8,opt,name=signature,proto3" json:"signature" yaml:"signature"`
}

func (m *GetFeeRebateInfoResponse) Reset()         { *m = GetFeeRebateInfoResponse{} }
func (m *GetFeeRebateInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetFeeRebateInfoResponse) ProtoMessage()    {}
func (*GetFeeRebateInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{61}
}
func (m *GetFeeRebateInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFeeRebateInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFeeRebateInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFeeRebateInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFeeRebateInfoResponse.Merge(m, src)
}
func (m *GetFeeRebateInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetFeeRebateInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFeeRebateInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFeeRebateInfoResponse proto.InternalMessageInfo

func (m *GetFeeRebateInfoResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetFeeRebateInfoResponse) GetEventId() uint64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *GetFeeRebateInfoResponse) GetEventEndTime() uint64 {
	if m != nil {
		return m.EventEndTime
	}
	return 0
}

func (m *GetFeeRebateInfoResponse) GetRebatePortion() float64 {
	if m != nil {
		return m.RebatePortion
	}
	return 0
}

func (m *GetFeeRebateInfoResponse) GetReward() string {
	if m != nil {
		return m.Reward
	}
	return ""
}

func (m *GetFeeRebateInfoResponse) GetCelrUsdPrice() float64 {
	if m != nil {
		return m.CelrUsdPrice
	}
	return 0
}

func (m *GetFeeRebateInfoResponse) GetClaimTime() uint64 {
	if m != nil {
		return m.ClaimTime
	}
	return 0
}

func (m *GetFeeRebateInfoResponse) GetSignature() types3.Signature {
	if m != nil {
		return m.Signature
	}
	return types3.Signature{}
}

type ClaimFeeRebateRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *ClaimFeeRebateRequest) Reset()         { *m = ClaimFeeRebateRequest{} }
func (m *ClaimFeeRebateRequest) String() string { return proto.CompactTextString(m) }
func (*ClaimFeeRebateRequest) ProtoMessage()    {}
func (*ClaimFeeRebateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{62}
}
func (m *ClaimFeeRebateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimFeeRebateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimFeeRebateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimFeeRebateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimFeeRebateRequest.Merge(m, src)
}
func (m *ClaimFeeRebateRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClaimFeeRebateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimFeeRebateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimFeeRebateRequest proto.InternalMessageInfo

func (m *ClaimFeeRebateRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type ClaimFeeRebateResponse struct {
	Err     *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	EventId uint64  `protobuf:"varint,2,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// in wei
	Reward string `protobuf:"bytes,3,opt,name=reward,proto3" json:"reward,omitempty"`
	// signatures defines the signatures to be verified on Ethereum.
	Signature types3.Signature `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature" yaml:"signature"`
}

func (m *ClaimFeeRebateResponse) Reset()         { *m = ClaimFeeRebateResponse{} }
func (m *ClaimFeeRebateResponse) String() string { return proto.CompactTextString(m) }
func (*ClaimFeeRebateResponse) ProtoMessage()    {}
func (*ClaimFeeRebateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{63}
}
func (m *ClaimFeeRebateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimFeeRebateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimFeeRebateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimFeeRebateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimFeeRebateResponse.Merge(m, src)
}
func (m *ClaimFeeRebateResponse) XXX_Size() int {
	return m.Size()
}
func (m *ClaimFeeRebateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimFeeRebateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimFeeRebateResponse proto.InternalMessageInfo

func (m *ClaimFeeRebateResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *ClaimFeeRebateResponse) GetEventId() uint64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *ClaimFeeRebateResponse) GetReward() string {
	if m != nil {
		return m.Reward
	}
	return ""
}

func (m *ClaimFeeRebateResponse) GetSignature() types3.Signature {
	if m != nil {
		return m.Signature
	}
	return types3.Signature{}
}

type ReportCurrentBlockNumberRequest struct {
	// serialized CurrentBlockNumberReport
	Report []byte `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
	Sig    []byte `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *ReportCurrentBlockNumberRequest) Reset()         { *m = ReportCurrentBlockNumberRequest{} }
func (m *ReportCurrentBlockNumberRequest) String() string { return proto.CompactTextString(m) }
func (*ReportCurrentBlockNumberRequest) ProtoMessage()    {}
func (*ReportCurrentBlockNumberRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{64}
}
func (m *ReportCurrentBlockNumberRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportCurrentBlockNumberRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportCurrentBlockNumberRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportCurrentBlockNumberRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportCurrentBlockNumberRequest.Merge(m, src)
}
func (m *ReportCurrentBlockNumberRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReportCurrentBlockNumberRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportCurrentBlockNumberRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReportCurrentBlockNumberRequest proto.InternalMessageInfo

func (m *ReportCurrentBlockNumberRequest) GetReport() []byte {
	if m != nil {
		return m.Report
	}
	return nil
}

func (m *ReportCurrentBlockNumberRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

type CurrentBlockNumberReport struct {
	// in millis
	Timestamp uint64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// key is chainId, value is block number
	BlockNums map[uint64]uint64 `protobuf:"bytes,2,rep,name=block_nums,json=blockNums,proto3" json:"block_nums,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *CurrentBlockNumberReport) Reset()         { *m = CurrentBlockNumberReport{} }
func (m *CurrentBlockNumberReport) String() string { return proto.CompactTextString(m) }
func (*CurrentBlockNumberReport) ProtoMessage()    {}
func (*CurrentBlockNumberReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{65}
}
func (m *CurrentBlockNumberReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrentBlockNumberReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrentBlockNumberReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrentBlockNumberReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentBlockNumberReport.Merge(m, src)
}
func (m *CurrentBlockNumberReport) XXX_Size() int {
	return m.Size()
}
func (m *CurrentBlockNumberReport) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentBlockNumberReport.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentBlockNumberReport proto.InternalMessageInfo

func (m *CurrentBlockNumberReport) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CurrentBlockNumberReport) GetBlockNums() map[uint64]uint64 {
	if m != nil {
		return m.BlockNums
	}
	return nil
}

type ReportCurrentBlockNumberResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ReportCurrentBlockNumberResponse) Reset()         { *m = ReportCurrentBlockNumberResponse{} }
func (m *ReportCurrentBlockNumberResponse) String() string { return proto.CompactTextString(m) }
func (*ReportCurrentBlockNumberResponse) ProtoMessage()    {}
func (*ReportCurrentBlockNumberResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{66}
}
func (m *ReportCurrentBlockNumberResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportCurrentBlockNumberResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportCurrentBlockNumberResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportCurrentBlockNumberResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportCurrentBlockNumberResponse.Merge(m, src)
}
func (m *ReportCurrentBlockNumberResponse) XXX_Size() int {
	return m.Size()
}
func (m *ReportCurrentBlockNumberResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportCurrentBlockNumberResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReportCurrentBlockNumberResponse proto.InternalMessageInfo

func (m *ReportCurrentBlockNumberResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type ErrMsg struct {
	Code ErrCode `protobuf:"varint,1,opt,name=code,proto3,enum=sgn.gateway.v1.ErrCode" json:"code,omitempty"`
	Msg  string  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ErrMsg) Reset()         { *m = ErrMsg{} }
func (m *ErrMsg) String() string { return proto.CompactTextString(m) }
func (*ErrMsg) ProtoMessage()    {}
func (*ErrMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{67}
}
func (m *ErrMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrMsg.Merge(m, src)
}
func (m *ErrMsg) XXX_Size() int {
	return m.Size()
}
func (m *ErrMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ErrMsg proto.InternalMessageInfo

func (m *ErrMsg) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_ERROR_CODE_UNDEFINED
}

func (m *ErrMsg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("sgn.gateway.v1.LPType", LPType_name, LPType_value)
	proto.RegisterEnum("sgn.gateway.v1.CSType", CSType_name, CSType_value)
	proto.RegisterEnum("sgn.gateway.v1.CSOperation", CSOperation_name, CSOperation_value)
	proto.RegisterEnum("sgn.gateway.v1.UserCaseStatus", UserCaseStatus_name, UserCaseStatus_value)
	proto.RegisterEnum("sgn.gateway.v1.WithdrawMethodType", WithdrawMethodType_name, WithdrawMethodType_value)
	proto.RegisterEnum("sgn.gateway.v1.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterType((*GetCampaignScoresRequest)(nil), "sgn.gateway.v1.GetCampaignScoresRequest")
	proto.RegisterType((*GetCampaignScoresResponse)(nil), "sgn.gateway.v1.GetCampaignScoresResponse")
	proto.RegisterType((*CampaignScore)(nil), "sgn.gateway.v1.CampaignScore")
	proto.RegisterType((*QueryLiquidityStatusResponse)(nil), "sgn.gateway.v1.QueryLiquidityStatusResponse")
	proto.RegisterType((*Chain)(nil), "sgn.gateway.v1.Chain")
	proto.RegisterType((*ChainTokenInfo)(nil), "sgn.gateway.v1.ChainTokenInfo")
	proto.RegisterType((*TokenInfo)(nil), "sgn.gateway.v1.TokenInfo")
	proto.RegisterType((*TransferInfo)(nil), "sgn.gateway.v1.TransferInfo")
	proto.RegisterType((*GetTransferStatusRequest)(nil), "sgn.gateway.v1.GetTransferStatusRequest")
	proto.RegisterType((*GetTransferStatusResponse)(nil), "sgn.gateway.v1.GetTransferStatusResponse")
	proto.RegisterType((*GetTransferConfigsRequest)(nil), "sgn.gateway.v1.GetTransferConfigsRequest")
	proto.RegisterType((*GetTransferConfigsResponse)(nil), "sgn.gateway.v1.GetTransferConfigsResponse")
	proto.RegisterMapType((map[uint32]*ChainTokenInfo)(nil), "sgn.gateway.v1.GetTransferConfigsResponse.ChainTokenEntry")
	proto.RegisterType((*PeggedPairConfig)(nil), "sgn.gateway.v1.PeggedPairConfig")
	proto.RegisterType((*GetTokenInfoRequest)(nil), "sgn.gateway.v1.GetTokenInfoRequest")
	proto.RegisterType((*GetTokenInfoResponse)(nil), "sgn.gateway.v1.GetTokenInfoResponse")
	proto.RegisterType((*EstimateAmtRequest)(nil), "sgn.gateway.v1.EstimateAmtRequest")
	proto.RegisterType((*EstimateAmtResponse)(nil), "sgn.gateway.v1.EstimateAmtResponse")
	proto.RegisterType((*WithdrawInfo)(nil), "sgn.gateway.v1.WithdrawInfo")
	proto.RegisterType((*EstimateWithdrawAmtRequest)(nil), "sgn.gateway.v1.EstimateWithdrawAmtRequest")
	proto.RegisterType((*EstimateWithdrawAmtResponse)(nil), "sgn.gateway.v1.EstimateWithdrawAmtResponse")
	proto.RegisterMapType((map[uint32]*EstimateWithdrawAmt)(nil), "sgn.gateway.v1.EstimateWithdrawAmtResponse.ReqAmtEntry")
	proto.RegisterType((*EstimateWithdrawAmt)(nil), "sgn.gateway.v1.EstimateWithdrawAmt")
	proto.RegisterType((*GetLPInfoListRequest)(nil), "sgn.gateway.v1.GetLPInfoListRequest")
	proto.RegisterType((*LPInfo)(nil), "sgn.gateway.v1.LPInfo")
	proto.RegisterType((*GetLPInfoListResponse)(nil), "sgn.gateway.v1.GetLPInfoListResponse")
	proto.RegisterType((*WithdrawLiquidityRequest)(nil), "sgn.gateway.v1.WithdrawLiquidityRequest")
	proto.RegisterType((*WithdrawLiquidityResponse)(nil), "sgn.gateway.v1.WithdrawLiquidityResponse")
	proto.RegisterType((*UnlockFarmingRewardRequest)(nil), "sgn.gateway.v1.UnlockFarmingRewardRequest")
	proto.RegisterType((*UnlockFarmingRewardResponse)(nil), "sgn.gateway.v1.UnlockFarmingRewardResponse")
	proto.RegisterType((*GetFarmingRewardDetailsRequest)(nil), "sgn.gateway.v1.GetFarmingRewardDetailsRequest")
	proto.RegisterType((*GetFarmingRewardDetailsResponse)(nil), "sgn.gateway.v1.GetFarmingRewardDetailsResponse")
	proto.RegisterType((*QueryLiquidityStatusRequest)(nil), "sgn.gateway.v1.QueryLiquidityStatusRequest")
	proto.RegisterType((*TransferHistory)(nil), "sgn.gateway.v1.TransferHistory")
	proto.RegisterType((*LPHistory)(nil), "sgn.gateway.v1.LPHistory")
	proto.RegisterType((*TransferHistoryRequest)(nil), "sgn.gateway.v1.TransferHistoryRequest")
	proto.RegisterType((*TransferHistoryResponse)(nil), "sgn.gateway.v1.TransferHistoryResponse")
	proto.RegisterType((*LPHistoryRequest)(nil), "sgn.gateway.v1.LPHistoryRequest")
	proto.RegisterType((*LPHistoryResponse)(nil), "sgn.gateway.v1.LPHistoryResponse")
	proto.RegisterType((*RewardingDataRequest)(nil), "sgn.gateway.v1.RewardingDataRequest")
	proto.RegisterType((*Reward)(nil), "sgn.gateway.v1.Reward")
	proto.RegisterType((*RewardingDataResponse)(nil), "sgn.gateway.v1.RewardingDataResponse")
	proto.RegisterMapType((map[string]float64)(nil), "sgn.gateway.v1.RewardingDataResponse.UsdPriceEntry")
	proto.RegisterType((*UpdateChainRequest)(nil), "sgn.gateway.v1.UpdateChainRequest")
	proto.RegisterType((*UpdateChainResponse)(nil), "sgn.gateway.v1.UpdateChainResponse")
	proto.RegisterType((*UpdateTokenRequest)(nil), "sgn.gateway.v1.UpdateTokenRequest")
	proto.RegisterType((*UpdateTokenResponse)(nil), "sgn.gateway.v1.UpdateTokenResponse")
	proto.RegisterType((*StakingConfigRequest)(nil), "sgn.gateway.v1.StakingConfigRequest")
	proto.RegisterType((*StakingConfigResponse)(nil), "sgn.gateway.v1.StakingConfigResponse")
	proto.RegisterType((*UnlockStakingRewardRequest)(nil), "sgn.gateway.v1.UnlockStakingRewardRequest")
	proto.RegisterType((*UnlockStakingRewardResponse)(nil), "sgn.gateway.v1.UnlockStakingRewardResponse")
	proto.RegisterType((*GetStakingRewardDetailsRequest)(nil), "sgn.gateway.v1.GetStakingRewardDetailsRequest")
	proto.RegisterType((*GetStakingRewardDetailsResponse)(nil), "sgn.gateway.v1.GetStakingRewardDetailsResponse")
	proto.RegisterType((*GetTotalLiquidityProviderTokenBalanceRequest)(nil), "sgn.gateway.v1.GetTotalLiquidityProviderTokenBalanceRequest")
	proto.RegisterType((*GetTotalLiquidityProviderTokenBalanceResponse)(nil), "sgn.gateway.v1.GetTotalLiquidityProviderTokenBalanceResponse")
	proto.RegisterMapType((map[uint64]string)(nil), "sgn.gateway.v1.GetTotalLiquidityProviderTokenBalanceResponse.TotalLiqEntry")
	proto.RegisterType((*GetInfoByTxHashRequest)(nil), "sgn.gateway.v1.GetInfoByTxHashRequest")
	proto.RegisterType((*GetInfoByTxHashResponse)(nil), "sgn.gateway.v1.GetInfoByTxHashResponse")
	proto.RegisterType((*FixEventMissRequest)(nil), "sgn.gateway.v1.FixEventMissRequest")
	proto.RegisterType((*FixEventMissResponse)(nil), "sgn.gateway.v1.FixEventMissResponse")
	proto.RegisterType((*GetRetentionRewardsInfoRequest)(nil), "sgn.gateway.v1.GetRetentionRewardsInfoRequest")
	proto.RegisterType((*GetRetentionRewardsInfoResponse)(nil), "sgn.gateway.v1.GetRetentionRewardsInfoResponse")
	proto.RegisterType((*ClaimRetentionRewardsRequest)(nil), "sgn.gateway.v1.ClaimRetentionRewardsRequest")
	proto.RegisterType((*ClaimRetentionRewardsResponse)(nil), "sgn.gateway.v1.ClaimRetentionRewardsResponse")
	proto.RegisterType((*GetFeeRebateInfoRequest)(nil), "sgn.gateway.v1.GetFeeRebateInfoRequest")
	proto.RegisterType((*GetFeeRebateInfoResponse)(nil), "sgn.gateway.v1.GetFeeRebateInfoResponse")
	proto.RegisterType((*ClaimFeeRebateRequest)(nil), "sgn.gateway.v1.ClaimFeeRebateRequest")
	proto.RegisterType((*ClaimFeeRebateResponse)(nil), "sgn.gateway.v1.ClaimFeeRebateResponse")
	proto.RegisterType((*ReportCurrentBlockNumberRequest)(nil), "sgn.gateway.v1.ReportCurrentBlockNumberRequest")
	proto.RegisterType((*CurrentBlockNumberReport)(nil), "sgn.gateway.v1.CurrentBlockNumberReport")
	proto.RegisterMapType((map[uint64]uint64)(nil), "sgn.gateway.v1.CurrentBlockNumberReport.BlockNumsEntry")
	proto.RegisterType((*ReportCurrentBlockNumberResponse)(nil), "sgn.gateway.v1.ReportCurrentBlockNumberResponse")
	proto.RegisterType((*ErrMsg)(nil), "sgn.gateway.v1.ErrMsg")
}

func init() { proto.RegisterFile("sgn/gateway/v1/gateway.proto", fileDescriptor_4ec1f1e4252d2467) }

var fileDescriptor_4ec1f1e4252d2467 = []byte{
	// 4795 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5c, 0x4d, 0x6c, 0x23, 0xc9,
	0x75, 0x9e, 0x26, 0x29, 0x52, 0x7c, 0xa2, 0x28, 0xaa, 0xa4, 0xd1, 0x50, 0x94, 0x46, 0xa3, 0xe9,
	0xf9, 0x59, 0x8d, 0x66, 0x47, 0xf2, 0xc8, 0x9b, 0x8d, 0x77, 0xbd, 0x86, 0x97, 0xa2, 0xa8, 0x19,
	0x66, 0x25, 0x52, 0x6e, 0x52, 0x3b, 0x5e, 0x07, 0x71, 0xa7, 0xc5, 0xae, 0xa1, 0x1a, 0x43, 0x76,
	0x53, 0x5d, 0x4d, 0xfd, 0xec, 0x21, 0x36, 0x9c, 0x5c, 0x12, 0x27, 0xc1, 0xc2, 0x46, 0x0e, 0x76,
	0x80, 0xe4, 0x12, 0x38, 0x37, 0xe7, 0x12, 0x24, 0xa7, 0x20, 0x97, 0x00, 0xd9, 0xe4, 0xb0, 0x30,
	0x90, 0x43, 0x02, 0x04, 0x31, 0x82, 0xdd, 0x20, 0x40, 0xe2, 0x9c, 0x02, 0x5f, 0x72, 0x0b, 0xea,
	0xa7, 0xc9, 0xfe, 0x23, 0x25, 0x4e, 0x66, 0x93, 0xdc, 0x9a, 0xef, 0x7d, 0x55, 0xef, 0xd5, 0xab,
	0x57, 0xaf, 0x5e, 0xbd, 0x2a, 0x09, 0x96, 0x49, 0xcb, 0xdc, 0x6c, 0x69, 0x0e, 0x3e, 0xd3, 0x2e,
	0x36, 0x4f, 0x1f, 0xbb, 0x9f, 0x1b, 0x5d, 0xdb, 0x72, 0x2c, 0x94, 0x25, 0x2d, 0x73, 0xc3, 0x25,
	0x9d, 0x3e, 0x2e, 0xcc, 0xb7, 0xac, 0x96, 0xc5, 0x58, 0x9b, 0xf4, 0x8b, 0xa3, 0x0a, 0xcb, 0x2d,
	0xcb, 0x6a, 0xb5, 0xf1, 0xa6, 0xd6, 0x35, 0x36, 0x35, 0xd3, 0xb4, 0x1c, 0xcd, 0x31, 0x2c, 0x93,
	0x08, 0x6e, 0x81, 0x4a, 0x68, 0x1e, 0xd9, 0x86, 0xde, 0xc2, 0x54, 0xc2, 0x49, 0x0f, 0xdb, 0x17,
	0x6e, 0xcb, 0x00, 0x4f, 0x7c, 0xfa, 0x5a, 0x5a, 0x9d, 0x8e, 0x65, 0x32, 0x26, 0xfb, 0xf2, 0xb6,
	0x7c, 0xae, 0xd9, 0x1d, 0xc3, 0x6c, 0x51, 0xa6, 0xf8, 0x14, 0xdc, 0xfb, 0x94, 0xab, 0x1b, 0xc4,
	0xb1, 0x8d, 0xa3, 0x1e, 0x55, 0x86, 0x42, 0xbc, 0xbf, 0x05, 0x6e, 0xa5, 0x69, 0x91, 0x8e, 0x45,
	0x36, 0x8f, 0x34, 0x42, 0xe5, 0x1f, 0x61, 0x47, 0xa3, 0x72, 0x0c, 0xc1, 0x97, 0xdb, 0x90, 0x7f,
	0x82, 0x9d, 0x92, 0xd6, 0xe9, 0x6a, 0x46, 0xcb, 0xac, 0x37, 0x2d, 0x1b, 0x13, 0x05, 0x9f, 0xf4,
	0x30, 0x71, 0x10, 0x82, 0x84, 0xae, 0x39, 0x38, 0x2f, 0xad, 0x4a, 0x6b, 0xd3, 0x0a, 0xfb, 0x46,
	0xb7, 0x60, 0xea, 0x08, 0xb7, 0x0c, 0x53, 0x3d, 0x6a, 0x5b, 0xcd, 0x17, 0xf9, 0xd8, 0xaa, 0xb4,
	0x96, 0x50, 0x80, 0x91, 0xb6, 0x29, 0x05, 0x2d, 0x41, 0x1a, 0x9b, 0xba, 0x60, 0xc7, 0x19, 0x7b,
	0x12, 0x9b, 0x3a, 0x63, 0xca, 0xdf, 0x93, 0x60, 0x31, 0x42, 0x1c, 0xe9, 0x5a, 0x26, 0xc1, 0xe8,
	0x17, 0x20, 0x49, 0x18, 0x25, 0x2f, 0xad, 0xc6, 0xd7, 0xa6, 0xb6, 0x6e, 0x6e, 0xf8, 0x27, 0x67,
	0xc3, 0xd7, 0x4e, 0x11, 0x60, 0xb4, 0x06, 0x71, 0x6c, 0xdb, 0x4c, 0x95, 0xa9, 0xad, 0x85, 0x60,
	0x9b, 0xb2, 0x6d, 0xef, 0x93, 0x96, 0x42, 0x21, 0x68, 0x1e, 0x26, 0x98, 0xa6, 0x42, 0x2f, 0xfe,
	0x43, 0x7e, 0x17, 0xa6, 0x7d, 0x1d, 0xa3, 0x45, 0x98, 0xec, 0x11, 0x5b, 0xd5, 0x74, 0xdd, 0x66,
	0x63, 0x4f, 0x2b, 0xa9, 0x1e, 0xb1, 0x8b, 0xba, 0xce, 0x7a, 0x60, 0x52, 0xc5, 0xc0, 0xf9, 0x0f,
	0xf9, 0xcf, 0x63, 0xb0, 0xfc, 0x35, 0x3a, 0xe9, 0x7b, 0xc6, 0x49, 0xcf, 0xd0, 0x0d, 0xe7, 0xa2,
	0xee, 0x68, 0x4e, 0x6f, 0x30, 0x32, 0xa1, 0xa2, 0x74, 0xb9, 0x8a, 0x6f, 0x42, 0x92, 0xb0, 0xb6,
	0x4c, 0x42, 0x76, 0x6b, 0x85, 0x81, 0x5d, 0xaf, 0x39, 0x7d, 0xbc, 0xf1, 0xcc, 0x70, 0x8e, 0x75,
	0x5b, 0x3b, 0x13, 0x12, 0x04, 0x1a, 0xdd, 0x04, 0x38, 0xd3, 0x55, 0xcb, 0x6c, 0x1e, 0x6b, 0x62,
	0x7c, 0x19, 0x25, 0x7d, 0xa6, 0xd7, 0x38, 0x81, 0x4e, 0x1b, 0xb1, 0x6c, 0x07, 0xeb, 0x2a, 0x31,
	0x5a, 0x24, 0x9f, 0x58, 0x8d, 0xaf, 0x65, 0x14, 0xe0, 0xa4, 0xba, 0xd1, 0x22, 0x28, 0x0f, 0x29,
	0x62, 0xb4, 0x4c, 0x6c, 0x93, 0xfc, 0x04, 0x63, 0xba, 0x3f, 0xd1, 0x02, 0x24, 0xbb, 0xd6, 0x19,
	0x65, 0x24, 0x19, 0x43, 0xfc, 0x42, 0x32, 0x4c, 0xb3, 0x49, 0x56, 0x9d, 0x73, 0xb5, 0x6d, 0x98,
	0x2f, 0xf2, 0x29, 0x66, 0xaa, 0x29, 0x46, 0x6c, 0x9c, 0xef, 0x19, 0xe6, 0x0b, 0xe6, 0x2d, 0x0c,
	0xa3, 0xe3, 0xb6, 0x76, 0x91, 0x9f, 0x64, 0x8e, 0x04, 0x8c, 0xb4, 0x43, 0x29, 0xf2, 0x8f, 0x62,
	0x30, 0x51, 0x62, 0x1a, 0x66, 0x21, 0x66, 0xe8, 0xc2, 0xd5, 0x62, 0x86, 0x4e, 0x9d, 0xcf, 0xd4,
	0x3a, 0xdc, 0xd0, 0x69, 0x85, 0x7d, 0x53, 0x9a, 0xd1, 0xb4, 0xf8, 0xf0, 0xd2, 0x0a, 0xfb, 0x0e,
	0x8a, 0x48, 0x04, 0x45, 0xa0, 0x35, 0xc8, 0xb5, 0x34, 0xa2, 0x3a, 0xd6, 0x0b, 0x6c, 0xaa, 0xe4,
	0xa2, 0x73, 0x64, 0xb5, 0xf3, 0x13, 0xac, 0x83, 0x6c, 0x4b, 0x23, 0x0d, 0x4a, 0xae, 0x33, 0x2a,
	0xed, 0x0a, 0x9f, 0x77, 0xdb, 0x96, 0x8d, 0xd5, 0x9e, 0xdd, 0xce, 0x27, 0x19, 0x08, 0x04, 0xe9,
	0xd0, 0x6e, 0xa3, 0x3b, 0x30, 0xdd, 0xb4, 0x4c, 0xc7, 0xd6, 0x9a, 0x0e, 0xf7, 0x8e, 0x49, 0x06,
	0xc9, 0xb8, 0x44, 0xe6, 0x22, 0xab, 0x90, 0xd1, 0x6d, 0xab, 0xab, 0x52, 0xa1, 0x5a, 0xc7, 0xc9,
	0xa7, 0x79, 0x37, 0x94, 0xf6, 0x44, 0x23, 0xc5, 0x8e, 0x83, 0x5e, 0x07, 0x44, 0x7a, 0xad, 0x16,
	0x26, 0x74, 0x3e, 0xe8, 0xc2, 0x54, 0x9f, 0x63, 0x9c, 0x87, 0x55, 0x69, 0x4d, 0x52, 0x72, 0x7d,
	0xce, 0xb6, 0x46, 0xf0, 0x2e, 0xc6, 0xbf, 0x94, 0x98, 0x4c, 0xe5, 0x26, 0xe5, 0x22, 0x64, 0x99,
	0x9d, 0x98, 0xbe, 0x15, 0xf3, 0xb9, 0x85, 0x36, 0x61, 0x82, 0x8d, 0x49, 0x2c, 0x96, 0xc5, 0xa0,
	0x57, 0xf5, 0x91, 0x0a, 0xc7, 0xc9, 0xbf, 0x0a, 0xe9, 0x41, 0xeb, 0x87, 0x83, 0xd6, 0xd4, 0x27,
	0xaf, 0x07, 0xdd, 0x8c, 0x21, 0x45, 0xcb, 0xab, 0xce, 0x85, 0xfc, 0x6d, 0x09, 0x32, 0x0d, 0x5b,
	0x33, 0xc9, 0x73, 0x6c, 0xbb, 0x52, 0xb8, 0x43, 0x7a, 0xa5, 0x78, 0x17, 0x34, 0x65, 0x2a, 0x1c,
	0x33, 0x50, 0x29, 0x76, 0x05, 0x95, 0x16, 0x20, 0xa9, 0x75, 0xac, 0x9e, 0xe9, 0x08, 0x05, 0xc4,
	0x2f, 0xf9, 0xcb, 0x2c, 0x9e, 0xb9, 0x4a, 0xb8, 0xcb, 0x90, 0xc7, 0xb3, 0x5b, 0x30, 0xe5, 0x08,
	0x86, 0x2a, 0x7c, 0x2d, 0xad, 0x80, 0x4b, 0xaa, 0xe8, 0xf2, 0x8f, 0xe3, 0x2c, 0x3c, 0x05, 0x5b,
	0x8f, 0xbd, 0x88, 0xbf, 0x12, 0x58, 0xc4, 0xf7, 0x42, 0x43, 0x11, 0x12, 0x9e, 0x1a, 0xc4, 0xb1,
	0xec, 0x8b, 0xff, 0xf3, 0xb5, 0xfc, 0x55, 0x98, 0xb6, 0xf1, 0xf3, 0x9e, 0xa9, 0xab, 0x36, 0xd6,
	0x88, 0x65, 0xb2, 0xb5, 0x9c, 0xdd, 0x2a, 0x04, 0xf5, 0xfe, 0xfa, 0xc0, 0x2a, 0x19, 0xde, 0x40,
	0x61, 0xf8, 0x4b, 0x17, 0x3a, 0x7a, 0x00, 0xb3, 0xc4, 0x6e, 0xaa, 0xfe, 0x88, 0xc1, 0x97, 0x46,
	0x96, 0xd8, 0xcd, 0x6d, 0x4f, 0xd0, 0x78, 0x00, 0xb3, 0x3a, 0x71, 0x02, 0x50, 0xe0, 0x50, 0x9d,
	0x38, 0x1e, 0xa8, 0xbc, 0xe4, 0x9b, 0xaf, 0x92, 0x65, 0x3e, 0x37, 0x5a, 0xee, 0x74, 0xcb, 0x7f,
	0x15, 0x87, 0x42, 0x14, 0x77, 0xec, 0xe9, 0x7c, 0x04, 0x49, 0x66, 0x79, 0x3a, 0x9d, 0xf1, 0xe1,
	0x6e, 0x2c, 0x40, 0xe8, 0x97, 0x61, 0x8a, 0x7d, 0xf1, 0x90, 0x93, 0x8f, 0xb3, 0x36, 0x6f, 0x07,
	0xdb, 0x0c, 0xd7, 0x6c, 0x63, 0xb0, 0xd0, 0xcb, 0xa6, 0x63, 0x5f, 0x28, 0xd0, 0xec, 0x13, 0xd0,
	0x57, 0x61, 0x59, 0x24, 0x02, 0xaa, 0x8d, 0xcf, 0x34, 0x5b, 0x57, 0xfd, 0x11, 0x29, 0xc1, 0xec,
	0xb4, 0x28, 0x30, 0x0a, 0x83, 0x94, 0xbc, 0xe1, 0xe9, 0x00, 0xe6, 0xba, 0xb8, 0xd5, 0xc2, 0xba,
	0xda, 0xd5, 0x0c, 0x9b, 0xb6, 0xa6, 0xb2, 0x99, 0xa3, 0x4c, 0x6d, 0xad, 0x06, 0xb5, 0x3c, 0x60,
	0xd0, 0x03, 0xcd, 0x10, 0x4a, 0x2a, 0xb3, 0xdd, 0x00, 0x85, 0x14, 0x7e, 0x05, 0x66, 0x02, 0x1a,
	0xa3, 0x1c, 0xc4, 0x5f, 0xe0, 0x0b, 0x11, 0xcd, 0xe9, 0x27, 0x7a, 0x03, 0x26, 0x4e, 0xb5, 0x76,
	0x0f, 0x8b, 0xc5, 0xbd, 0x12, 0x69, 0x42, 0x4f, 0xc8, 0x62, 0xe0, 0xb7, 0x63, 0x5f, 0x92, 0xe4,
	0x4f, 0x62, 0x90, 0x0b, 0xaa, 0x41, 0x83, 0xac, 0x65, 0xb7, 0x54, 0x6e, 0xe7, 0xfe, 0xbe, 0x01,
	0x96, 0xdd, 0x62, 0x1d, 0x55, 0x74, 0xf4, 0x26, 0xa4, 0x29, 0xc2, 0x1b, 0x51, 0x46, 0x84, 0xc8,
	0x49, 0xcb, 0x6e, 0x71, 0x03, 0xdf, 0x87, 0x19, 0x61, 0x9f, 0x7e, 0xe7, 0x71, 0xd6, 0xf9, 0x34,
	0x27, 0xbb, 0xfd, 0xbf, 0x03, 0x19, 0x81, 0xe3, 0x22, 0x12, 0x97, 0x89, 0x98, 0xe2, 0xf0, 0xfe,
	0x34, 0x8a, 0xd6, 0x3a, 0xee, 0x5a, 0xc4, 0x70, 0x02, 0xd3, 0xc8, 0x37, 0xa8, 0x45, 0x8e, 0xd9,
	0xe1, 0x10, 0xdf, 0x34, 0xbe, 0x05, 0x82, 0xa9, 0x1e, 0xf5, 0x6c, 0x33, 0xd0, 0x9a, 0xef, 0x5c,
	0x0b, 0x1c, 0xb0, 0xdd, 0xb3, 0x4d, 0x6f, 0x53, 0xb9, 0x0e, 0x73, 0xd4, 0xf9, 0xfa, 0x8a, 0x89,
	0xe8, 0xb8, 0x08, 0x93, 0x01, 0x73, 0xa6, 0x9a, 0x62, 0xac, 0xb7, 0x21, 0xe3, 0xdb, 0x3e, 0xf9,
	0x3e, 0x30, 0xe5, 0x0c, 0xf6, 0x4e, 0xf9, 0x43, 0x98, 0xf7, 0x77, 0x3a, 0xf6, 0x2a, 0xfb, 0x12,
	0x00, 0x17, 0x62, 0x98, 0xcf, 0xad, 0xcb, 0x67, 0x2c, 0xed, 0xb8, 0x9f, 0xf2, 0xcf, 0x25, 0x40,
	0x65, 0xe2, 0x18, 0x1d, 0xcd, 0xc1, 0xc5, 0x8e, 0xe3, 0x0e, 0x68, 0x15, 0x32, 0x34, 0xe4, 0x04,
	0x7d, 0x84, 0xd8, 0x4d, 0x77, 0x0e, 0xe9, 0x56, 0x4d, 0x9c, 0x01, 0x22, 0xc6, 0x11, 0x3a, 0x71,
	0x4a, 0x43, 0x46, 0x1e, 0x0f, 0x8d, 0x9c, 0xfa, 0x3a, 0xdd, 0xe6, 0xf9, 0xc2, 0xa3, 0x9f, 0xbe,
	0xfc, 0x71, 0xc2, 0x9f, 0x3f, 0x3e, 0x02, 0x44, 0xda, 0x46, 0xb7, 0xab, 0xb5, 0xb0, 0xea, 0x58,
	0x6d, 0x6c, 0x6b, 0x66, 0x13, 0xb3, 0xf9, 0x9a, 0x56, 0x66, 0x5d, 0x4e, 0xc3, 0x65, 0xd0, 0x64,
	0xda, 0x20, 0x2a, 0x9f, 0x47, 0x16, 0x93, 0x27, 0x95, 0x49, 0x83, 0xf0, 0xd5, 0x20, 0xff, 0x5e,
	0x0c, 0xe6, 0x7c, 0xc3, 0x1e, 0xdb, 0xe4, 0x0f, 0x01, 0xe1, 0x13, 0x95, 0x2d, 0x35, 0x91, 0x1f,
	0xd1, 0x91, 0xf0, 0xd9, 0x9d, 0xc1, 0x27, 0xef, 0x53, 0x06, 0xb3, 0x38, 0xcd, 0x5a, 0x68, 0x88,
	0x67, 0x1b, 0x81, 0x6a, 0xd3, 0x43, 0x01, 0xb5, 0x44, 0x4c, 0x01, 0x4e, 0x52, 0xe8, 0xd1, 0x60,
	0x11, 0x26, 0xbb, 0xd8, 0x6e, 0xb2, 0x64, 0x86, 0x5b, 0x23, 0x45, 0x7f, 0xef, 0x62, 0xc6, 0xea,
	0xe7, 0x39, 0x3c, 0x4d, 0x4c, 0x1d, 0xf1, 0xf4, 0x66, 0x88, 0x45, 0x26, 0x86, 0x59, 0xe4, 0x36,
	0x64, 0x3a, 0xda, 0xb9, 0xea, 0x32, 0x84, 0xe9, 0xa6, 0x3a, 0xda, 0x79, 0x5d, 0x90, 0xe4, 0x2e,
	0x64, 0xdc, 0x24, 0x99, 0x25, 0x21, 0x23, 0x1c, 0x7b, 0x90, 0x45, 0xc4, 0xbc, 0x59, 0xc4, 0x10,
	0xa5, 0xe2, 0x43, 0x94, 0x92, 0xff, 0x52, 0x82, 0x82, 0x3b, 0x13, 0xae, 0x68, 0x8f, 0x23, 0x16,
	0x61, 0x9a, 0x3a, 0xe2, 0x99, 0xe0, 0xb8, 0xc7, 0x9b, 0xe5, 0xe0, 0xd4, 0x78, 0xb5, 0x56, 0xa8,
	0xef, 0xba, 0x04, 0xf2, 0x6a, 0x3c, 0xd5, 0xeb, 0x97, 0x09, 0x9f, 0x5f, 0xca, 0xff, 0x25, 0xc1,
	0x52, 0xe4, 0x08, 0xc6, 0xf6, 0xa9, 0x03, 0x48, 0xd9, 0xf8, 0x44, 0x38, 0x12, 0x1d, 0xe6, 0x2f,
	0x86, 0xd0, 0xc3, 0xe5, 0x6c, 0x28, 0xf8, 0xa4, 0xd8, 0x71, 0xf8, 0xb6, 0x97, 0xb4, 0xd9, 0x8f,
	0xc2, 0x37, 0x61, 0xca, 0x43, 0x8e, 0xd8, 0x5b, 0xde, 0xf2, 0xef, 0x2d, 0x77, 0xae, 0x22, 0xd0,
	0xb3, 0xc1, 0xfc, 0x4c, 0x1a, 0xac, 0x23, 0x0f, 0x64, 0xc8, 0xea, 0x90, 0xae, 0xb4, 0x3a, 0x62,
	0x23, 0x57, 0x47, 0x7c, 0xf8, 0xea, 0x48, 0x7c, 0xde, 0xab, 0x63, 0x9d, 0x05, 0xea, 0xbd, 0x03,
	0xea, 0x64, 0x7b, 0x06, 0x71, 0x3c, 0x87, 0x7d, 0xcf, 0x81, 0x97, 0x7d, 0xcb, 0x9f, 0x24, 0x20,
	0xc9, 0x91, 0xe3, 0x65, 0xf2, 0x9b, 0xfe, 0x4c, 0xfe, 0xd2, 0xa3, 0x09, 0x5a, 0x86, 0x74, 0xdb,
	0x3d, 0x3a, 0x33, 0xeb, 0x48, 0xca, 0x80, 0x40, 0x8f, 0x5d, 0xfd, 0x1f, 0xea, 0x20, 0xd6, 0x66,
	0xfa, 0x44, 0x3a, 0x01, 0x5f, 0x80, 0xf9, 0x63, 0x8d, 0xa8, 0x6e, 0x72, 0x44, 0x30, 0x21, 0x86,
	0x65, 0x12, 0x66, 0xab, 0x49, 0x05, 0x1d, 0x6b, 0x64, 0x97, 0xb3, 0xea, 0x82, 0x83, 0xee, 0x42,
	0xb6, 0xdd, 0xa5, 0x46, 0x57, 0xb1, 0x66, 0x9b, 0x86, 0xd9, 0x62, 0xe6, 0x92, 0x94, 0x4c, 0xbb,
	0xbb, 0x8b, 0x71, 0x99, 0xd3, 0xd0, 0x1b, 0xb0, 0x10, 0x48, 0xb8, 0x5c, 0x74, 0x8a, 0xa1, 0xe7,
	0x7d, 0xa9, 0x96, 0xdb, 0xea, 0x26, 0xc0, 0xa9, 0xd5, 0xee, 0x75, 0xb0, 0xba, 0xf5, 0xc6, 0x31,
	0x4b, 0x87, 0x25, 0x25, 0xcd, 0x29, 0x5b, 0x6f, 0x1c, 0xa3, 0xd7, 0x60, 0xc6, 0xb1, 0x1c, 0xad,
	0xad, 0x0e, 0x46, 0x9d, 0x66, 0x98, 0x2c, 0x23, 0xf7, 0xcb, 0x08, 0x68, 0x03, 0xe6, 0x02, 0x40,
	0x66, 0x00, 0x9e, 0x0d, 0xcf, 0xfa, 0xc1, 0xc2, 0x67, 0xfd, 0x63, 0x52, 0xb5, 0xee, 0x45, 0x7e,
	0x8a, 0xf5, 0x3d, 0xe3, 0x1d, 0x57, 0xb1, 0x7b, 0x41, 0x7d, 0xd6, 0x1d, 0x1a, 0x45, 0x65, 0x18,
	0x0a, 0x04, 0x89, 0x02, 0x6a, 0x83, 0xb1, 0x0b, 0x7b, 0xf2, 0x85, 0x40, 0xf2, 0xd3, 0x97, 0x9d,
	0x39, 0x5d, 0xb3, 0x08, 0x6b, 0x33, 0x06, 0x91, 0x6d, 0xb8, 0x1e, 0x70, 0xbe, 0xb1, 0xe3, 0xcb,
	0x26, 0xa4, 0xda, 0x5d, 0x37, 0x47, 0x88, 0x47, 0xa1, 0x79, 0xf7, 0x4a, 0xb2, 0xdd, 0x65, 0xd9,
	0xc1, 0xdf, 0x4a, 0x90, 0x77, 0x97, 0x75, 0xdf, 0x56, 0xae, 0xd7, 0xdf, 0x86, 0x8c, 0x1b, 0x96,
	0x55, 0x1b, 0x9f, 0x30, 0x05, 0x32, 0xca, 0x94, 0x4b, 0x53, 0xf0, 0x09, 0x8d, 0x37, 0xc4, 0x68,
	0x31, 0x57, 0xce, 0x28, 0xf4, 0x93, 0xba, 0x04, 0x16, 0xf1, 0x82, 0x1e, 0x98, 0x9a, 0xd8, 0x38,
	0xc5, 0x3a, 0x9b, 0x17, 0xbe, 0xb0, 0xe7, 0xfb, 0x5c, 0x45, 0x30, 0xe9, 0xd4, 0x94, 0x60, 0xaa,
	0x83, 0x9d, 0x63, 0x4b, 0x57, 0x9d, 0x8b, 0x2e, 0x5f, 0xe8, 0xd9, 0x2d, 0x79, 0xd8, 0x1e, 0xb0,
	0xcf, 0xa0, 0x8d, 0x8b, 0x2e, 0x56, 0xa0, 0xd3, 0xff, 0x96, 0xbf, 0x09, 0x8b, 0x11, 0x63, 0x19,
	0xdb, 0x88, 0x37, 0x20, 0x45, 0xf0, 0x89, 0x6a, 0xf6, 0x3a, 0xa2, 0x90, 0x95, 0x24, 0xf8, 0xa4,
	0xda, 0xeb, 0xc8, 0x5f, 0x80, 0xc2, 0xa1, 0x49, 0x0f, 0x58, 0xbb, 0x5e, 0xaf, 0x1e, 0x15, 0x23,
	0x9e, 0xc0, 0x52, 0x64, 0x8b, 0x71, 0x75, 0x92, 0xdf, 0x80, 0x95, 0x27, 0xd8, 0xf1, 0xf5, 0xb2,
	0x83, 0x1d, 0xcd, 0x68, 0x93, 0x51, 0xe2, 0x7f, 0x53, 0x82, 0x5b, 0x43, 0x9b, 0x8d, 0x6d, 0x97,
	0x77, 0x20, 0xa5, 0xf3, 0xc6, 0xc2, 0xb9, 0xf8, 0xfc, 0xb8, 0xa5, 0xd7, 0xd3, 0xc7, 0x1b, 0xe2,
	0x44, 0xd5, 0xd6, 0x8c, 0x8e, 0x2b, 0xc6, 0x6d, 0x22, 0xff, 0x89, 0x04, 0x4b, 0xd1, 0x65, 0x40,
	0xae, 0xbf, 0xc7, 0xea, 0x92, 0xd7, 0xea, 0x94, 0xe1, 0x9c, 0xab, 0xc7, 0x1a, 0x39, 0x76, 0xf3,
	0x10, 0xe7, 0xfc, 0xa9, 0x46, 0x8e, 0x29, 0xa3, 0xdd, 0xe5, 0x1b, 0xb6, 0x28, 0x73, 0xb4, 0xbb,
	0x2c, 0x8f, 0xf4, 0xe6, 0x34, 0x09, 0x7f, 0x4e, 0xb3, 0x0e, 0x09, 0xe6, 0x60, 0x13, 0xcc, 0xc1,
	0x22, 0x56, 0x07, 0x73, 0x2a, 0x86, 0x91, 0xff, 0x28, 0x0e, 0x33, 0x81, 0x5a, 0xc4, 0xa5, 0x55,
	0x12, 0xf4, 0x2e, 0x4f, 0x67, 0x08, 0x36, 0x75, 0x6f, 0xae, 0x1e, 0x4a, 0x67, 0xbc, 0x95, 0x20,
	0x65, 0x8a, 0xd8, 0xcd, 0x3a, 0x36, 0x75, 0xb6, 0x99, 0x3c, 0xe5, 0x27, 0xfc, 0xfe, 0xd2, 0x61,
	0xbd, 0xc4, 0xaf, 0xd0, 0xcb, 0x8c, 0x4e, 0x63, 0x06, 0x6f, 0xc5, 0x7a, 0xca, 0x42, 0xcc, 0x21,
	0xcc, 0x02, 0x09, 0x25, 0xe6, 0x90, 0xe8, 0x32, 0xc3, 0xc4, 0xd5, 0xcb, 0x0c, 0xc9, 0xa8, 0x32,
	0x83, 0xa7, 0x9e, 0x93, 0x7a, 0x99, 0x7a, 0x4e, 0xa8, 0xba, 0x32, 0x39, 0x5e, 0x75, 0x45, 0xfe,
	0x9d, 0x38, 0xa4, 0xf7, 0x0e, 0xdc, 0x09, 0xfa, 0x7c, 0xb7, 0xe2, 0x21, 0x85, 0xb5, 0x90, 0xa5,
	0x43, 0xe5, 0xdf, 0x89, 0x70, 0xf9, 0x77, 0x50, 0xcc, 0x4e, 0x8e, 0x55, 0xcc, 0x76, 0x5d, 0x38,
	0x75, 0xb9, 0x0b, 0x7b, 0x17, 0xd5, 0xa4, 0x6f, 0x51, 0x05, 0xe2, 0x6d, 0xfa, 0x65, 0xe2, 0x2d,
	0x9a, 0x87, 0x09, 0xd3, 0xa2, 0x29, 0x17, 0xf0, 0x7a, 0x3f, 0xfb, 0x21, 0x9f, 0xc0, 0x42, 0x60,
	0xc6, 0xdd, 0x25, 0x7e, 0x1f, 0x66, 0x4c, 0x7c, 0xee, 0xa8, 0x22, 0x61, 0x73, 0x0b, 0xac, 0x69,
	0x65, 0x9a, 0x92, 0x0f, 0x58, 0xb2, 0x46, 0xad, 0xbc, 0x04, 0x69, 0x06, 0x21, 0xc6, 0x87, 0xee,
	0x5d, 0xc2, 0x24, 0x25, 0xd4, 0x8d, 0x0f, 0x71, 0x3f, 0xce, 0xc5, 0x3d, 0x71, 0xee, 0x6f, 0x24,
	0xb8, 0x11, 0x92, 0x39, 0x76, 0x7c, 0x7b, 0x0b, 0x52, 0xc7, 0xbc, 0xb1, 0x88, 0x6f, 0xb7, 0x86,
	0x2d, 0x37, 0x57, 0x86, 0x8b, 0x8f, 0x1a, 0x59, 0x3c, 0x6a, 0x64, 0xb7, 0x21, 0xd3, 0xec, 0xd9,
	0x36, 0x36, 0x1d, 0x3e, 0x38, 0xee, 0x31, 0x53, 0x82, 0x46, 0xc7, 0x27, 0xbf, 0x80, 0x5c, 0xdf,
	0x9b, 0x3f, 0x77, 0xc3, 0xfd, 0x85, 0x04, 0xb3, 0x1e, 0x69, 0x63, 0x9b, 0xec, 0x8b, 0x41, 0x93,
	0x2d, 0x86, 0xdd, 0xf1, 0xf3, 0x34, 0xd6, 0x3a, 0xcc, 0xf3, 0x3d, 0xc7, 0x30, 0x5b, 0x3b, 0x9a,
	0xa3, 0x8d, 0xde, 0x8b, 0x93, 0x1c, 0xeb, 0x16, 0x25, 0x24, 0x96, 0xd2, 0xb1, 0xa2, 0xc4, 0x38,
	0xd5, 0x75, 0xf9, 0x37, 0xe2, 0x70, 0x3d, 0x20, 0xf5, 0x25, 0x0e, 0x82, 0xe9, 0x1e, 0xd1, 0xd5,
	0xae, 0x6d, 0x34, 0xb1, 0x30, 0xdd, 0x17, 0x83, 0xf8, 0x48, 0x19, 0x1b, 0x87, 0x44, 0x3f, 0xa0,
	0xad, 0xf8, 0x31, 0x70, 0xb2, 0x27, 0x7e, 0xa2, 0x6f, 0xc0, 0x4d, 0x6e, 0x60, 0xa3, 0xa9, 0xb5,
	0xd5, 0x66, 0xaf, 0xd3, 0x6b, 0x6b, 0x8e, 0x71, 0x8a, 0x45, 0x62, 0x4e, 0x44, 0xa9, 0x75, 0x21,
	0x5a, 0x8a, 0xb2, 0x34, 0x68, 0x5c, 0xea, 0xb7, 0xe5, 0x3c, 0x82, 0xde, 0x87, 0xa5, 0x1e, 0x4b,
	0x63, 0xb0, 0x1e, 0xd5, 0x73, 0x62, 0x64, 0xcf, 0x8b, 0x6e, 0xd3, 0x50, 0xbf, 0x85, 0x2f, 0xc3,
	0xb4, 0x6f, 0x38, 0xde, 0xe3, 0x6b, 0x9a, 0x1f, 0x5f, 0xe7, 0xbd, 0xc7, 0x57, 0xc9, 0x7b, 0x32,
	0xfd, 0xae, 0x04, 0xe8, 0xb0, 0xab, 0x6b, 0x0e, 0xe6, 0x31, 0x5d, 0x4c, 0xfd, 0x58, 0x1b, 0x80,
	0x0c, 0xd3, 0xce, 0xb9, 0xda, 0xb3, 0xdb, 0x6a, 0xd7, 0xc6, 0xcf, 0x8d, 0xf3, 0x7e, 0xf1, 0xee,
	0xfc, 0xd0, 0x6e, 0x1f, 0x30, 0x92, 0x9b, 0xe2, 0xc6, 0x07, 0x29, 0xae, 0xeb, 0x5d, 0x09, 0x8f,
	0x77, 0x7d, 0x24, 0xc1, 0x9c, 0x4f, 0x9b, 0x97, 0xa8, 0x37, 0x09, 0xc5, 0x63, 0x2f, 0xa3, 0x78,
	0x3c, 0xa4, 0xb8, 0xfc, 0x67, 0x7d, 0x03, 0x71, 0xf7, 0x7d, 0x15, 0xa5, 0x4c, 0x7a, 0x76, 0xe3,
	0x10, 0x76, 0xe7, 0xc5, 0xa5, 0xf2, 0x6a, 0x63, 0x55, 0xeb, 0xe0, 0x01, 0x9b, 0x5d, 0x7f, 0x25,
	0x3c, 0xec, 0x4a, 0xd3, 0x32, 0x5d, 0x5b, 0x4e, 0x84, 0x6d, 0x99, 0xf4, 0xd8, 0xb2, 0xeb, 0x9a,
	0x52, 0xe8, 0xfd, 0x12, 0xc7, 0xa0, 0xf1, 0xf6, 0x75, 0x79, 0x01, 0xe6, 0xeb, 0x8e, 0xf6, 0xc2,
	0x30, 0x5b, 0xa2, 0x92, 0x2f, 0x6e, 0x49, 0x3e, 0x96, 0xe0, 0x7a, 0x80, 0x21, 0x94, 0x79, 0x0d,
	0x66, 0x4e, 0x0d, 0x7c, 0x86, 0xed, 0x7e, 0x75, 0x59, 0x78, 0x6d, 0x96, 0x93, 0xdd, 0xa2, 0x32,
	0x7a, 0x00, 0x39, 0xc2, 0x7b, 0x18, 0x20, 0x45, 0x11, 0x91, 0xf4, 0x7b, 0xe6, 0xd0, 0x37, 0xe1,
	0x86, 0x0b, 0x0d, 0x5c, 0x5f, 0x08, 0x43, 0x5f, 0x17, 0x6c, 0xff, 0xcd, 0x05, 0xbb, 0x79, 0xc5,
	0x6d, 0x8f, 0x26, 0xa2, 0x04, 0x40, 0x89, 0x2e, 0x48, 0xae, 0xb8, 0x87, 0x97, 0xba, 0xb7, 0x8f,
	0xc1, 0xaa, 0x99, 0xd5, 0x71, 0x1b, 0xb7, 0x34, 0xc7, 0xe2, 0x35, 0x30, 0x4c, 0x88, 0x18, 0x50,
	0xae, 0xcf, 0x28, 0x72, 0xfa, 0xe0, 0x54, 0x13, 0xe8, 0x6a, 0xec, 0x53, 0xcd, 0x3e, 0x3b, 0xd5,
	0xf8, 0x7a, 0x09, 0x9c, 0x6a, 0xc6, 0xd2, 0xeb, 0x23, 0x7e, 0xdc, 0x89, 0xee, 0x6f, 0x6c, 0x27,
	0x2a, 0x41, 0x92, 0x9f, 0x5d, 0x84, 0x17, 0x3d, 0x64, 0x60, 0xdf, 0x2b, 0x92, 0xd3, 0xc7, 0x1b,
	0x3e, 0x61, 0xec, 0xe4, 0xc3, 0xcf, 0xd7, 0xbc, 0xa9, 0x6c, 0xc2, 0xeb, 0xac, 0xf2, 0xef, 0x2d,
	0x45, 0x1c, 0xd8, 0xd6, 0xa9, 0xa1, 0x63, 0x9b, 0x79, 0xe1, 0xb6, 0xd6, 0xd6, 0xcc, 0x26, 0x76,
	0xc7, 0xbb, 0x04, 0x69, 0x77, 0x71, 0xf2, 0x4a, 0xe8, 0xb4, 0x32, 0x29, 0x56, 0x27, 0xb9, 0xca,
	0x4d, 0xc3, 0xb7, 0x63, 0xf0, 0xe8, 0x8a, 0x02, 0xc7, 0x36, 0xc8, 0x31, 0xa4, 0xfb, 0xe5, 0x16,
	0xb1, 0x67, 0xbd, 0x17, 0x75, 0x71, 0x77, 0x65, 0xd9, 0x1b, 0x2e, 0x54, 0xec, 0x65, 0x6e, 0xc5,
	0x86, 0xee, 0x0b, 0x3e, 0x96, 0x77, 0x5f, 0x48, 0x44, 0xec, 0x0b, 0x69, 0xef, 0xbe, 0xf0, 0x07,
	0x12, 0x2c, 0x3c, 0xc1, 0x0e, 0x9d, 0x86, 0xed, 0x8b, 0x06, 0x3b, 0x2a, 0x5e, 0x21, 0xf4, 0x0d,
	0x3d, 0x65, 0xba, 0xe9, 0x76, 0x3c, 0x3a, 0xdd, 0x2e, 0xd5, 0x3d, 0xe9, 0xb6, 0x08, 0x6f, 0x89,
	0x70, 0x78, 0x9b, 0xf0, 0x84, 0xb7, 0x3f, 0x95, 0xe0, 0x46, 0x48, 0x41, 0x31, 0x1b, 0x6f, 0x41,
	0xda, 0xea, 0x62, 0x9b, 0xbd, 0xa0, 0x62, 0x2a, 0x66, 0xb7, 0x96, 0xc2, 0x22, 0x6b, 0x2e, 0x44,
	0x19, 0xa0, 0x87, 0x3c, 0x8e, 0xf1, 0xb4, 0x3b, 0x24, 0xd8, 0x2e, 0x69, 0x04, 0x07, 0xce, 0x13,
	0x08, 0x12, 0x1d, 0xdc, 0xb1, 0xdc, 0xbc, 0x90, 0x7e, 0xb3, 0xf7, 0x0b, 0xf4, 0xd8, 0x29, 0x76,
	0x38, 0xfa, 0x2d, 0xff, 0xbe, 0x04, 0x73, 0xbb, 0xc6, 0x79, 0xf9, 0x14, 0x9b, 0xce, 0xbe, 0x41,
	0xc8, 0xff, 0x2f, 0xa3, 0xbe, 0x0b, 0xf3, 0x7e, 0xe5, 0x5e, 0xb2, 0xc4, 0xa2, 0x60, 0x07, 0x9b,
	0xcc, 0xb4, 0x3c, 0x47, 0xf1, 0x5e, 0x02, 0x46, 0x65, 0x95, 0x3f, 0x88, 0xb3, 0x98, 0x13, 0xdd,
	0x6c, 0xec, 0x25, 0xb6, 0x08, 0x93, 0x98, 0x0e, 0xc1, 0xbd, 0xc5, 0x48, 0x28, 0x29, 0xf6, 0xbb,
	0xa2, 0xa3, 0xbb, 0x90, 0xe5, 0x2c, 0x6c, 0xea, 0xaa, 0x63, 0x88, 0xcd, 0x37, 0xa1, 0x64, 0x18,
	0xb5, 0x6c, 0xea, 0x0d, 0x83, 0xef, 0xbf, 0x1d, 0xed, 0x5c, 0x6c, 0x1f, 0xee, 0xfe, 0xdb, 0xd1,
	0xce, 0x45, 0xe6, 0xbb, 0x01, 0x73, 0x94, 0xdd, 0x2f, 0x61, 0xf0, 0xa2, 0x2b, 0x33, 0xa4, 0xa4,
	0xcc, 0x76, 0xb4, 0x73, 0xf7, 0x84, 0xf3, 0x3e, 0x63, 0xa0, 0x7b, 0x90, 0x75, 0x53, 0x70, 0xd1,
	0x25, 0xdf, 0xa7, 0xa7, 0x05, 0x55, 0x74, 0x7b, 0x17, 0xb2, 0x6c, 0x03, 0x1a, 0xa4, 0xb4, 0xbc,
	0xfc, 0xcb, 0x76, 0x20, 0x37, 0xc3, 0xa3, 0xba, 0x35, 0x69, 0x80, 0xe4, 0xda, 0xf3, 0xf3, 0x68,
	0x9a, 0x51, 0x98, 0xea, 0x07, 0x90, 0x26, 0x46, 0xcb, 0xd4, 0x9c, 0x9e, 0xcd, 0x0f, 0xa4, 0x53,
	0x5b, 0x79, 0x9e, 0x87, 0xf3, 0x87, 0x7f, 0x34, 0xd8, 0xba, 0xfc, 0xed, 0xfc, 0xc7, 0x3f, 0xbd,
	0x75, 0xed, 0x3f, 0x7f, 0x7a, 0x2b, 0x77, 0xa1, 0x75, 0xda, 0x6f, 0xcb, 0xfd, 0x86, 0xb2, 0x32,
	0xe8, 0x44, 0xde, 0x82, 0x65, 0x16, 0x91, 0x83, 0x93, 0x33, 0x6a, 0x3e, 0xff, 0x49, 0x82, 0x9b,
	0x43, 0x1a, 0xbd, 0xca, 0xd9, 0x0c, 0x1b, 0x36, 0x1e, 0x65, 0x58, 0x9f, 0x4d, 0x12, 0xaf, 0xc2,
	0x26, 0x8f, 0x58, 0xec, 0xd9, 0xc5, 0x58, 0xc1, 0x47, 0x9a, 0x83, 0x2f, 0x73, 0xef, 0x7f, 0x8c,
	0xb1, 0x27, 0x43, 0x01, 0xfc, 0xff, 0xbe, 0x5f, 0xdf, 0x83, 0xac, 0xcd, 0x14, 0x50, 0xbb, 0x96,
	0xcd, 0x82, 0x63, 0x82, 0x79, 0xd8, 0x34, 0xa7, 0x1e, 0x70, 0x22, 0x5a, 0x80, 0xa4, 0x30, 0x27,
	0x8f, 0x0d, 0xe2, 0x57, 0x84, 0x83, 0x26, 0x2f, 0x75, 0xd0, 0xd4, 0x48, 0x07, 0x9d, 0x7c, 0x15,
	0x93, 0xf1, 0x10, 0xae, 0x33, 0x5f, 0xeb, 0x9b, 0x77, 0xd4, 0x54, 0xfc, 0xb5, 0x04, 0x0b, 0x41,
	0xf4, 0xab, 0x9c, 0x88, 0x81, 0xed, 0xe2, 0x3e, 0xdb, 0xbd, 0x7a, 0x1f, 0x7c, 0x0f, 0x6e, 0x29,
	0x98, 0xce, 0x63, 0x89, 0x3b, 0x3b, 0xab, 0x26, 0x56, 0x7b, 0x9d, 0x23, 0x6c, 0xbb, 0x06, 0x60,
	0xca, 0x50, 0x88, 0xb8, 0x74, 0x10, 0xbf, 0xc2, 0xf7, 0x0d, 0xf2, 0x27, 0x12, 0xe4, 0xa3, 0xfa,
	0x61, 0xf0, 0x65, 0x48, 0xd3, 0xb9, 0x24, 0x8e, 0xd6, 0xe9, 0x8a, 0xec, 0x61, 0x40, 0x40, 0xef,
	0x03, 0x7f, 0x84, 0xa5, 0x9a, 0xbd, 0x0e, 0x19, 0x76, 0x21, 0x3b, 0xac, 0xef, 0x0d, 0x97, 0x42,
	0x78, 0xf6, 0x92, 0x3e, 0x72, 0x7f, 0x17, 0xde, 0x81, 0xac, 0x9f, 0x79, 0x59, 0xfe, 0x92, 0xf0,
	0xe6, 0x2f, 0x7b, 0xb0, 0x3a, 0xdc, 0x3a, 0x63, 0xef, 0x6a, 0x4f, 0x20, 0xc9, 0x7f, 0xa2, 0x87,
	0x90, 0x68, 0x5a, 0x3a, 0x16, 0x59, 0xc5, 0x8d, 0x88, 0x46, 0x25, 0x4b, 0xc7, 0x0a, 0x03, 0x51,
	0x85, 0x3b, 0xa4, 0x25, 0x76, 0x6d, 0xfa, 0xb9, 0xbe, 0x0d, 0x49, 0x5e, 0x5a, 0x44, 0x73, 0x30,
	0xb3, 0x77, 0xa0, 0x36, 0x3e, 0x38, 0x28, 0xab, 0x87, 0xd5, 0xf7, 0xaa, 0xb5, 0x67, 0xd5, 0xdc,
	0x35, 0x34, 0x03, 0x53, 0x2e, 0xb1, 0xb8, 0xb3, 0x93, 0x93, 0x10, 0x82, 0xac, 0x4b, 0x50, 0xca,
	0xfb, 0xb5, 0xf7, 0xcb, 0xb9, 0xd8, 0xfa, 0xbb, 0x90, 0xe4, 0x5b, 0x3b, 0xca, 0x02, 0x94, 0x1a,
	0x9e, 0xe6, 0x69, 0x98, 0x28, 0x35, 0xd4, 0xc6, 0xd7, 0x73, 0x12, 0x9a, 0x86, 0x74, 0xa9, 0xa1,
	0xee, 0x1d, 0xb0, 0x7e, 0x62, 0x28, 0x03, 0x93, 0xfc, 0xa7, 0xb2, 0x9f, 0x8b, 0xaf, 0xff, 0x58,
	0x82, 0x29, 0x4f, 0xfe, 0xc3, 0xfa, 0x29, 0x7a, 0xfa, 0xa1, 0x8d, 0x8b, 0x6a, 0xb5, 0xa6, 0xec,
	0x17, 0xf7, 0x72, 0x92, 0x60, 0x3f, 0x2b, 0x56, 0x1a, 0x95, 0xea, 0x93, 0x5c, 0x4c, 0xb0, 0x95,
	0xf2, 0x41, 0x4d, 0x69, 0xe4, 0xe2, 0x68, 0x01, 0x10, 0x6d, 0x5d, 0xa7, 0x2a, 0xd6, 0x3f, 0xa8,
	0x96, 0xd4, 0x46, 0xad, 0xb6, 0x97, 0x4b, 0xf8, 0xe9, 0x95, 0x27, 0x55, 0x4e, 0x9f, 0x40, 0x79,
	0x98, 0x1f, 0xd0, 0x0f, 0xf7, 0xb7, 0x2b, 0x0d, 0xce, 0x49, 0xa2, 0x1b, 0x30, 0x57, 0x2a, 0xaa,
	0xfb, 0x35, 0xa5, 0xac, 0x56, 0xaa, 0xbb, 0x35, 0xb5, 0x5a, 0x2e, 0xef, 0x94, 0x77, 0x72, 0xa9,
	0xf5, 0x1f, 0xc4, 0x21, 0xeb, 0x4f, 0xbc, 0x98, 0x52, 0x25, 0x8f, 0xce, 0x05, 0x58, 0x28, 0x95,
	0xd4, 0x86, 0x52, 0xac, 0xd6, 0x77, 0xcb, 0x8a, 0x5a, 0xad, 0xa9, 0x4f, 0x2b, 0xf5, 0x46, 0x4d,
	0xf9, 0x20, 0x27, 0x05, 0x79, 0xf5, 0xc3, 0xed, 0xfd, 0x4a, 0x43, 0x0c, 0xe6, 0x75, 0x58, 0xf3,
	0xf2, 0xc4, 0x28, 0xd5, 0xdd, 0x9a, 0xa2, 0xd6, 0x9f, 0x54, 0xd5, 0x52, 0xad, 0xba, 0x5b, 0x51,
	0xf6, 0x8b, 0x8d, 0x4a, 0xad, 0x9a, 0x8b, 0xa3, 0x35, 0xb8, 0x3b, 0x0c, 0xbd, 0x7b, 0x58, 0xdd,
	0x51, 0x95, 0xf2, 0x5e, 0xb9, 0x58, 0x2f, 0xe7, 0x12, 0xe8, 0x36, 0xdc, 0xf4, 0x22, 0x95, 0xf2,
	0xd7, 0x0e, 0xcb, 0x75, 0x06, 0x56, 0xca, 0x14, 0x9a, 0x9b, 0x40, 0xf7, 0x41, 0xf6, 0x42, 0x84,
	0x28, 0x0a, 0xf9, 0xa0, 0x76, 0xa8, 0xb8, 0xb8, 0x24, 0xba, 0x0e, 0xb3, 0xa5, 0x12, 0x9d, 0x48,
	0xef, 0xa8, 0x52, 0x1e, 0xb2, 0x67, 0x40, 0x93, 0x62, 0xb0, 0x94, 0x1c, 0x18, 0x4b, 0x2e, 0x2d,
	0x9a, 0x78, 0xe9, 0x7b, 0x07, 0x39, 0x10, 0x4d, 0x9e, 0x55, 0x1a, 0x4f, 0x77, 0x94, 0xe2, 0x33,
	0x6f, 0x77, 0x53, 0xe8, 0x16, 0x2c, 0x79, 0x79, 0xc1, 0x3e, 0x33, 0xeb, 0xbf, 0x2b, 0x01, 0x0a,
	0x97, 0xb8, 0xd1, 0x32, 0xe4, 0x9f, 0xed, 0xa8, 0xfb, 0xe5, 0xc6, 0xd3, 0xda, 0x8e, 0xeb, 0xe6,
	0x3b, 0xe5, 0xdd, 0x4a, 0xb5, 0xbc, 0x93, 0xbb, 0x86, 0x16, 0xe1, 0x7a, 0x80, 0x5b, 0xab, 0x96,
	0xa9, 0x73, 0x4a, 0xe8, 0x26, 0x2c, 0x06, 0x58, 0xc5, 0xbd, 0x3d, 0xb5, 0x52, 0xa5, 0x88, 0x5c,
	0x0c, 0xad, 0xc2, 0x72, 0x80, 0x5d, 0x6f, 0x14, 0xdf, 0xa3, 0x2a, 0x95, 0xf6, 0x8a, 0x15, 0xea,
	0xdd, 0x9f, 0x48, 0x90, 0x12, 0xeb, 0x90, 0xfa, 0x5a, 0x59, 0x51, 0x6a, 0xd4, 0xb8, 0x3b, 0x7e,
	0x0d, 0x16, 0x60, 0xd6, 0xc3, 0x29, 0xd5, 0xf6, 0xf7, 0x6b, 0xd5, 0xdc, 0xcf, 0xe3, 0x68, 0x15,
	0x96, 0x38, 0xbd, 0x5a, 0x53, 0x1b, 0xb5, 0xf7, 0xca, 0x54, 0xae, 0xba, 0x53, 0x6f, 0xa8, 0xa5,
	0xa7, 0xc5, 0x4a, 0x35, 0xf7, 0x6f, 0xa9, 0x68, 0x44, 0x5d, 0x29, 0x09, 0xc4, 0xbf, 0xa7, 0xd0,
	0x2d, 0x28, 0x70, 0x44, 0xa5, 0x5a, 0x69, 0x0c, 0x6c, 0xb7, 0x5b, 0xac, 0xec, 0x95, 0x77, 0x72,
	0x3f, 0x4b, 0xa1, 0xd7, 0xe1, 0x35, 0x8f, 0xf0, 0x6a, 0x4d, 0x2d, 0x57, 0x6b, 0x87, 0x4f, 0x9e,
	0x46, 0x09, 0xfc, 0x8f, 0xd4, 0xd6, 0xbf, 0xde, 0x84, 0xf8, 0x33, 0x7c, 0x84, 0xbe, 0x2b, 0x01,
	0x0a, 0xbf, 0xe9, 0x44, 0x0f, 0xae, 0xf2, 0xee, 0x93, 0x6d, 0x08, 0x85, 0xf5, 0xab, 0x3f, 0x11,
	0x95, 0x57, 0xbe, 0xf3, 0x77, 0xff, 0xf2, 0xfd, 0x58, 0x1e, 0x2d, 0xb0, 0xbf, 0x68, 0x09, 0x8b,
	0x25, 0x90, 0xf1, 0x3e, 0xc7, 0x43, 0x77, 0x22, 0x4f, 0xb1, 0xfe, 0x17, 0x80, 0x85, 0xbb, 0xa3,
	0x41, 0x42, 0x74, 0x9e, 0x89, 0x46, 0x28, 0xe7, 0x8a, 0xee, 0x0b, 0xb1, 0x60, 0xca, 0xf3, 0x1e,
	0x0d, 0xc9, 0xc3, 0xde, 0xe1, 0x0c, 0x9e, 0x46, 0x15, 0xee, 0x8c, 0xc4, 0x08, 0x89, 0x37, 0x98,
	0xc4, 0x59, 0x34, 0x43, 0x25, 0x62, 0x8f, 0x84, 0xdf, 0x92, 0x60, 0x36, 0xf4, 0x5e, 0x1b, 0xad,
	0x8d, 0xb0, 0xa3, 0xef, 0x42, 0xb6, 0xf0, 0xe0, 0x0a, 0x48, 0xa1, 0xc3, 0x2a, 0xd3, 0xa1, 0x20,
	0x5f, 0x0f, 0x18, 0x9c, 0xc3, 0xde, 0x96, 0xd6, 0xd1, 0x19, 0x4c, 0xfb, 0xde, 0x36, 0xa0, 0x28,
	0x73, 0x86, 0xde, 0xdd, 0x14, 0xee, 0x5d, 0x82, 0x12, 0xf2, 0x17, 0x99, 0xfc, 0x39, 0x34, 0x2b,
	0xe4, 0x7b, 0xe4, 0x50, 0x2b, 0x84, 0x1e, 0x05, 0x84, 0xad, 0x30, 0xec, 0x0d, 0x44, 0xd8, 0x0a,
	0x43, 0x5f, 0x18, 0xf8, 0xad, 0x70, 0x16, 0x84, 0x51, 0x2b, 0x7c, 0x6f, 0xc8, 0x63, 0xaa, 0xf5,
	0x2b, 0xbd, 0x02, 0xe3, 0x0a, 0x3d, 0x1c, 0xe3, 0xc5, 0x98, 0x2c, 0x33, 0x95, 0x96, 0xe5, 0x1b,
	0x5e, 0xe7, 0xf0, 0x00, 0xa9, 0x52, 0xdf, 0x97, 0x60, 0x3e, 0xea, 0x62, 0x1e, 0x85, 0x24, 0x8d,
	0xb8, 0xbe, 0x2f, 0xbc, 0x7e, 0x35, 0xb0, 0xdf, 0x54, 0x28, 0xdf, 0xff, 0x8b, 0xb0, 0xa0, 0x70,
	0x6a, 0xaa, 0x88, 0xa7, 0x13, 0x61, 0x53, 0x0d, 0x7f, 0x91, 0x11, 0x36, 0xd5, 0x88, 0xb7, 0x18,
	0x7e, 0x53, 0xf5, 0xc2, 0x40, 0x6a, 0xaa, 0x3f, 0xe4, 0x95, 0x9b, 0xa8, 0xf7, 0x14, 0x68, 0x23,
	0xc2, 0x55, 0x47, 0xbc, 0xd7, 0x28, 0x6c, 0x5e, 0x19, 0x2f, 0x14, 0xbc, 0xc3, 0x14, 0xbc, 0x89,
	0x96, 0x84, 0x93, 0x47, 0x6a, 0xf1, 0xad, 0xf0, 0x93, 0x85, 0xfb, 0x97, 0xdd, 0x62, 0x0a, 0x85,
	0x5e, 0xbb, 0x14, 0x27, 0x14, 0x59, 0x62, 0x8a, 0x5c, 0x47, 0x73, 0x54, 0x11, 0x27, 0x20, 0xad,
	0xe5, 0xbd, 0x8c, 0x5f, 0x1d, 0x7e, 0x1b, 0x28, 0x84, 0xde, 0x1e, 0x81, 0x10, 0xe2, 0xae, 0x33,
	0x71, 0x33, 0x68, 0x9a, 0x8a, 0x6b, 0x77, 0xdd, 0xbe, 0xcf, 0x60, 0xda, 0x77, 0x41, 0x16, 0x8e,
	0x28, 0x51, 0x37, 0x83, 0xe1, 0x88, 0x12, 0x79, 0xcb, 0xe6, 0x8f, 0x28, 0xb6, 0x4f, 0xce, 0xb7,
	0x60, 0xda, 0x77, 0x25, 0x10, 0x16, 0x1c, 0x75, 0x95, 0x10, 0x16, 0x1c, 0x79, 0xaf, 0x20, 0xdf,
	0x66, 0x82, 0x97, 0xd0, 0x22, 0x15, 0x2c, 0xca, 0xfd, 0x9b, 0xc4, 0x27, 0xef, 0x87, 0xfd, 0xa5,
	0xe1, 0x2b, 0x3e, 0x0f, 0x5b, 0x1a, 0x51, 0xf5, 0xfe, 0x61, 0x4b, 0x23, 0xb2, 0xa0, 0x2f, 0xaf,
	0x33, 0x9d, 0xee, 0xca, 0xb7, 0xbc, 0x3a, 0xf5, 0xc2, 0x0d, 0xe8, 0x12, 0xf9, 0x63, 0xbe, 0x44,
	0xa2, 0x6a, 0xf0, 0x91, 0x4b, 0x64, 0x44, 0xf1, 0x3f, 0x72, 0x89, 0x8c, 0x2a, 0xee, 0xcb, 0x0f,
	0x99, 0xa2, 0xf7, 0xd0, 0x1d, 0xaf, 0xa2, 0xad, 0x21, 0xda, 0xfc, 0xbd, 0x04, 0xf7, 0xae, 0x54,
	0xae, 0x46, 0xef, 0xbc, 0x64, 0x95, 0x9b, 0x8f, 0xe2, 0x2b, 0xff, 0xa3, 0x1a, 0xb9, 0xfc, 0x98,
	0x8d, 0xe9, 0x21, 0x7a, 0xd0, 0xcf, 0x28, 0x2e, 0xd5, 0xf7, 0x02, 0xa6, 0x3c, 0x57, 0x91, 0xe1,
	0x54, 0x23, 0x7c, 0x6b, 0x1a, 0x4e, 0x35, 0x22, 0xee, 0x32, 0x5d, 0xdf, 0x94, 0x17, 0xf8, 0x9f,
	0xe3, 0x52, 0x67, 0xdc, 0xec, 0x0d, 0x70, 0x74, 0xfa, 0xfb, 0xa2, 0xf9, 0x15, 0xfe, 0x10, 0xd1,
	0xde, 0xfb, 0xc8, 0x61, 0xa2, 0x7d, 0x77, 0x7f, 0x23, 0x44, 0x33, 0x1c, 0x15, 0xfd, 0xdb, 0x3c,
	0xdf, 0xf1, 0xff, 0xf9, 0x6c, 0x64, 0xbe, 0x13, 0xf9, 0x07, 0xbd, 0x91, 0xf9, 0x4e, 0xf4, 0xdf,
	0xe2, 0xba, 0x7b, 0x05, 0x2a, 0x88, 0x39, 0x71, 0x61, 0x7b, 0x58, 0xd3, 0xb1, 0xbd, 0x6d, 0xd1,
	0xd5, 0xf8, 0x1d, 0x09, 0x66, 0x02, 0x55, 0xfe, 0x70, 0x28, 0x8e, 0xbe, 0xa7, 0x08, 0x87, 0xe2,
	0x21, 0xd7, 0x05, 0xfe, 0x4c, 0xb7, 0x49, 0xa8, 0x2e, 0x3e, 0x81, 0x17, 0x90, 0xf1, 0x56, 0xc5,
	0xc3, 0x99, 0x6e, 0x44, 0x41, 0x3f, 0x9c, 0xe9, 0x46, 0x15, 0xd6, 0x5d, 0xd1, 0xf2, 0x9c, 0x10,
	0xfd, 0xdc, 0x03, 0xa2, 0xd3, 0xf1, 0x23, 0x09, 0xf2, 0xc3, 0xea, 0x18, 0x68, 0x33, 0x1c, 0x85,
	0x47, 0xd6, 0x83, 0x0a, 0x5f, 0xb8, 0x7a, 0x03, 0xa1, 0xdf, 0x6b, 0x4c, 0xbf, 0xdb, 0xf2, 0x32,
	0x8f, 0xe0, 0xd1, 0x68, 0xcf, 0xa6, 0x1e, 0x55, 0xc1, 0x8f, 0x8c, 0x58, 0x23, 0x6e, 0x08, 0x22,
	0x23, 0xd6, 0xa8, 0xab, 0x81, 0xd0, 0xa6, 0x1e, 0xa9, 0xc5, 0x0f, 0x25, 0x51, 0x27, 0x0c, 0x72,
	0x51, 0x28, 0xeb, 0x1a, 0x55, 0xef, 0x2e, 0x3c, 0xba, 0x22, 0x5a, 0xe8, 0x76, 0x97, 0xe9, 0xb6,
	0x22, 0xb3, 0xad, 0xa8, 0x19, 0x05, 0xa5, 0xe6, 0xfb, 0x75, 0x09, 0x72, 0xc1, 0x0a, 0x31, 0x8a,
	0x72, 0xe0, 0xa8, 0x9a, 0x73, 0x61, 0xed, 0x72, 0xa0, 0xd0, 0x66, 0x99, 0x69, 0xb3, 0x80, 0xe6,
	0xdd, 0xf4, 0xc7, 0x27, 0xf0, 0xd7, 0x20, 0xeb, 0xaf, 0x8d, 0xa2, 0x7b, 0x91, 0x83, 0x0d, 0x56,
	0x5a, 0x0b, 0xf7, 0x2f, 0x83, 0x09, 0xf1, 0x37, 0x99, 0xf8, 0x1b, 0x32, 0xea, 0x1b, 0xa3, 0x8f,
	0x79, 0x5b, 0x5a, 0xdf, 0x7e, 0xfa, 0xf1, 0xa7, 0x2b, 0xd2, 0x4f, 0x3e, 0x5d, 0x91, 0xfe, 0xf9,
	0xd3, 0x15, 0xe9, 0xa3, 0xcf, 0x56, 0xae, 0xfd, 0xe4, 0xb3, 0x95, 0x6b, 0xff, 0xf0, 0xd9, 0xca,
	0xb5, 0x6f, 0x6c, 0xb4, 0x0c, 0xe7, 0xb8, 0x77, 0xb4, 0xd1, 0xb4, 0x3a, 0x9b, 0x4d, 0xdc, 0xc6,
	0xf6, 0x23, 0x13, 0x3b, 0x67, 0x96, 0xfd, 0x62, 0x93, 0xb4, 0xcc, 0x47, 0xa7, 0x5b, 0xfd, 0xff,
	0xbe, 0x70, 0x86, 0x8f, 0xb4, 0xae, 0x71, 0x94, 0x64, 0xff, 0x7a, 0xe0, 0x8b, 0xff, 0x1d, 0x00,
	0x00, 0xff, 0xff, 0xac, 0x23, 0x95, 0xbc, 0x9a, 0x41, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WebClient is the client API for Web service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WebClient interface {
	// get chain and token selector
	// after getting these info, remember to record them(especially decimal)
	GetTransferConfigs(ctx context.Context, in *GetTransferConfigsRequest, opts ...grpc.CallOption) (*GetTransferConfigsResponse, error)
	// get chain and token info
	GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoResponse, error)
	// estimate transfer fee
	EstimateAmt(ctx context.Context, in *EstimateAmtRequest, opts ...grpc.CallOption) (*EstimateAmtResponse, error)
	GetTransferStatus(ctx context.Context, in *GetTransferStatusRequest, opts ...grpc.CallOption) (*GetTransferStatusResponse, error)
	// LP
	//  get LP table info
	GetLPInfoList(ctx context.Context, in *GetLPInfoListRequest, opts ...grpc.CallOption) (*GetLPInfoListResponse, error)
	// https://github.com/celer-network/sgn-v2/blob/main/proto/sgn/cbridge/v1/tx.proto#L10
	//  remove liquidity or refund transfer calling this api
	WithdrawLiquidity(ctx context.Context, in *WithdrawLiquidityRequest, opts ...grpc.CallOption) (*WithdrawLiquidityResponse, error)
	// estimate transfer fee
	// front end need post method for this api
	EstimateWithdrawAmt(ctx context.Context, in *EstimateWithdrawAmtRequest, opts ...grpc.CallOption) (*EstimateWithdrawAmtResponse, error)
	// bcz it's time cost for sgn voting, so we need a polling api to check the status
	QueryLiquidityStatus(ctx context.Context, in *QueryLiquidityStatusRequest, opts ...grpc.CallOption) (*QueryLiquidityStatusResponse, error)
	// web will use this api to init reward claim
	UnlockFarmingReward(ctx context.Context, in *UnlockFarmingRewardRequest, opts ...grpc.CallOption) (*UnlockFarmingRewardResponse, error)
	// web polling this api after UnlockFarmingReward
	GetFarmingRewardDetails(ctx context.Context, in *GetFarmingRewardDetailsRequest, opts ...grpc.CallOption) (*GetFarmingRewardDetailsResponse, error)
	// History
	TransferHistory(ctx context.Context, in *TransferHistoryRequest, opts ...grpc.CallOption) (*TransferHistoryResponse, error)
	LPHistory(ctx context.Context, in *LPHistoryRequest, opts ...grpc.CallOption) (*LPHistoryResponse, error)
	RewardingData(ctx context.Context, in *RewardingDataRequest, opts ...grpc.CallOption) (*RewardingDataResponse, error)
	// staking api
	StakingConfig(ctx context.Context, in *StakingConfigRequest, opts ...grpc.CallOption) (*StakingConfigResponse, error)
	// web will use this api to init distribution reward claim
	UnlockStakingReward(ctx context.Context, in *UnlockStakingRewardRequest, opts ...grpc.CallOption) (*UnlockStakingRewardResponse, error)
	// web polling this api after UnlockStakingReward
	GetStakingRewardDetails(ctx context.Context, in *GetStakingRewardDetailsRequest, opts ...grpc.CallOption) (*GetStakingRewardDetailsResponse, error)
	// Safeguarding apis
	GetTotalLiquidityProviderTokenBalance(ctx context.Context, in *GetTotalLiquidityProviderTokenBalanceRequest, opts ...grpc.CallOption) (*GetTotalLiquidityProviderTokenBalanceResponse, error)
	// configs api, apis in these service need sign valid addr
	UpdateChain(ctx context.Context, in *UpdateChainRequest, opts ...grpc.CallOption) (*UpdateChainResponse, error)
	UpdateToken(ctx context.Context, in *UpdateTokenRequest, opts ...grpc.CallOption) (*UpdateTokenResponse, error)
	GetCampaignScores(ctx context.Context, in *GetCampaignScoresRequest, opts ...grpc.CallOption) (*GetCampaignScoresResponse, error)
	// cs tools
	GetInfoByTxHash(ctx context.Context, in *GetInfoByTxHashRequest, opts ...grpc.CallOption) (*GetInfoByTxHashResponse, error)
	// only CA_USE_RESYNC_TOOL and CA_USE_RESIGN_TOOL will be handled
	FixEventMiss(ctx context.Context, in *FixEventMissRequest, opts ...grpc.CallOption) (*FixEventMissResponse, error)
	ReportCurrentBlockNumber(ctx context.Context, in *ReportCurrentBlockNumberRequest, opts ...grpc.CallOption) (*ReportCurrentBlockNumberResponse, error)
	// incentive rewards
	GetRetentionRewardsInfo(ctx context.Context, in *GetRetentionRewardsInfoRequest, opts ...grpc.CallOption) (*GetRetentionRewardsInfoResponse, error)
	ClaimRetentionRewards(ctx context.Context, in *ClaimRetentionRewardsRequest, opts ...grpc.CallOption) (*ClaimRetentionRewardsResponse, error)
	GetFeeRebateInfo(ctx context.Context, in *GetFeeRebateInfoRequest, opts ...grpc.CallOption) (*GetFeeRebateInfoResponse, error)
	ClaimFeeRebate(ctx context.Context, in *ClaimFeeRebateRequest, opts ...grpc.CallOption) (*ClaimFeeRebateResponse, error)
}

type webClient struct {
	cc grpc1.ClientConn
}

func NewWebClient(cc grpc1.ClientConn) WebClient {
	return &webClient{cc}
}

func (c *webClient) GetTransferConfigs(ctx context.Context, in *GetTransferConfigsRequest, opts ...grpc.CallOption) (*GetTransferConfigsResponse, error) {
	out := new(GetTransferConfigsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTransferConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoResponse, error) {
	out := new(GetTokenInfoResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTokenInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) EstimateAmt(ctx context.Context, in *EstimateAmtRequest, opts ...grpc.CallOption) (*EstimateAmtResponse, error) {
	out := new(EstimateAmtResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/EstimateAmt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTransferStatus(ctx context.Context, in *GetTransferStatusRequest, opts ...grpc.CallOption) (*GetTransferStatusResponse, error) {
	out := new(GetTransferStatusResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTransferStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetLPInfoList(ctx context.Context, in *GetLPInfoListRequest, opts ...grpc.CallOption) (*GetLPInfoListResponse, error) {
	out := new(GetLPInfoListResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetLPInfoList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) WithdrawLiquidity(ctx context.Context, in *WithdrawLiquidityRequest, opts ...grpc.CallOption) (*WithdrawLiquidityResponse, error) {
	out := new(WithdrawLiquidityResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/WithdrawLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) EstimateWithdrawAmt(ctx context.Context, in *EstimateWithdrawAmtRequest, opts ...grpc.CallOption) (*EstimateWithdrawAmtResponse, error) {
	out := new(EstimateWithdrawAmtResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/EstimateWithdrawAmt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) QueryLiquidityStatus(ctx context.Context, in *QueryLiquidityStatusRequest, opts ...grpc.CallOption) (*QueryLiquidityStatusResponse, error) {
	out := new(QueryLiquidityStatusResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/QueryLiquidityStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UnlockFarmingReward(ctx context.Context, in *UnlockFarmingRewardRequest, opts ...grpc.CallOption) (*UnlockFarmingRewardResponse, error) {
	out := new(UnlockFarmingRewardResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UnlockFarmingReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetFarmingRewardDetails(ctx context.Context, in *GetFarmingRewardDetailsRequest, opts ...grpc.CallOption) (*GetFarmingRewardDetailsResponse, error) {
	out := new(GetFarmingRewardDetailsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetFarmingRewardDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) TransferHistory(ctx context.Context, in *TransferHistoryRequest, opts ...grpc.CallOption) (*TransferHistoryResponse, error) {
	out := new(TransferHistoryResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/TransferHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) LPHistory(ctx context.Context, in *LPHistoryRequest, opts ...grpc.CallOption) (*LPHistoryResponse, error) {
	out := new(LPHistoryResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/LPHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) RewardingData(ctx context.Context, in *RewardingDataRequest, opts ...grpc.CallOption) (*RewardingDataResponse, error) {
	out := new(RewardingDataResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/RewardingData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) StakingConfig(ctx context.Context, in *StakingConfigRequest, opts ...grpc.CallOption) (*StakingConfigResponse, error) {
	out := new(StakingConfigResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/StakingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UnlockStakingReward(ctx context.Context, in *UnlockStakingRewardRequest, opts ...grpc.CallOption) (*UnlockStakingRewardResponse, error) {
	out := new(UnlockStakingRewardResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UnlockStakingReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetStakingRewardDetails(ctx context.Context, in *GetStakingRewardDetailsRequest, opts ...grpc.CallOption) (*GetStakingRewardDetailsResponse, error) {
	out := new(GetStakingRewardDetailsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetStakingRewardDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTotalLiquidityProviderTokenBalance(ctx context.Context, in *GetTotalLiquidityProviderTokenBalanceRequest, opts ...grpc.CallOption) (*GetTotalLiquidityProviderTokenBalanceResponse, error) {
	out := new(GetTotalLiquidityProviderTokenBalanceResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTotalLiquidityProviderTokenBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UpdateChain(ctx context.Context, in *UpdateChainRequest, opts ...grpc.CallOption) (*UpdateChainResponse, error) {
	out := new(UpdateChainResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UpdateChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UpdateToken(ctx context.Context, in *UpdateTokenRequest, opts ...grpc.CallOption) (*UpdateTokenResponse, error) {
	out := new(UpdateTokenResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UpdateToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetCampaignScores(ctx context.Context, in *GetCampaignScoresRequest, opts ...grpc.CallOption) (*GetCampaignScoresResponse, error) {
	out := new(GetCampaignScoresResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetCampaignScores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetInfoByTxHash(ctx context.Context, in *GetInfoByTxHashRequest, opts ...grpc.CallOption) (*GetInfoByTxHashResponse, error) {
	out := new(GetInfoByTxHashResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetInfoByTxHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) FixEventMiss(ctx context.Context, in *FixEventMissRequest, opts ...grpc.CallOption) (*FixEventMissResponse, error) {
	out := new(FixEventMissResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/FixEventMiss", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) ReportCurrentBlockNumber(ctx context.Context, in *ReportCurrentBlockNumberRequest, opts ...grpc.CallOption) (*ReportCurrentBlockNumberResponse, error) {
	out := new(ReportCurrentBlockNumberResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/ReportCurrentBlockNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetRetentionRewardsInfo(ctx context.Context, in *GetRetentionRewardsInfoRequest, opts ...grpc.CallOption) (*GetRetentionRewardsInfoResponse, error) {
	out := new(GetRetentionRewardsInfoResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetRetentionRewardsInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) ClaimRetentionRewards(ctx context.Context, in *ClaimRetentionRewardsRequest, opts ...grpc.CallOption) (*ClaimRetentionRewardsResponse, error) {
	out := new(ClaimRetentionRewardsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/ClaimRetentionRewards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetFeeRebateInfo(ctx context.Context, in *GetFeeRebateInfoRequest, opts ...grpc.CallOption) (*GetFeeRebateInfoResponse, error) {
	out := new(GetFeeRebateInfoResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetFeeRebateInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) ClaimFeeRebate(ctx context.Context, in *ClaimFeeRebateRequest, opts ...grpc.CallOption) (*ClaimFeeRebateResponse, error) {
	out := new(ClaimFeeRebateResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/ClaimFeeRebate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebServer is the server API for Web service.
type WebServer interface {
	// get chain and token selector
	// after getting these info, remember to record them(especially decimal)
	GetTransferConfigs(context.Context, *GetTransferConfigsRequest) (*GetTransferConfigsResponse, error)
	// get chain and token info
	GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoResponse, error)
	// estimate transfer fee
	EstimateAmt(context.Context, *EstimateAmtRequest) (*EstimateAmtResponse, error)
	GetTransferStatus(context.Context, *GetTransferStatusRequest) (*GetTransferStatusResponse, error)
	// LP
	//  get LP table info
	GetLPInfoList(context.Context, *GetLPInfoListRequest) (*GetLPInfoListResponse, error)
	// https://github.com/celer-network/sgn-v2/blob/main/proto/sgn/cbridge/v1/tx.proto#L10
	//  remove liquidity or refund transfer calling this api
	WithdrawLiquidity(context.Context, *WithdrawLiquidityRequest) (*WithdrawLiquidityResponse, error)
	// estimate transfer fee
	// front end need post method for this api
	EstimateWithdrawAmt(context.Context, *EstimateWithdrawAmtRequest) (*EstimateWithdrawAmtResponse, error)
	// bcz it's time cost for sgn voting, so we need a polling api to check the status
	QueryLiquidityStatus(context.Context, *QueryLiquidityStatusRequest) (*QueryLiquidityStatusResponse, error)
	// web will use this api to init reward claim
	UnlockFarmingReward(context.Context, *UnlockFarmingRewardRequest) (*UnlockFarmingRewardResponse, error)
	// web polling this api after UnlockFarmingReward
	GetFarmingRewardDetails(context.Context, *GetFarmingRewardDetailsRequest) (*GetFarmingRewardDetailsResponse, error)
	// History
	TransferHistory(context.Context, *TransferHistoryRequest) (*TransferHistoryResponse, error)
	LPHistory(context.Context, *LPHistoryRequest) (*LPHistoryResponse, error)
	RewardingData(context.Context, *RewardingDataRequest) (*RewardingDataResponse, error)
	// staking api
	StakingConfig(context.Context, *StakingConfigRequest) (*StakingConfigResponse, error)
	// web will use this api to init distribution reward claim
	UnlockStakingReward(context.Context, *UnlockStakingRewardRequest) (*UnlockStakingRewardResponse, error)
	// web polling this api after UnlockStakingReward
	GetStakingRewardDetails(context.Context, *GetStakingRewardDetailsRequest) (*GetStakingRewardDetailsResponse, error)
	// Safeguarding apis
	GetTotalLiquidityProviderTokenBalance(context.Context, *GetTotalLiquidityProviderTokenBalanceRequest) (*GetTotalLiquidityProviderTokenBalanceResponse, error)
	// configs api, apis in these service need sign valid addr
	UpdateChain(context.Context, *UpdateChainRequest) (*UpdateChainResponse, error)
	UpdateToken(context.Context, *UpdateTokenRequest) (*UpdateTokenResponse, error)
	GetCampaignScores(context.Context, *GetCampaignScoresRequest) (*GetCampaignScoresResponse, error)
	// cs tools
	GetInfoByTxHash(context.Context, *GetInfoByTxHashRequest) (*GetInfoByTxHashResponse, error)
	// only CA_USE_RESYNC_TOOL and CA_USE_RESIGN_TOOL will be handled
	FixEventMiss(context.Context, *FixEventMissRequest) (*FixEventMissResponse, error)
	ReportCurrentBlockNumber(context.Context, *ReportCurrentBlockNumberRequest) (*ReportCurrentBlockNumberResponse, error)
	// incentive rewards
	GetRetentionRewardsInfo(context.Context, *GetRetentionRewardsInfoRequest) (*GetRetentionRewardsInfoResponse, error)
	ClaimRetentionRewards(context.Context, *ClaimRetentionRewardsRequest) (*ClaimRetentionRewardsResponse, error)
	GetFeeRebateInfo(context.Context, *GetFeeRebateInfoRequest) (*GetFeeRebateInfoResponse, error)
	ClaimFeeRebate(context.Context, *ClaimFeeRebateRequest) (*ClaimFeeRebateResponse, error)
}

// UnimplementedWebServer can be embedded to have forward compatible implementations.
type UnimplementedWebServer struct {
}

func (*UnimplementedWebServer) GetTransferConfigs(ctx context.Context, req *GetTransferConfigsRequest) (*GetTransferConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransferConfigs not implemented")
}
func (*UnimplementedWebServer) GetTokenInfo(ctx context.Context, req *GetTokenInfoRequest) (*GetTokenInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenInfo not implemented")
}
func (*UnimplementedWebServer) EstimateAmt(ctx context.Context, req *EstimateAmtRequest) (*EstimateAmtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateAmt not implemented")
}
func (*UnimplementedWebServer) GetTransferStatus(ctx context.Context, req *GetTransferStatusRequest) (*GetTransferStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransferStatus not implemented")
}
func (*UnimplementedWebServer) GetLPInfoList(ctx context.Context, req *GetLPInfoListRequest) (*GetLPInfoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLPInfoList not implemented")
}
func (*UnimplementedWebServer) WithdrawLiquidity(ctx context.Context, req *WithdrawLiquidityRequest) (*WithdrawLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawLiquidity not implemented")
}
func (*UnimplementedWebServer) EstimateWithdrawAmt(ctx context.Context, req *EstimateWithdrawAmtRequest) (*EstimateWithdrawAmtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateWithdrawAmt not implemented")
}
func (*UnimplementedWebServer) QueryLiquidityStatus(ctx context.Context, req *QueryLiquidityStatusRequest) (*QueryLiquidityStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryLiquidityStatus not implemented")
}
func (*UnimplementedWebServer) UnlockFarmingReward(ctx context.Context, req *UnlockFarmingRewardRequest) (*UnlockFarmingRewardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockFarmingReward not implemented")
}
func (*UnimplementedWebServer) GetFarmingRewardDetails(ctx context.Context, req *GetFarmingRewardDetailsRequest) (*GetFarmingRewardDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFarmingRewardDetails not implemented")
}
func (*UnimplementedWebServer) TransferHistory(ctx context.Context, req *TransferHistoryRequest) (*TransferHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferHistory not implemented")
}
func (*UnimplementedWebServer) LPHistory(ctx context.Context, req *LPHistoryRequest) (*LPHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LPHistory not implemented")
}
func (*UnimplementedWebServer) RewardingData(ctx context.Context, req *RewardingDataRequest) (*RewardingDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardingData not implemented")
}
func (*UnimplementedWebServer) StakingConfig(ctx context.Context, req *StakingConfigRequest) (*StakingConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StakingConfig not implemented")
}
func (*UnimplementedWebServer) UnlockStakingReward(ctx context.Context, req *UnlockStakingRewardRequest) (*UnlockStakingRewardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockStakingReward not implemented")
}
func (*UnimplementedWebServer) GetStakingRewardDetails(ctx context.Context, req *GetStakingRewardDetailsRequest) (*GetStakingRewardDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStakingRewardDetails not implemented")
}
func (*UnimplementedWebServer) GetTotalLiquidityProviderTokenBalance(ctx context.Context, req *GetTotalLiquidityProviderTokenBalanceRequest) (*GetTotalLiquidityProviderTokenBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalLiquidityProviderTokenBalance not implemented")
}
func (*UnimplementedWebServer) UpdateChain(ctx context.Context, req *UpdateChainRequest) (*UpdateChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChain not implemented")
}
func (*UnimplementedWebServer) UpdateToken(ctx context.Context, req *UpdateTokenRequest) (*UpdateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateToken not implemented")
}
func (*UnimplementedWebServer) GetCampaignScores(ctx context.Context, req *GetCampaignScoresRequest) (*GetCampaignScoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCampaignScores not implemented")
}
func (*UnimplementedWebServer) GetInfoByTxHash(ctx context.Context, req *GetInfoByTxHashRequest) (*GetInfoByTxHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfoByTxHash not implemented")
}
func (*UnimplementedWebServer) FixEventMiss(ctx context.Context, req *FixEventMissRequest) (*FixEventMissResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FixEventMiss not implemented")
}
func (*UnimplementedWebServer) ReportCurrentBlockNumber(ctx context.Context, req *ReportCurrentBlockNumberRequest) (*ReportCurrentBlockNumberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportCurrentBlockNumber not implemented")
}
func (*UnimplementedWebServer) GetRetentionRewardsInfo(ctx context.Context, req *GetRetentionRewardsInfoRequest) (*GetRetentionRewardsInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRetentionRewardsInfo not implemented")
}
func (*UnimplementedWebServer) ClaimRetentionRewards(ctx context.Context, req *ClaimRetentionRewardsRequest) (*ClaimRetentionRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimRetentionRewards not implemented")
}
func (*UnimplementedWebServer) GetFeeRebateInfo(ctx context.Context, req *GetFeeRebateInfoRequest) (*GetFeeRebateInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeeRebateInfo not implemented")
}
func (*UnimplementedWebServer) ClaimFeeRebate(ctx context.Context, req *ClaimFeeRebateRequest) (*ClaimFeeRebateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimFeeRebate not implemented")
}

func RegisterWebServer(s grpc1.Server, srv WebServer) {
	s.RegisterService(&_Web_serviceDesc, srv)
}

func _Web_GetTransferConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransferConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTransferConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTransferConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTransferConfigs(ctx, req.(*GetTransferConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTokenInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTokenInfo(ctx, req.(*GetTokenInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_EstimateAmt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateAmtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).EstimateAmt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/EstimateAmt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).EstimateAmt(ctx, req.(*EstimateAmtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTransferStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransferStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTransferStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTransferStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTransferStatus(ctx, req.(*GetTransferStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetLPInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLPInfoListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetLPInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetLPInfoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetLPInfoList(ctx, req.(*GetLPInfoListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_WithdrawLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).WithdrawLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/WithdrawLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).WithdrawLiquidity(ctx, req.(*WithdrawLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_EstimateWithdrawAmt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateWithdrawAmtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).EstimateWithdrawAmt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/EstimateWithdrawAmt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).EstimateWithdrawAmt(ctx, req.(*EstimateWithdrawAmtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_QueryLiquidityStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLiquidityStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).QueryLiquidityStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/QueryLiquidityStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).QueryLiquidityStatus(ctx, req.(*QueryLiquidityStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UnlockFarmingReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockFarmingRewardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UnlockFarmingReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UnlockFarmingReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UnlockFarmingReward(ctx, req.(*UnlockFarmingRewardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetFarmingRewardDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFarmingRewardDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetFarmingRewardDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetFarmingRewardDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetFarmingRewardDetails(ctx, req.(*GetFarmingRewardDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_TransferHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).TransferHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/TransferHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).TransferHistory(ctx, req.(*TransferHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_LPHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LPHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).LPHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/LPHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).LPHistory(ctx, req.(*LPHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_RewardingData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardingDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).RewardingData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/RewardingData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).RewardingData(ctx, req.(*RewardingDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_StakingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StakingConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).StakingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/StakingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).StakingConfig(ctx, req.(*StakingConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UnlockStakingReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockStakingRewardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UnlockStakingReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UnlockStakingReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UnlockStakingReward(ctx, req.(*UnlockStakingRewardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetStakingRewardDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStakingRewardDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetStakingRewardDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetStakingRewardDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetStakingRewardDetails(ctx, req.(*GetStakingRewardDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTotalLiquidityProviderTokenBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTotalLiquidityProviderTokenBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTotalLiquidityProviderTokenBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTotalLiquidityProviderTokenBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTotalLiquidityProviderTokenBalance(ctx, req.(*GetTotalLiquidityProviderTokenBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UpdateChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UpdateChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UpdateChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UpdateChain(ctx, req.(*UpdateChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UpdateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UpdateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UpdateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UpdateToken(ctx, req.(*UpdateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetCampaignScores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCampaignScoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetCampaignScores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetCampaignScores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetCampaignScores(ctx, req.(*GetCampaignScoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetInfoByTxHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoByTxHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetInfoByTxHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetInfoByTxHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetInfoByTxHash(ctx, req.(*GetInfoByTxHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_FixEventMiss_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FixEventMissRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).FixEventMiss(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/FixEventMiss",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).FixEventMiss(ctx, req.(*FixEventMissRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_ReportCurrentBlockNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCurrentBlockNumberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).ReportCurrentBlockNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/ReportCurrentBlockNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).ReportCurrentBlockNumber(ctx, req.(*ReportCurrentBlockNumberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetRetentionRewardsInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRetentionRewardsInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetRetentionRewardsInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetRetentionRewardsInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetRetentionRewardsInfo(ctx, req.(*GetRetentionRewardsInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_ClaimRetentionRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimRetentionRewardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).ClaimRetentionRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/ClaimRetentionRewards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).ClaimRetentionRewards(ctx, req.(*ClaimRetentionRewardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetFeeRebateInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeeRebateInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetFeeRebateInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetFeeRebateInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetFeeRebateInfo(ctx, req.(*GetFeeRebateInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_ClaimFeeRebate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimFeeRebateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).ClaimFeeRebate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/ClaimFeeRebate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).ClaimFeeRebate(ctx, req.(*ClaimFeeRebateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Web_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sgn.gateway.v1.Web",
	HandlerType: (*WebServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransferConfigs",
			Handler:    _Web_GetTransferConfigs_Handler,
		},
		{
			MethodName: "GetTokenInfo",
			Handler:    _Web_GetTokenInfo_Handler,
		},
		{
			MethodName: "EstimateAmt",
			Handler:    _Web_EstimateAmt_Handler,
		},
		{
			MethodName: "GetTransferStatus",
			Handler:    _Web_GetTransferStatus_Handler,
		},
		{
			MethodName: "GetLPInfoList",
			Handler:    _Web_GetLPInfoList_Handler,
		},
		{
			MethodName: "WithdrawLiquidity",
			Handler:    _Web_WithdrawLiquidity_Handler,
		},
		{
			MethodName: "EstimateWithdrawAmt",
			Handler:    _Web_EstimateWithdrawAmt_Handler,
		},
		{
			MethodName: "QueryLiquidityStatus",
			Handler:    _Web_QueryLiquidityStatus_Handler,
		},
		{
			MethodName: "UnlockFarmingReward",
			Handler:    _Web_UnlockFarmingReward_Handler,
		},
		{
			MethodName: "GetFarmingRewardDetails",
			Handler:    _Web_GetFarmingRewardDetails_Handler,
		},
		{
			MethodName: "TransferHistory",
			Handler:    _Web_TransferHistory_Handler,
		},
		{
			MethodName: "LPHistory",
			Handler:    _Web_LPHistory_Handler,
		},
		{
			MethodName: "RewardingData",
			Handler:    _Web_RewardingData_Handler,
		},
		{
			MethodName: "StakingConfig",
			Handler:    _Web_StakingConfig_Handler,
		},
		{
			MethodName: "UnlockStakingReward",
			Handler:    _Web_UnlockStakingReward_Handler,
		},
		{
			MethodName: "GetStakingRewardDetails",
			Handler:    _Web_GetStakingRewardDetails_Handler,
		},
		{
			MethodName: "GetTotalLiquidityProviderTokenBalance",
			Handler:    _Web_GetTotalLiquidityProviderTokenBalance_Handler,
		},
		{
			MethodName: "UpdateChain",
			Handler:    _Web_UpdateChain_Handler,
		},
		{
			MethodName: "UpdateToken",
			Handler:    _Web_UpdateToken_Handler,
		},
		{
			MethodName: "GetCampaignScores",
			Handler:    _Web_GetCampaignScores_Handler,
		},
		{
			MethodName: "GetInfoByTxHash",
			Handler:    _Web_GetInfoByTxHash_Handler,
		},
		{
			MethodName: "FixEventMiss",
			Handler:    _Web_FixEventMiss_Handler,
		},
		{
			MethodName: "ReportCurrentBlockNumber",
			Handler:    _Web_ReportCurrentBlockNumber_Handler,
		},
		{
			MethodName: "GetRetentionRewardsInfo",
			Handler:    _Web_GetRetentionRewardsInfo_Handler,
		},
		{
			MethodName: "ClaimRetentionRewards",
			Handler:    _Web_ClaimRetentionRewards_Handler,
		},
		{
			MethodName: "GetFeeRebateInfo",
			Handler:    _Web_GetFeeRebateInfo_Handler,
		},
		{
			MethodName: "ClaimFeeRebate",
			Handler:    _Web_ClaimFeeRebate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sgn/gateway/v1/gateway.proto",
}

func (m *GetCampaignScoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCampaignScoresRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCampaignScoresRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndBlock != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EndBlock))
		i--
		dAtA[i] = 0x18
	}
	if m.BeginBlock != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BeginBlock))
		i--
		dAtA[i] = 0x10
	}
	if m.Date != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCampaignScoresResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCampaignScoresResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCampaignScoresResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x18
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Scores) > 0 {
		for iNdEx := len(m.Scores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CampaignScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CampaignScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CampaignScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UsrAddr) > 0 {
		i -= len(m.UsrAddr)
		copy(dAtA[i:], m.UsrAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.UsrAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLiquidityStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidityStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidityStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockDelay != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BlockDelay))
		i--
		dAtA[i] = 0x40
	}
	if len(m.BlockTxLink) > 0 {
		i -= len(m.BlockTxLink)
		copy(dAtA[i:], m.BlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BlockTxLink)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Powers) > 0 {
		for iNdEx := len(m.Powers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Powers[iNdEx])
			copy(dAtA[i:], m.Powers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Powers[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SortedSigs[iNdEx])
			copy(dAtA[i:], m.SortedSigs[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.SortedSigs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.WdOnchain) > 0 {
		i -= len(m.WdOnchain)
		copy(dAtA[i:], m.WdOnchain)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WdOnchain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Chain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SuggestedBaseFee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SuggestedBaseFee))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.DropGasAmt) > 0 {
		i -= len(m.DropGasAmt)
		copy(dAtA[i:], m.DropGasAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DropGasAmt)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ContractAddr) > 0 {
		i -= len(m.ContractAddr)
		copy(dAtA[i:], m.ContractAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ContractAddr)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ExploreUrl) > 0 {
		i -= len(m.ExploreUrl)
		copy(dAtA[i:], m.ExploreUrl)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ExploreUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GasTokenSymbol) > 0 {
		i -= len(m.GasTokenSymbol)
		copy(dAtA[i:], m.GasTokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.GasTokenSymbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BlockDelay != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BlockDelay))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChainTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		for iNdEx := len(m.Token) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Token[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstBlockTxLink) > 0 {
		i -= len(m.DstBlockTxLink)
		copy(dAtA[i:], m.DstBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DstBlockTxLink)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcBlockTxLink) > 0 {
		i -= len(m.SrcBlockTxLink)
		copy(dAtA[i:], m.SrcBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SrcBlockTxLink)))
		i--
		dAtA[i] = 0x4a
	}
	if m.BlockDelay != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BlockDelay))
		i--
		dAtA[i] = 0x40
	}
	if m.RefundReason != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RefundReason))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Powers) > 0 {
		for iNdEx := len(m.Powers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Powers[iNdEx])
			copy(dAtA[i:], m.Powers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Powers[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SortedSigs[iNdEx])
			copy(dAtA[i:], m.SortedSigs[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.SortedSigs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.WdOnchain) > 0 {
		i -= len(m.WdOnchain)
		copy(dAtA[i:], m.WdOnchain)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WdOnchain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTransferConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PeggedPairConfigs) > 0 {
		for iNdEx := len(m.PeggedPairConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PeggedPairConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.FarmingRewardContractAddr) > 0 {
		i -= len(m.FarmingRewardContractAddr)
		copy(dAtA[i:], m.FarmingRewardContractAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.FarmingRewardContractAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainToken) > 0 {
		for k := range m.ChainToken {
			v := m.ChainToken[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGateway(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Chains) > 0 {
		for iNdEx := len(m.Chains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PeggedPairConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeggedPairConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeggedPairConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PeggedBurnContractAddr) > 0 {
		i -= len(m.PeggedBurnContractAddr)
		copy(dAtA[i:], m.PeggedBurnContractAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.PeggedBurnContractAddr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PeggedDepositContractAddr) > 0 {
		i -= len(m.PeggedDepositContractAddr)
		copy(dAtA[i:], m.PeggedDepositContractAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.PeggedDepositContractAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if m.PeggedToken != nil {
		{
			size, err := m.PeggedToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PeggedChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PeggedChainId))
		i--
		dAtA[i] = 0x18
	}
	if m.OrgToken != nil {
		{
			size, err := m.OrgToken.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OrgChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.OrgChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TokenInfo != nil {
		{
			size, err := m.TokenInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstimateAmtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateAmtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateAmtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsPegged {
		i--
		if m.IsPegged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x30
	}
	if len(m.UsrAddr) > 0 {
		i -= len(m.UsrAddr)
		copy(dAtA[i:], m.UsrAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.UsrAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Amt) > 0 {
		i -= len(m.Amt)
		copy(dAtA[i:], m.Amt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amt)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DstChainId))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SrcChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EstimateAmtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateAmtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateAmtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseFee) > 0 {
		i -= len(m.BaseFee)
		copy(dAtA[i:], m.BaseFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BaseFee)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxSlippage != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MaxSlippage))
		i--
		dAtA[i] = 0x30
	}
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PercFee) > 0 {
		i -= len(m.PercFee)
		copy(dAtA[i:], m.PercFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.PercFee)))
		i--
		dAtA[i] = 0x22
	}
	if m.BridgeRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BridgeRate))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.EqValueTokenAmt) > 0 {
		i -= len(m.EqValueTokenAmt)
		copy(dAtA[i:], m.EqValueTokenAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EqValueTokenAmt)))
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EstimateWithdrawAmtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateWithdrawAmtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateWithdrawAmtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsrAddr) > 0 {
		i -= len(m.UsrAddr)
		copy(dAtA[i:], m.UsrAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.UsrAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DstChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SrcWithdraws) > 0 {
		for iNdEx := len(m.SrcWithdraws) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SrcWithdraws[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EstimateWithdrawAmtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateWithdrawAmtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateWithdrawAmtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReqAmt) > 0 {
		for k := range m.ReqAmt {
			v := m.ReqAmt[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGateway(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstimateWithdrawAmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateWithdrawAmt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateWithdrawAmt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSlippage != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MaxSlippage))
		i--
		dAtA[i] = 0x30
	}
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x28
	}
	if len(m.BaseFee) > 0 {
		i -= len(m.BaseFee)
		copy(dAtA[i:], m.BaseFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BaseFee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PercFee) > 0 {
		i -= len(m.PercFee)
		copy(dAtA[i:], m.PercFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.PercFee)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BridgeRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BridgeRate))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.EqValueTokenAmt) > 0 {
		i -= len(m.EqValueTokenAmt)
		copy(dAtA[i:], m.EqValueTokenAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EqValueTokenAmt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLPInfoListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLPInfoListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLPInfoListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FarmingSessionTokens) > 0 {
		for iNdEx := len(m.FarmingSessionTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FarmingSessionTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.FarmingApy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FarmingApy))))
		i--
		dAtA[i] = 0x61
	}
	if m.LpFeeEarningApy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LpFeeEarningApy))))
		i--
		dAtA[i] = 0x59
	}
	if len(m.TotalLiquidityAmt) > 0 {
		i -= len(m.TotalLiquidityAmt)
		copy(dAtA[i:], m.TotalLiquidityAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TotalLiquidityAmt)))
		i--
		dAtA[i] = 0x52
	}
	if m.TotalLiquidity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalLiquidity))))
		i--
		dAtA[i] = 0x49
	}
	if m.Volume_24H != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume_24H))))
		i--
		dAtA[i] = 0x41
	}
	if m.FarmingRewardEarning != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FarmingRewardEarning))))
		i--
		dAtA[i] = 0x39
	}
	if m.LpFeeEarning != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LpFeeEarning))))
		i--
		dAtA[i] = 0x31
	}
	if m.HasFarmingSessions {
		i--
		if m.HasFarmingSessions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.LiquidityAmt) > 0 {
		i -= len(m.LiquidityAmt)
		copy(dAtA[i:], m.LiquidityAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LiquidityAmt)))
		i--
		dAtA[i] = 0x22
	}
	if m.Liquidity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Liquidity))))
		i--
		dAtA[i] = 0x19
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLPInfoListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLPInfoListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLPInfoListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LpInfo) > 0 {
		for iNdEx := len(m.LpInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LpInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawLiquidityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawLiquidityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawLiquidityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MethodType != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MethodType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EstimatedReceivedAmt) > 0 {
		i -= len(m.EstimatedReceivedAmt)
		copy(dAtA[i:], m.EstimatedReceivedAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EstimatedReceivedAmt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WithdrawReq) > 0 {
		i -= len(m.WithdrawReq)
		copy(dAtA[i:], m.WithdrawReq)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WithdrawReq)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockFarmingRewardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockFarmingRewardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockFarmingRewardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockFarmingRewardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockFarmingRewardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockFarmingRewardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFarmingRewardDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFarmingRewardDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFarmingRewardDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFarmingRewardDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFarmingRewardDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFarmingRewardDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		for iNdEx := len(m.Details) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Details[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLiquidityStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidityStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidityStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LpAddr) > 0 {
		i -= len(m.LpAddr)
		copy(dAtA[i:], m.LpAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LpAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefundReason != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RefundReason))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DstBlockTxLink) > 0 {
		i -= len(m.DstBlockTxLink)
		copy(dAtA[i:], m.DstBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DstBlockTxLink)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SrcBlockTxLink) > 0 {
		i -= len(m.SrcBlockTxLink)
		copy(dAtA[i:], m.SrcBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SrcBlockTxLink)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ts != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Ts))
		i--
		dAtA[i] = 0x20
	}
	if m.DstReceivedInfo != nil {
		{
			size, err := m.DstReceivedInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcSendInfo != nil {
		{
			size, err := m.SrcSendInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nonce != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x50
	}
	if m.MethodType != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MethodType))
		i--
		dAtA[i] = 0x48
	}
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x40
	}
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BlockTxLink) > 0 {
		i -= len(m.BlockTxLink)
		copy(dAtA[i:], m.BlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BlockTxLink)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ts != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Ts))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.CurrentSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.History) > 0 {
		for iNdEx := len(m.History) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.History[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.CurrentSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.History) > 0 {
		for iNdEx := len(m.History) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.History[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardingDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardingDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardingDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Amt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amt))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *RewardingDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardingDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardingDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnlockedCumulativeRewards) > 0 {
		for iNdEx := len(m.UnlockedCumulativeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnlockedCumulativeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.HistoricalCumulativeRewards) > 0 {
		for iNdEx := len(m.HistoricalCumulativeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoricalCumulativeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.UsdPrice) > 0 {
		for k := range m.UsdPrice {
			v := m.UsdPrice[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGateway(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateChainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateChainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateChainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TxUrlPrefix) > 0 {
		i -= len(m.TxUrlPrefix)
		copy(dAtA[i:], m.TxUrlPrefix)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxUrlPrefix)))
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxUrlPrefix) > 0 {
		i -= len(m.TxUrlPrefix)
		copy(dAtA[i:], m.TxUrlPrefix)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxUrlPrefix)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenIcon) > 0 {
		i -= len(m.TokenIcon)
		copy(dAtA[i:], m.TokenIcon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenIcon)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenName) > 0 {
		i -= len(m.TokenName)
		copy(dAtA[i:], m.TokenName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakingConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakingConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakingConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StakingConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakingConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakingConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CelrContract) > 0 {
		i -= len(m.CelrContract)
		copy(dAtA[i:], m.CelrContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.CelrContract)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StakingRewardContract) > 0 {
		i -= len(m.StakingRewardContract)
		copy(dAtA[i:], m.StakingRewardContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.StakingRewardContract)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StakingContract) > 0 {
		i -= len(m.StakingContract)
		copy(dAtA[i:], m.StakingContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.StakingContract)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ViewerContract) > 0 {
		i -= len(m.ViewerContract)
		copy(dAtA[i:], m.ViewerContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ViewerContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockStakingRewardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockStakingRewardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockStakingRewardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockStakingRewardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockStakingRewardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockStakingRewardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStakingRewardDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStakingRewardDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStakingRewardDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStakingRewardDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStakingRewardDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStakingRewardDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		{
			size, err := m.Detail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainIds) > 0 {
		dAtA39 := make([]byte, len(m.ChainIds)*10)
		var j38 int
		for _, num := range m.ChainIds {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		i -= j38
		copy(dAtA[i:], dAtA39[:j38])
		i = encodeVarintGateway(dAtA, i, uint64(j38))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalLiq) > 0 {
		for k := range m.TotalLiq {
			v := m.TotalLiq[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGateway(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetInfoByTxHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInfoByTxHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetInfoByTxHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetInfoByTxHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetInfoByTxHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetInfoByTxHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Memo) > 0 {
		i -= len(m.Memo)
		copy(dAtA[i:], m.Memo)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Memo)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Operation != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FixEventMissRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FixEventMissRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FixEventMissRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FixEventMissResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FixEventMissResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FixEventMissResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRetentionRewardsInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRetentionRewardsInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRetentionRewardsInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetRetentionRewardsInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRetentionRewardsInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetRetentionRewardsInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGateway(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.ClaimTime != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ClaimTime))
		i--
		dAtA[i] = 0x40
	}
	if m.CelrUsdPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CelrUsdPrice))))
		i--
		dAtA[i] = 0x39
	}
	if len(m.CurrentReward) > 0 {
		i -= len(m.CurrentReward)
		copy(dAtA[i:], m.CurrentReward)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.CurrentReward)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxTransferVolume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxTransferVolume))))
		i--
		dAtA[i] = 0x29
	}
	if len(m.MaxReward) > 0 {
		i -= len(m.MaxReward)
		copy(dAtA[i:], m.MaxReward)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.MaxReward)))
		i--
		dAtA[i] = 0x22
	}
	if m.EventEndTime != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EventEndTime))
		i--
		dAtA[i] = 0x18
	}
	if m.EventId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimRetentionRewardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimRetentionRewardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimRetentionRewardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimRetentionRewardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimRetentionRewardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimRetentionRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGateway(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.CurrentReward) > 0 {
		i -= len(m.CurrentReward)
		copy(dAtA[i:], m.CurrentReward)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.CurrentReward)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFeeRebateInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFeeRebateInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFeeRebateInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFeeRebateInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFeeRebateInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFeeRebateInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGateway(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.ClaimTime != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ClaimTime))
		i--
		dAtA[i] = 0x38
	}
	if m.CelrUsdPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CelrUsdPrice))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.Reward) > 0 {
		i -= len(m.Reward)
		copy(dAtA[i:], m.Reward)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Reward)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RebatePortion != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.RebatePortion))))
		i--
		dAtA[i] = 0x21
	}
	if m.EventEndTime != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EventEndTime))
		i--
		dAtA[i] = 0x18
	}
	if m.EventId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimFeeRebateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimFeeRebateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimFeeRebateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimFeeRebateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimFeeRebateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimFeeRebateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintGateway(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Reward) > 0 {
		i -= len(m.Reward)
		copy(dAtA[i:], m.Reward)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Reward)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EventId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EventId))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportCurrentBlockNumberRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportCurrentBlockNumberRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportCurrentBlockNumberRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Report) > 0 {
		i -= len(m.Report)
		copy(dAtA[i:], m.Report)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Report)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CurrentBlockNumberReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrentBlockNumberReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrentBlockNumberReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlockNums) > 0 {
		for k := range m.BlockNums {
			v := m.BlockNums[k]
			baseI := i
			i = encodeVarintGateway(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportCurrentBlockNumberResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportCurrentBlockNumberResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportCurrentBlockNumberResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ErrMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGateway(dAtA []byte, offset int, v uint64) int {
	offset -= sovGateway(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetCampaignScoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Date != 0 {
		n += 1 + sovGateway(uint64(m.Date))
	}
	if m.BeginBlock != 0 {
		n += 1 + sovGateway(uint64(m.BeginBlock))
	}
	if m.EndBlock != 0 {
		n += 1 + sovGateway(uint64(m.EndBlock))
	}
	return n
}

func (m *GetCampaignScoresResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scores) > 0 {
		for _, e := range m.Scores {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Begin != 0 {
		n += 1 + sovGateway(uint64(m.Begin))
	}
	return n
}

func (m *CampaignScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsrAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovGateway(uint64(m.Score))
	}
	return n
}

func (m *QueryLiquidityStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	l = len(m.WdOnchain)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, b := range m.SortedSigs {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, b := range m.Signers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Powers) > 0 {
		for _, b := range m.Powers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.BlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BlockDelay != 0 {
		n += 1 + sovGateway(uint64(m.BlockDelay))
	}
	return n
}

func (m *Chain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGateway(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BlockDelay != 0 {
		n += 1 + sovGateway(uint64(m.BlockDelay))
	}
	l = len(m.GasTokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ExploreUrl)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ContractAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DropGasAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SuggestedBaseFee != 0 {
		n += 9
	}
	return n
}

func (m *ChainTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Token) > 0 {
		for _, e := range m.Token {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *TokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTransferStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTransferStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	l = len(m.WdOnchain)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, b := range m.SortedSigs {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, b := range m.Signers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Powers) > 0 {
		for _, b := range m.Powers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.RefundReason != 0 {
		n += 1 + sovGateway(uint64(m.RefundReason))
	}
	if m.BlockDelay != 0 {
		n += 1 + sovGateway(uint64(m.BlockDelay))
	}
	l = len(m.SrcBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DstBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTransferConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTransferConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.Chains) > 0 {
		for _, e := range m.Chains {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.ChainToken) > 0 {
		for k, v := range m.ChainToken {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGateway(uint64(l))
			}
			mapEntrySize := 1 + sovGateway(uint64(k)) + l
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	l = len(m.FarmingRewardContractAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.PeggedPairConfigs) > 0 {
		for _, e := range m.PeggedPairConfigs {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *PeggedPairConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrgChainId != 0 {
		n += 1 + sovGateway(uint64(m.OrgChainId))
	}
	if m.OrgToken != nil {
		l = m.OrgToken.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.PeggedChainId != 0 {
		n += 1 + sovGateway(uint64(m.PeggedChainId))
	}
	if m.PeggedToken != nil {
		l = m.PeggedToken.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.PeggedDepositContractAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.PeggedBurnContractAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTokenInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTokenInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.TokenInfo != nil {
		l = m.TokenInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EstimateAmtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcChainId != 0 {
		n += 1 + sovGateway(uint64(m.SrcChainId))
	}
	if m.DstChainId != 0 {
		n += 1 + sovGateway(uint64(m.DstChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.UsrAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	if m.IsPegged {
		n += 2
	}
	return n
}

func (m *EstimateAmtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.EqValueTokenAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BridgeRate != 0 {
		n += 5
	}
	l = len(m.PercFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	if m.MaxSlippage != 0 {
		n += 1 + sovGateway(uint64(m.MaxSlippage))
	}
	l = len(m.BaseFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *WithdrawInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	return n
}

func (m *EstimateWithdrawAmtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SrcWithdraws) > 0 {
		for _, e := range m.SrcWithdraws {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.DstChainId != 0 {
		n += 1 + sovGateway(uint64(m.DstChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.UsrAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EstimateWithdrawAmtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.ReqAmt) > 0 {
		for k, v := range m.ReqAmt {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGateway(uint64(l))
			}
			mapEntrySize := 1 + sovGateway(uint64(k)) + l
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EstimateWithdrawAmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EqValueTokenAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BridgeRate != 0 {
		n += 5
	}
	l = len(m.PercFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.BaseFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	if m.MaxSlippage != 0 {
		n += 1 + sovGateway(uint64(m.MaxSlippage))
	}
	return n
}

func (m *GetLPInfoListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *LPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Liquidity != 0 {
		n += 9
	}
	l = len(m.LiquidityAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.HasFarmingSessions {
		n += 2
	}
	if m.LpFeeEarning != 0 {
		n += 9
	}
	if m.FarmingRewardEarning != 0 {
		n += 9
	}
	if m.Volume_24H != 0 {
		n += 9
	}
	if m.TotalLiquidity != 0 {
		n += 9
	}
	l = len(m.TotalLiquidityAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.LpFeeEarningApy != 0 {
		n += 9
	}
	if m.FarmingApy != 0 {
		n += 9
	}
	if len(m.FarmingSessionTokens) > 0 {
		for _, e := range m.FarmingSessionTokens {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *GetLPInfoListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.LpInfo) > 0 {
		for _, e := range m.LpInfo {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *WithdrawLiquidityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WithdrawReq)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.EstimatedReceivedAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.MethodType != 0 {
		n += 1 + sovGateway(uint64(m.MethodType))
	}
	return n
}

func (m *WithdrawLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	return n
}

func (m *UnlockFarmingRewardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UnlockFarmingRewardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetFarmingRewardDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetFarmingRewardDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *QueryLiquidityStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.LpAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	return n
}

func (m *TransferHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SrcSendInfo != nil {
		l = m.SrcSendInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DstReceivedInfo != nil {
		l = m.DstReceivedInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovGateway(uint64(m.Ts))
	}
	l = len(m.SrcBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DstBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	if m.RefundReason != 0 {
		n += 1 + sovGateway(uint64(m.RefundReason))
	}
	return n
}

func (m *LPHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovGateway(uint64(m.Ts))
	}
	l = len(m.BlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	if m.MethodType != 0 {
		n += 1 + sovGateway(uint64(m.MethodType))
	}
	if m.Nonce != 0 {
		n += 1 + sovGateway(uint64(m.Nonce))
	}
	return n
}

func (m *TransferHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGateway(uint64(m.PageSize))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TransferHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CurrentSize != 0 {
		n += 1 + sovGateway(uint64(m.CurrentSize))
	}
	return n
}

func (m *LPHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGateway(uint64(m.PageSize))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *LPHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CurrentSize != 0 {
		n += 1 + sovGateway(uint64(m.CurrentSize))
	}
	return n
}

func (m *RewardingDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *Reward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amt != 0 {
		n += 9
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *RewardingDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.UsdPrice) > 0 {
		for k, v := range m.UsdPrice {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGateway(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	if len(m.HistoricalCumulativeRewards) > 0 {
		for _, e := range m.HistoricalCumulativeRewards {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.UnlockedCumulativeRewards) > 0 {
		for _, e := range m.UnlockedCumulativeRewards {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *UpdateChainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TxUrlPrefix)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UpdateChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TxUrlPrefix)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UpdateTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TokenName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TokenIcon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UpdateTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *StakingConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StakingConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ViewerContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.StakingContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.StakingRewardContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.CelrContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UnlockStakingRewardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UnlockStakingRewardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetStakingRewardDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetStakingRewardDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChainIds) > 0 {
		l = 0
		for _, e := range m.ChainIds {
			l += sovGateway(uint64(e))
		}
		n += 1 + sovGateway(uint64(l)) + l
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.TotalLiq) > 0 {
		for k, v := range m.TotalLiq {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGateway(uint64(k)) + 1 + len(v) + sovGateway(uint64(len(v)))
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetInfoByTxHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetInfoByTxHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovGateway(uint64(m.Operation))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	l = len(m.Memo)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *FixEventMissRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *FixEventMissResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetRetentionRewardsInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetRetentionRewardsInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.EventId != 0 {
		n += 1 + sovGateway(uint64(m.EventId))
	}
	if m.EventEndTime != 0 {
		n += 1 + sovGateway(uint64(m.EventEndTime))
	}
	l = len(m.MaxReward)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.MaxTransferVolume != 0 {
		n += 9
	}
	l = len(m.CurrentReward)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CelrUsdPrice != 0 {
		n += 9
	}
	if m.ClaimTime != 0 {
		n += 1 + sovGateway(uint64(m.ClaimTime))
	}
	l = m.Signature.Size()
	n += 1 + l + sovGateway(uint64(l))
	return n
}

func (m *ClaimRetentionRewardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ClaimRetentionRewardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.EventId != 0 {
		n += 1 + sovGateway(uint64(m.EventId))
	}
	l = len(m.CurrentReward)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = m.Signature.Size()
	n += 1 + l + sovGateway(uint64(l))
	return n
}

func (m *GetFeeRebateInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetFeeRebateInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.EventId != 0 {
		n += 1 + sovGateway(uint64(m.EventId))
	}
	if m.EventEndTime != 0 {
		n += 1 + sovGateway(uint64(m.EventEndTime))
	}
	if m.RebatePortion != 0 {
		n += 9
	}
	l = len(m.Reward)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CelrUsdPrice != 0 {
		n += 9
	}
	if m.ClaimTime != 0 {
		n += 1 + sovGateway(uint64(m.ClaimTime))
	}
	l = m.Signature.Size()
	n += 1 + l + sovGateway(uint64(l))
	return n
}

func (m *ClaimFeeRebateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ClaimFeeRebateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.EventId != 0 {
		n += 1 + sovGateway(uint64(m.EventId))
	}
	l = len(m.Reward)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = m.Signature.Size()
	n += 1 + l + sovGateway(uint64(l))
	return n
}

func (m *ReportCurrentBlockNumberRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Report)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *CurrentBlockNumberReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if len(m.BlockNums) > 0 {
		for k, v := range m.BlockNums {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGateway(uint64(k)) + 1 + sovGateway(uint64(v))
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ReportCurrentBlockNumberResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ErrMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGateway(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func sovGateway(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetCampaignScoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCampaignScoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCampaignScoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginBlock", wireType)
			}
			m.BeginBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlock", wireType)
			}
			m.EndBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCampaignScoresResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCampaignScoresResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCampaignScoresResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scores = append(m.Scores, &CampaignScore{})
			if err := m.Scores[len(m.Scores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CampaignScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CampaignScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CampaignScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLiquidityStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidityStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidityStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.WithdrawStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdOnchain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WdOnchain = append(m.WdOnchain[:0], dAtA[iNdEx:postIndex]...)
			if m.WdOnchain == nil {
				m.WdOnchain = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, make([]byte, postIndex-iNdEx))
			copy(m.SortedSigs[len(m.SortedSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, make([]byte, postIndex-iNdEx))
			copy(m.Signers[len(m.Signers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Powers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Powers = append(m.Powers, make([]byte, postIndex-iNdEx))
			copy(m.Powers[len(m.Powers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDelay", wireType)
			}
			m.BlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDelay", wireType)
			}
			m.BlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasTokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasTokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExploreUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExploreUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropGasAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropGasAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuggestedBaseFee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SuggestedBaseFee = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token, &TokenInfo{})
			if err := m.Token[len(m.Token)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.TransferHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdOnchain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WdOnchain = append(m.WdOnchain[:0], dAtA[iNdEx:postIndex]...)
			if m.WdOnchain == nil {
				m.WdOnchain = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, make([]byte, postIndex-iNdEx))
			copy(m.SortedSigs[len(m.SortedSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, make([]byte, postIndex-iNdEx))
			copy(m.Signers[len(m.Signers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Powers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Powers = append(m.Powers, make([]byte, postIndex-iNdEx))
			copy(m.Powers[len(m.Powers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundReason", wireType)
			}
			m.RefundReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundReason |= types.XferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDelay", wireType)
			}
			m.BlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chains = append(m.Chains, &Chain{})
			if err := m.Chains[len(m.Chains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainToken == nil {
				m.ChainToken = make(map[uint32]*ChainTokenInfo)
			}
			var mapkey uint32
			var mapvalue *ChainTokenInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGateway
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGateway
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChainTokenInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChainToken[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingRewardContractAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FarmingRewardContractAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeggedPairConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeggedPairConfigs = append(m.PeggedPairConfigs, &PeggedPairConfig{})
			if err := m.PeggedPairConfigs[len(m.PeggedPairConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeggedPairConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeggedPairConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeggedPairConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgChainId", wireType)
			}
			m.OrgChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrgChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrgToken == nil {
				m.OrgToken = &TokenInfo{}
			}
			if err := m.OrgToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeggedChainId", wireType)
			}
			m.PeggedChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeggedChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeggedToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PeggedToken == nil {
				m.PeggedToken = &TokenInfo{}
			}
			if err := m.PeggedToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeggedDepositContractAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeggedDepositContractAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeggedBurnContractAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeggedBurnContractAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenInfo == nil {
				m.TokenInfo = &TokenInfo{}
			}
			if err := m.TokenInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateAmtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateAmtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateAmtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcChainId", wireType)
			}
			m.SrcChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstChainId", wireType)
			}
			m.DstChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPegged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPegged = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateAmtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateAmtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateAmtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqValueTokenAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqValueTokenAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BridgeRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSlippage", wireType)
			}
			m.MaxSlippage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSlippage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateWithdrawAmtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateWithdrawAmtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateWithdrawAmtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcWithdraws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcWithdraws = append(m.SrcWithdraws, &WithdrawInfo{})
			if err := m.SrcWithdraws[len(m.SrcWithdraws)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstChainId", wireType)
			}
			m.DstChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateWithdrawAmtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateWithdrawAmtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateWithdrawAmtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqAmt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReqAmt == nil {
				m.ReqAmt = make(map[uint32]*EstimateWithdrawAmt)
			}
			var mapkey uint32
			var mapvalue *EstimateWithdrawAmt
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGateway
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGateway
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EstimateWithdrawAmt{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReqAmt[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateWithdrawAmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateWithdrawAmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateWithdrawAmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqValueTokenAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqValueTokenAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BridgeRate = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSlippage", wireType)
			}
			m.MaxSlippage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSlippage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLPInfoListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLPInfoListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLPInfoListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Liquidity = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiquidityAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFarmingSessions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFarmingSessions = bool(v != 0)
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpFeeEarning", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LpFeeEarning = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingRewardEarning", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FarmingRewardEarning = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume_24H", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume_24H = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiquidity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalLiquidity = float64(math.Float64frombits(v))
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiquidityAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalLiquidityAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpFeeEarningApy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LpFeeEarningApy = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingApy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FarmingApy = float64(math.Float64frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingSessionTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FarmingSessionTokens = append(m.FarmingSessionTokens, &TokenInfo{})
			if err := m.FarmingSessionTokens[len(m.FarmingSessionTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLPInfoListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLPInfoListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLPInfoListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpInfo = append(m.LpInfo, &LPInfo{})
			if err := m.LpInfo[len(m.LpInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawLiquidityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawLiquidityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawLiquidityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawReq", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawReq = append(m.WithdrawReq[:0], dAtA[iNdEx:postIndex]...)
			if m.WithdrawReq == nil {
				m.WithdrawReq = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedReceivedAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EstimatedReceivedAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodType", wireType)
			}
			m.MethodType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MethodType |= WithdrawMethodType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockFarmingRewardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockFarmingRewardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockFarmingRewardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockFarmingRewardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockFarmingRewardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockFarmingRewardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFarmingRewardDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFarmingRewardDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &types1.RewardClaimDetails{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLiquidityStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidityStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidityStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSendInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcSendInfo == nil {
				m.SrcSendInfo = &TransferInfo{}
			}
			if err := m.SrcSendInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstReceivedInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstReceivedInfo == nil {
				m.DstReceivedInfo = &TransferInfo{}
			}
			if err := m.DstReceivedInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.TransferHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundReason", wireType)
			}
			m.RefundReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundReason |= types.XferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.WithdrawStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodType", wireType)
			}
			m.MethodType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MethodType |= WithdrawMethodType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &TransferHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSize", wireType)
			}
			m.CurrentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &LPHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSize", wireType)
			}
			m.CurrentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardingDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardingDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardingDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amt = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardingDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardingDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardingDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsdPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsdPrice == nil {
				m.UsdPrice = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGateway
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGateway
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UsdPrice[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalCumulativeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoricalCumulativeRewards = append(m.HistoricalCumulativeRewards, &Reward{})
			if err := m.HistoricalCumulativeRewards[len(m.HistoricalCumulativeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockedCumulativeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockedCumulativeRewards = append(m.UnlockedCumulativeRewards, &Reward{})
			if err := m.UnlockedCumulativeRewards[len(m.UnlockedCumulativeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateChainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateChainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateChainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxUrlPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxUrlPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxUrlPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxUrlPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakingConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakingConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakingConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakingConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakingConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakingConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewerContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewerContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingRewardContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingRewardContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CelrContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CelrContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockStakingRewardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockStakingRewardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockStakingRewardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockStakingRewardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockStakingRewardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockStakingRewardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStakingRewardDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStakingRewardDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStakingRewardDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStakingRewardDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStakingRewardDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStakingRewardDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &types2.StakingRewardClaimInfo{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChainIds = append(m.ChainIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGateway
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGateway
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChainIds) == 0 {
					m.ChainIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChainIds = append(m.ChainIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalLiq == nil {
				m.TotalLiq = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGateway
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGateway
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TotalLiq[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInfoByTxHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInfoByTxHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInfoByTxHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetInfoByTxHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetInfoByTxHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetInfoByTxHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= CSOperation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UserCaseStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FixEventMissRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FixEventMissRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FixEventMissRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FixEventMissResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FixEventMissResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FixEventMissResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRetentionRewardsInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRetentionRewardsInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRetentionRewardsInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRetentionRewardsInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRetentionRewardsInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRetentionRewardsInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventEndTime", wireType)
			}
			m.EventEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventEndTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxReward = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTransferVolume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxTransferVolume = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentReward = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CelrUsdPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CelrUsdPrice = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimTime", wireType)
			}
			m.ClaimTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimRetentionRewardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimRetentionRewardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimRetentionRewardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimRetentionRewardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimRetentionRewardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimRetentionRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentReward = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFeeRebateInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFeeRebateInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFeeRebateInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFeeRebateInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFeeRebateInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFeeRebateInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventEndTime", wireType)
			}
			m.EventEndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventEndTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebatePortion", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.RebatePortion = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CelrUsdPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CelrUsdPrice = float64(math.Float64frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimTime", wireType)
			}
			m.ClaimTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimFeeRebateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimFeeRebateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimFeeRebateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimFeeRebateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimFeeRebateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimFeeRebateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportCurrentBlockNumberRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportCurrentBlockNumberRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportCurrentBlockNumberRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Report = append(m.Report[:0], dAtA[iNdEx:postIndex]...)
			if m.Report == nil {
				m.Report = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrentBlockNumberReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrentBlockNumberReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrentBlockNumberReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockNums == nil {
				m.BlockNums = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BlockNums[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportCurrentBlockNumberResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportCurrentBlockNumberResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportCurrentBlockNumberResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGateway
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGateway
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGateway        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGateway = fmt.Errorf("proto: unexpected end of group")
)
