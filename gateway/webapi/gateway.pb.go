// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sgn/gateway/v1/gateway.proto

package webapi

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	types "github.com/celer-network/sgn-v2/x/cbridge/types"
	types2 "github.com/celer-network/sgn-v2/x/distribution/types"
	types1 "github.com/celer-network/sgn-v2/x/farming/types"
	_ "github.com/cosmos/cosmos-sdk/types"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TransferType int32

const (
	TransferType_TRANSFER_TYPE_UNKNOWN TransferType = 0
	TransferType_TRANSFER_TYPE_SEND    TransferType = 1
	TransferType_TRANSFER_TYPE_REFUND  TransferType = 2
)

var TransferType_name = map[int32]string{
	0: "TRANSFER_TYPE_UNKNOWN",
	1: "TRANSFER_TYPE_SEND",
	2: "TRANSFER_TYPE_REFUND",
}

var TransferType_value = map[string]int32{
	"TRANSFER_TYPE_UNKNOWN": 0,
	"TRANSFER_TYPE_SEND":    1,
	"TRANSFER_TYPE_REFUND":  2,
}

func (x TransferType) String() string {
	return proto.EnumName(TransferType_name, int32(x))
}

func (TransferType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{0}
}

type LPType int32

const (
	LPType_LP_TYPE_UNKNOWN LPType = 0
	LPType_LP_TYPE_ADD     LPType = 1
	LPType_LP_TYPE_REMOVE  LPType = 2
)

var LPType_name = map[int32]string{
	0: "LP_TYPE_UNKNOWN",
	1: "LP_TYPE_ADD",
	2: "LP_TYPE_REMOVE",
}

var LPType_value = map[string]int32{
	"LP_TYPE_UNKNOWN": 0,
	"LP_TYPE_ADD":     1,
	"LP_TYPE_REMOVE":  2,
}

func (x LPType) String() string {
	return proto.EnumName(LPType_name, int32(x))
}

func (LPType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{1}
}

type WithdrawMethodType int32

const (
	WithdrawMethodType_WD_METHOD_TYPE_UNDEFINED     WithdrawMethodType = 0
	WithdrawMethodType_WD_METHOD_TYPE_ONE_RM        WithdrawMethodType = 1
	WithdrawMethodType_WD_METHOD_TYPE_ALL_IN_ONE    WithdrawMethodType = 2
	WithdrawMethodType_WD_METHOD_TYPE_STAKING_CLAIM WithdrawMethodType = 3
)

var WithdrawMethodType_name = map[int32]string{
	0: "WD_METHOD_TYPE_UNDEFINED",
	1: "WD_METHOD_TYPE_ONE_RM",
	2: "WD_METHOD_TYPE_ALL_IN_ONE",
	3: "WD_METHOD_TYPE_STAKING_CLAIM",
}

var WithdrawMethodType_value = map[string]int32{
	"WD_METHOD_TYPE_UNDEFINED":     0,
	"WD_METHOD_TYPE_ONE_RM":        1,
	"WD_METHOD_TYPE_ALL_IN_ONE":    2,
	"WD_METHOD_TYPE_STAKING_CLAIM": 3,
}

func (x WithdrawMethodType) String() string {
	return proto.EnumName(WithdrawMethodType_name, int32(x))
}

func (WithdrawMethodType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{2}
}

type ErrCode int32

const (
	ErrCode_ERROR_CODE_UNDEFINED        ErrCode = 0
	ErrCode_ERROR_CODE_COMMON           ErrCode = 500
	ErrCode_ERROR_NO_TOKEN_ON_DST_CHAIN ErrCode = 1001
	ErrCode_ERROR_NO_TOKEN_ON_SRC_CHAIN ErrCode = 1002
)

var ErrCode_name = map[int32]string{
	0:    "ERROR_CODE_UNDEFINED",
	500:  "ERROR_CODE_COMMON",
	1001: "ERROR_NO_TOKEN_ON_DST_CHAIN",
	1002: "ERROR_NO_TOKEN_ON_SRC_CHAIN",
}

var ErrCode_value = map[string]int32{
	"ERROR_CODE_UNDEFINED":        0,
	"ERROR_CODE_COMMON":           500,
	"ERROR_NO_TOKEN_ON_DST_CHAIN": 1001,
	"ERROR_NO_TOKEN_ON_SRC_CHAIN": 1002,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{3}
}

type GetCampaignScoresRequest struct {
	Date       uint32 `protobuf:"varint,1,opt,name=date,proto3" json:"date,omitempty"`
	BeginBlock uint64 `protobuf:"varint,2,opt,name=begin_block,json=beginBlock,proto3" json:"begin_block,omitempty"`
	EndBlock   uint64 `protobuf:"varint,3,opt,name=end_block,json=endBlock,proto3" json:"end_block,omitempty"`
}

func (m *GetCampaignScoresRequest) Reset()         { *m = GetCampaignScoresRequest{} }
func (m *GetCampaignScoresRequest) String() string { return proto.CompactTextString(m) }
func (*GetCampaignScoresRequest) ProtoMessage()    {}
func (*GetCampaignScoresRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{0}
}
func (m *GetCampaignScoresRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCampaignScoresRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCampaignScoresRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCampaignScoresRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCampaignScoresRequest.Merge(m, src)
}
func (m *GetCampaignScoresRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCampaignScoresRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCampaignScoresRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCampaignScoresRequest proto.InternalMessageInfo

func (m *GetCampaignScoresRequest) GetDate() uint32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *GetCampaignScoresRequest) GetBeginBlock() uint64 {
	if m != nil {
		return m.BeginBlock
	}
	return 0
}

func (m *GetCampaignScoresRequest) GetEndBlock() uint64 {
	if m != nil {
		return m.EndBlock
	}
	return 0
}

type GetCampaignScoresResponse struct {
	Scores []*CampaignScore `protobuf:"bytes,1,rep,name=scores,proto3" json:"scores,omitempty"`
	Err    *ErrMsg          `protobuf:"bytes,2,opt,name=err,proto3" json:"err,omitempty"`
	Begin  uint64           `protobuf:"varint,3,opt,name=begin,proto3" json:"begin,omitempty"`
}

func (m *GetCampaignScoresResponse) Reset()         { *m = GetCampaignScoresResponse{} }
func (m *GetCampaignScoresResponse) String() string { return proto.CompactTextString(m) }
func (*GetCampaignScoresResponse) ProtoMessage()    {}
func (*GetCampaignScoresResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{1}
}
func (m *GetCampaignScoresResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCampaignScoresResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCampaignScoresResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCampaignScoresResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCampaignScoresResponse.Merge(m, src)
}
func (m *GetCampaignScoresResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCampaignScoresResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCampaignScoresResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCampaignScoresResponse proto.InternalMessageInfo

func (m *GetCampaignScoresResponse) GetScores() []*CampaignScore {
	if m != nil {
		return m.Scores
	}
	return nil
}

func (m *GetCampaignScoresResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetCampaignScoresResponse) GetBegin() uint64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

type CampaignScore struct {
	UsrAddr string `protobuf:"bytes,1,opt,name=usr_addr,json=usrAddr,proto3" json:"usr_addr,omitempty"`
	Score   uint64 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *CampaignScore) Reset()         { *m = CampaignScore{} }
func (m *CampaignScore) String() string { return proto.CompactTextString(m) }
func (*CampaignScore) ProtoMessage()    {}
func (*CampaignScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{2}
}
func (m *CampaignScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CampaignScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CampaignScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CampaignScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CampaignScore.Merge(m, src)
}
func (m *CampaignScore) XXX_Size() int {
	return m.Size()
}
func (m *CampaignScore) XXX_DiscardUnknown() {
	xxx_messageInfo_CampaignScore.DiscardUnknown(m)
}

var xxx_messageInfo_CampaignScore proto.InternalMessageInfo

func (m *CampaignScore) GetUsrAddr() string {
	if m != nil {
		return m.UsrAddr
	}
	return ""
}

func (m *CampaignScore) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

type QueryLiquidityStatusResponse struct {
	Err         *ErrMsg               `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Status      types.LPHistoryStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sgn.cbridge.v1.LPHistoryStatus" json:"status,omitempty"`
	WdOnchain   []byte                `protobuf:"bytes,3,opt,name=wd_onchain,json=wdOnchain,proto3" json:"wd_onchain,omitempty"`
	SortedSigs  [][]byte              `protobuf:"bytes,4,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	Signers     [][]byte              `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
	Powers      [][]byte              `protobuf:"bytes,6,rep,name=powers,proto3" json:"powers,omitempty"`
	BlockTxLink string                `protobuf:"bytes,7,opt,name=block_tx_link,json=blockTxLink,proto3" json:"block_tx_link,omitempty"`
	BlockDelay  uint32                `protobuf:"varint,8,opt,name=block_delay,json=blockDelay,proto3" json:"block_delay,omitempty"`
}

func (m *QueryLiquidityStatusResponse) Reset()         { *m = QueryLiquidityStatusResponse{} }
func (m *QueryLiquidityStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidityStatusResponse) ProtoMessage()    {}
func (*QueryLiquidityStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{3}
}
func (m *QueryLiquidityStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidityStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidityStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidityStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidityStatusResponse.Merge(m, src)
}
func (m *QueryLiquidityStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidityStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidityStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidityStatusResponse proto.InternalMessageInfo

func (m *QueryLiquidityStatusResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetStatus() types.LPHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.LPHistoryStatus_LP_UNKNOWN
}

func (m *QueryLiquidityStatusResponse) GetWdOnchain() []byte {
	if m != nil {
		return m.WdOnchain
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetSortedSigs() [][]byte {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetSigners() [][]byte {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetPowers() [][]byte {
	if m != nil {
		return m.Powers
	}
	return nil
}

func (m *QueryLiquidityStatusResponse) GetBlockTxLink() string {
	if m != nil {
		return m.BlockTxLink
	}
	return ""
}

func (m *QueryLiquidityStatusResponse) GetBlockDelay() uint32 {
	if m != nil {
		return m.BlockDelay
	}
	return 0
}

type Chain struct {
	Id             uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name           string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon           string `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
	BlockDelay     uint32 `protobuf:"varint,4,opt,name=block_delay,json=blockDelay,proto3" json:"block_delay,omitempty"`
	GasTokenSymbol string `protobuf:"bytes,5,opt,name=gas_token_symbol,json=gasTokenSymbol,proto3" json:"gas_token_symbol,omitempty"`
	ExploreUrl     string `protobuf:"bytes,6,opt,name=explore_url,json=exploreUrl,proto3" json:"explore_url,omitempty"`
	RpcUrl         string `protobuf:"bytes,7,opt,name=rpc_url,json=rpcUrl,proto3" json:"rpc_url,omitempty"`
	ContractAddr   string `protobuf:"bytes,8,opt,name=contract_addr,json=contractAddr,proto3" json:"contract_addr,omitempty"`
}

func (m *Chain) Reset()         { *m = Chain{} }
func (m *Chain) String() string { return proto.CompactTextString(m) }
func (*Chain) ProtoMessage()    {}
func (*Chain) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{4}
}
func (m *Chain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Chain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Chain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Chain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Chain.Merge(m, src)
}
func (m *Chain) XXX_Size() int {
	return m.Size()
}
func (m *Chain) XXX_DiscardUnknown() {
	xxx_messageInfo_Chain.DiscardUnknown(m)
}

var xxx_messageInfo_Chain proto.InternalMessageInfo

func (m *Chain) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Chain) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Chain) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *Chain) GetBlockDelay() uint32 {
	if m != nil {
		return m.BlockDelay
	}
	return 0
}

func (m *Chain) GetGasTokenSymbol() string {
	if m != nil {
		return m.GasTokenSymbol
	}
	return ""
}

func (m *Chain) GetExploreUrl() string {
	if m != nil {
		return m.ExploreUrl
	}
	return ""
}

func (m *Chain) GetRpcUrl() string {
	if m != nil {
		return m.RpcUrl
	}
	return ""
}

func (m *Chain) GetContractAddr() string {
	if m != nil {
		return m.ContractAddr
	}
	return ""
}

type ChainTokenInfo struct {
	Token []*TokenInfo `protobuf:"bytes,1,rep,name=token,proto3" json:"token,omitempty"`
}

func (m *ChainTokenInfo) Reset()         { *m = ChainTokenInfo{} }
func (m *ChainTokenInfo) String() string { return proto.CompactTextString(m) }
func (*ChainTokenInfo) ProtoMessage()    {}
func (*ChainTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{5}
}
func (m *ChainTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainTokenInfo.Merge(m, src)
}
func (m *ChainTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChainTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChainTokenInfo proto.InternalMessageInfo

func (m *ChainTokenInfo) GetToken() []*TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

type TokenInfo struct {
	Token *types.Token `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Name  string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Icon  string       `protobuf:"bytes,3,opt,name=icon,proto3" json:"icon,omitempty"`
}

func (m *TokenInfo) Reset()         { *m = TokenInfo{} }
func (m *TokenInfo) String() string { return proto.CompactTextString(m) }
func (*TokenInfo) ProtoMessage()    {}
func (*TokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{6}
}
func (m *TokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenInfo.Merge(m, src)
}
func (m *TokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *TokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TokenInfo proto.InternalMessageInfo

func (m *TokenInfo) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *TokenInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TokenInfo) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

type TransferInfo struct {
	Chain  *Chain       `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token  *types.Token `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Amount string       `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *TransferInfo) Reset()         { *m = TransferInfo{} }
func (m *TransferInfo) String() string { return proto.CompactTextString(m) }
func (*TransferInfo) ProtoMessage()    {}
func (*TransferInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{7}
}
func (m *TransferInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferInfo.Merge(m, src)
}
func (m *TransferInfo) XXX_Size() int {
	return m.Size()
}
func (m *TransferInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TransferInfo proto.InternalMessageInfo

func (m *TransferInfo) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *TransferInfo) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *TransferInfo) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type GetTransferStatusRequest struct {
	TransferId string `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
}

func (m *GetTransferStatusRequest) Reset()         { *m = GetTransferStatusRequest{} }
func (m *GetTransferStatusRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransferStatusRequest) ProtoMessage()    {}
func (*GetTransferStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{8}
}
func (m *GetTransferStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferStatusRequest.Merge(m, src)
}
func (m *GetTransferStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferStatusRequest proto.InternalMessageInfo

func (m *GetTransferStatusRequest) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

type GetTransferStatusResponse struct {
	Err            *ErrMsg                     `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Status         types.TransferHistoryStatus `protobuf:"varint,2,opt,name=status,proto3,enum=sgn.cbridge.v1.TransferHistoryStatus" json:"status,omitempty"`
	WdOnchain      []byte                      `protobuf:"bytes,3,opt,name=wd_onchain,json=wdOnchain,proto3" json:"wd_onchain,omitempty"`
	SortedSigs     [][]byte                    `protobuf:"bytes,4,rep,name=sorted_sigs,json=sortedSigs,proto3" json:"sorted_sigs,omitempty"`
	Signers        [][]byte                    `protobuf:"bytes,5,rep,name=signers,proto3" json:"signers,omitempty"`
	Powers         [][]byte                    `protobuf:"bytes,6,rep,name=powers,proto3" json:"powers,omitempty"`
	RefundReason   types.XferStatus            `protobuf:"varint,7,opt,name=refund_reason,json=refundReason,proto3,enum=sgn.cbridge.v1.XferStatus" json:"refund_reason,omitempty"`
	BlockDelay     uint32                      `protobuf:"varint,8,opt,name=block_delay,json=blockDelay,proto3" json:"block_delay,omitempty"`
	SrcBlockTxLink string                      `protobuf:"bytes,9,opt,name=src_block_tx_link,json=srcBlockTxLink,proto3" json:"src_block_tx_link,omitempty"`
	DstBlockTxLink string                      `protobuf:"bytes,10,opt,name=dst_block_tx_link,json=dstBlockTxLink,proto3" json:"dst_block_tx_link,omitempty"`
}

func (m *GetTransferStatusResponse) Reset()         { *m = GetTransferStatusResponse{} }
func (m *GetTransferStatusResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransferStatusResponse) ProtoMessage()    {}
func (*GetTransferStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{9}
}
func (m *GetTransferStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferStatusResponse.Merge(m, src)
}
func (m *GetTransferStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferStatusResponse proto.InternalMessageInfo

func (m *GetTransferStatusResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTransferStatusResponse) GetStatus() types.TransferHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.TransferHistoryStatus_TRANSFER_UNKNOWN
}

func (m *GetTransferStatusResponse) GetWdOnchain() []byte {
	if m != nil {
		return m.WdOnchain
	}
	return nil
}

func (m *GetTransferStatusResponse) GetSortedSigs() [][]byte {
	if m != nil {
		return m.SortedSigs
	}
	return nil
}

func (m *GetTransferStatusResponse) GetSigners() [][]byte {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *GetTransferStatusResponse) GetPowers() [][]byte {
	if m != nil {
		return m.Powers
	}
	return nil
}

func (m *GetTransferStatusResponse) GetRefundReason() types.XferStatus {
	if m != nil {
		return m.RefundReason
	}
	return types.XferStatus_UNKNOWN
}

func (m *GetTransferStatusResponse) GetBlockDelay() uint32 {
	if m != nil {
		return m.BlockDelay
	}
	return 0
}

func (m *GetTransferStatusResponse) GetSrcBlockTxLink() string {
	if m != nil {
		return m.SrcBlockTxLink
	}
	return ""
}

func (m *GetTransferStatusResponse) GetDstBlockTxLink() string {
	if m != nil {
		return m.DstBlockTxLink
	}
	return ""
}

type GetTransferConfigsRequest struct {
}

func (m *GetTransferConfigsRequest) Reset()         { *m = GetTransferConfigsRequest{} }
func (m *GetTransferConfigsRequest) String() string { return proto.CompactTextString(m) }
func (*GetTransferConfigsRequest) ProtoMessage()    {}
func (*GetTransferConfigsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{10}
}
func (m *GetTransferConfigsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferConfigsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferConfigsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferConfigsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferConfigsRequest.Merge(m, src)
}
func (m *GetTransferConfigsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferConfigsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferConfigsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferConfigsRequest proto.InternalMessageInfo

type GetTransferConfigsResponse struct {
	Err                       *ErrMsg                    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Chains                    []*Chain                   `protobuf:"bytes,2,rep,name=chains,proto3" json:"chains,omitempty"`
	ChainToken                map[uint32]*ChainTokenInfo `protobuf:"bytes,3,rep,name=chain_token,json=chainToken,proto3" json:"chain_token,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FarmingRewardContractAddr string                     `protobuf:"bytes,4,opt,name=farming_reward_contract_addr,json=farmingRewardContractAddr,proto3" json:"farming_reward_contract_addr,omitempty"`
}

func (m *GetTransferConfigsResponse) Reset()         { *m = GetTransferConfigsResponse{} }
func (m *GetTransferConfigsResponse) String() string { return proto.CompactTextString(m) }
func (*GetTransferConfigsResponse) ProtoMessage()    {}
func (*GetTransferConfigsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{11}
}
func (m *GetTransferConfigsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTransferConfigsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTransferConfigsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTransferConfigsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTransferConfigsResponse.Merge(m, src)
}
func (m *GetTransferConfigsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTransferConfigsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTransferConfigsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTransferConfigsResponse proto.InternalMessageInfo

func (m *GetTransferConfigsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetChains() []*Chain {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetChainToken() map[uint32]*ChainTokenInfo {
	if m != nil {
		return m.ChainToken
	}
	return nil
}

func (m *GetTransferConfigsResponse) GetFarmingRewardContractAddr() string {
	if m != nil {
		return m.FarmingRewardContractAddr
	}
	return ""
}

type GetTokenInfoRequest struct {
	ChainId     uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TokenSymbol string `protobuf:"bytes,2,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
}

func (m *GetTokenInfoRequest) Reset()         { *m = GetTokenInfoRequest{} }
func (m *GetTokenInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetTokenInfoRequest) ProtoMessage()    {}
func (*GetTokenInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{12}
}
func (m *GetTokenInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenInfoRequest.Merge(m, src)
}
func (m *GetTokenInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenInfoRequest proto.InternalMessageInfo

func (m *GetTokenInfoRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *GetTokenInfoRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

type GetTokenInfoResponse struct {
	Err       *ErrMsg    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	TokenInfo *TokenInfo `protobuf:"bytes,2,opt,name=token_info,json=tokenInfo,proto3" json:"token_info,omitempty"`
}

func (m *GetTokenInfoResponse) Reset()         { *m = GetTokenInfoResponse{} }
func (m *GetTokenInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetTokenInfoResponse) ProtoMessage()    {}
func (*GetTokenInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{13}
}
func (m *GetTokenInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTokenInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTokenInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTokenInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTokenInfoResponse.Merge(m, src)
}
func (m *GetTokenInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTokenInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTokenInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTokenInfoResponse proto.InternalMessageInfo

func (m *GetTokenInfoResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTokenInfoResponse) GetTokenInfo() *TokenInfo {
	if m != nil {
		return m.TokenInfo
	}
	return nil
}

type EstimateAmtRequest struct {
	SrcChainId        uint32 `protobuf:"varint,1,opt,name=src_chain_id,json=srcChainId,proto3" json:"src_chain_id,omitempty"`
	DstChainId        uint32 `protobuf:"varint,2,opt,name=dst_chain_id,json=dstChainId,proto3" json:"dst_chain_id,omitempty"`
	TokenSymbol       string `protobuf:"bytes,3,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
	Amt               string `protobuf:"bytes,4,opt,name=amt,proto3" json:"amt,omitempty"`
	UsrAddr           string `protobuf:"bytes,5,opt,name=usr_addr,json=usrAddr,proto3" json:"usr_addr,omitempty"`
	SlippageTolerance uint32 `protobuf:"varint,6,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
}

func (m *EstimateAmtRequest) Reset()         { *m = EstimateAmtRequest{} }
func (m *EstimateAmtRequest) String() string { return proto.CompactTextString(m) }
func (*EstimateAmtRequest) ProtoMessage()    {}
func (*EstimateAmtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{14}
}
func (m *EstimateAmtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateAmtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateAmtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateAmtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateAmtRequest.Merge(m, src)
}
func (m *EstimateAmtRequest) XXX_Size() int {
	return m.Size()
}
func (m *EstimateAmtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateAmtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateAmtRequest proto.InternalMessageInfo

func (m *EstimateAmtRequest) GetSrcChainId() uint32 {
	if m != nil {
		return m.SrcChainId
	}
	return 0
}

func (m *EstimateAmtRequest) GetDstChainId() uint32 {
	if m != nil {
		return m.DstChainId
	}
	return 0
}

func (m *EstimateAmtRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

func (m *EstimateAmtRequest) GetAmt() string {
	if m != nil {
		return m.Amt
	}
	return ""
}

func (m *EstimateAmtRequest) GetUsrAddr() string {
	if m != nil {
		return m.UsrAddr
	}
	return ""
}

func (m *EstimateAmtRequest) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

type EstimateAmtResponse struct {
	Err               *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	EqValueTokenAmt   string  `protobuf:"bytes,2,opt,name=eq_value_token_amt,json=eqValueTokenAmt,proto3" json:"eq_value_token_amt,omitempty"`
	BridgeRate        float32 `protobuf:"fixed32,3,opt,name=bridge_rate,json=bridgeRate,proto3" json:"bridge_rate,omitempty"`
	PercFee           string  `protobuf:"bytes,4,opt,name=perc_fee,json=percFee,proto3" json:"perc_fee,omitempty"`
	BaseFee           string  `protobuf:"bytes,7,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
	SlippageTolerance uint32  `protobuf:"varint,5,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	MaxSlippage       uint32  `protobuf:"varint,6,opt,name=max_slippage,json=maxSlippage,proto3" json:"max_slippage,omitempty"`
}

func (m *EstimateAmtResponse) Reset()         { *m = EstimateAmtResponse{} }
func (m *EstimateAmtResponse) String() string { return proto.CompactTextString(m) }
func (*EstimateAmtResponse) ProtoMessage()    {}
func (*EstimateAmtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{15}
}
func (m *EstimateAmtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateAmtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateAmtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateAmtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateAmtResponse.Merge(m, src)
}
func (m *EstimateAmtResponse) XXX_Size() int {
	return m.Size()
}
func (m *EstimateAmtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateAmtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateAmtResponse proto.InternalMessageInfo

func (m *EstimateAmtResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *EstimateAmtResponse) GetEqValueTokenAmt() string {
	if m != nil {
		return m.EqValueTokenAmt
	}
	return ""
}

func (m *EstimateAmtResponse) GetBridgeRate() float32 {
	if m != nil {
		return m.BridgeRate
	}
	return 0
}

func (m *EstimateAmtResponse) GetPercFee() string {
	if m != nil {
		return m.PercFee
	}
	return ""
}

func (m *EstimateAmtResponse) GetBaseFee() string {
	if m != nil {
		return m.BaseFee
	}
	return ""
}

func (m *EstimateAmtResponse) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *EstimateAmtResponse) GetMaxSlippage() uint32 {
	if m != nil {
		return m.MaxSlippage
	}
	return 0
}

type WithdrawInfo struct {
	ChainId           uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Amount            string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	SlippageTolerance uint32 `protobuf:"varint,3,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
}

func (m *WithdrawInfo) Reset()         { *m = WithdrawInfo{} }
func (m *WithdrawInfo) String() string { return proto.CompactTextString(m) }
func (*WithdrawInfo) ProtoMessage()    {}
func (*WithdrawInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{16}
}
func (m *WithdrawInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawInfo.Merge(m, src)
}
func (m *WithdrawInfo) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawInfo proto.InternalMessageInfo

func (m *WithdrawInfo) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *WithdrawInfo) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *WithdrawInfo) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

type EstimateWithdrawAmtRequest struct {
	SrcWithdraws []*WithdrawInfo `protobuf:"bytes,1,rep,name=src_withdraws,json=srcWithdraws,proto3" json:"src_withdraws,omitempty"`
	DstChainId   uint32          `protobuf:"varint,2,opt,name=dst_chain_id,json=dstChainId,proto3" json:"dst_chain_id,omitempty"`
	TokenSymbol  string          `protobuf:"bytes,3,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
	UsrAddr      string          `protobuf:"bytes,4,opt,name=usr_addr,json=usrAddr,proto3" json:"usr_addr,omitempty"`
}

func (m *EstimateWithdrawAmtRequest) Reset()         { *m = EstimateWithdrawAmtRequest{} }
func (m *EstimateWithdrawAmtRequest) String() string { return proto.CompactTextString(m) }
func (*EstimateWithdrawAmtRequest) ProtoMessage()    {}
func (*EstimateWithdrawAmtRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{17}
}
func (m *EstimateWithdrawAmtRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateWithdrawAmtRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateWithdrawAmtRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateWithdrawAmtRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateWithdrawAmtRequest.Merge(m, src)
}
func (m *EstimateWithdrawAmtRequest) XXX_Size() int {
	return m.Size()
}
func (m *EstimateWithdrawAmtRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateWithdrawAmtRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateWithdrawAmtRequest proto.InternalMessageInfo

func (m *EstimateWithdrawAmtRequest) GetSrcWithdraws() []*WithdrawInfo {
	if m != nil {
		return m.SrcWithdraws
	}
	return nil
}

func (m *EstimateWithdrawAmtRequest) GetDstChainId() uint32 {
	if m != nil {
		return m.DstChainId
	}
	return 0
}

func (m *EstimateWithdrawAmtRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

func (m *EstimateWithdrawAmtRequest) GetUsrAddr() string {
	if m != nil {
		return m.UsrAddr
	}
	return ""
}

type EstimateWithdrawAmtResponse struct {
	Err    *ErrMsg                         `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	ReqAmt map[uint32]*EstimateWithdrawAmt `protobuf:"bytes,2,rep,name=req_amt,json=reqAmt,proto3" json:"req_amt,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EstimateWithdrawAmtResponse) Reset()         { *m = EstimateWithdrawAmtResponse{} }
func (m *EstimateWithdrawAmtResponse) String() string { return proto.CompactTextString(m) }
func (*EstimateWithdrawAmtResponse) ProtoMessage()    {}
func (*EstimateWithdrawAmtResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{18}
}
func (m *EstimateWithdrawAmtResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateWithdrawAmtResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateWithdrawAmtResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateWithdrawAmtResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateWithdrawAmtResponse.Merge(m, src)
}
func (m *EstimateWithdrawAmtResponse) XXX_Size() int {
	return m.Size()
}
func (m *EstimateWithdrawAmtResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateWithdrawAmtResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateWithdrawAmtResponse proto.InternalMessageInfo

func (m *EstimateWithdrawAmtResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *EstimateWithdrawAmtResponse) GetReqAmt() map[uint32]*EstimateWithdrawAmt {
	if m != nil {
		return m.ReqAmt
	}
	return nil
}

type EstimateWithdrawAmt struct {
	EqValueTokenAmt   string  `protobuf:"bytes,1,opt,name=eq_value_token_amt,json=eqValueTokenAmt,proto3" json:"eq_value_token_amt,omitempty"`
	BridgeRate        float32 `protobuf:"fixed32,2,opt,name=bridge_rate,json=bridgeRate,proto3" json:"bridge_rate,omitempty"`
	PercFee           string  `protobuf:"bytes,3,opt,name=perc_fee,json=percFee,proto3" json:"perc_fee,omitempty"`
	BaseFee           string  `protobuf:"bytes,4,opt,name=base_fee,json=baseFee,proto3" json:"base_fee,omitempty"`
	SlippageTolerance uint32  `protobuf:"varint,5,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	MaxSlippage       uint32  `protobuf:"varint,6,opt,name=max_slippage,json=maxSlippage,proto3" json:"max_slippage,omitempty"`
}

func (m *EstimateWithdrawAmt) Reset()         { *m = EstimateWithdrawAmt{} }
func (m *EstimateWithdrawAmt) String() string { return proto.CompactTextString(m) }
func (*EstimateWithdrawAmt) ProtoMessage()    {}
func (*EstimateWithdrawAmt) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{19}
}
func (m *EstimateWithdrawAmt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EstimateWithdrawAmt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EstimateWithdrawAmt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EstimateWithdrawAmt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EstimateWithdrawAmt.Merge(m, src)
}
func (m *EstimateWithdrawAmt) XXX_Size() int {
	return m.Size()
}
func (m *EstimateWithdrawAmt) XXX_DiscardUnknown() {
	xxx_messageInfo_EstimateWithdrawAmt.DiscardUnknown(m)
}

var xxx_messageInfo_EstimateWithdrawAmt proto.InternalMessageInfo

func (m *EstimateWithdrawAmt) GetEqValueTokenAmt() string {
	if m != nil {
		return m.EqValueTokenAmt
	}
	return ""
}

func (m *EstimateWithdrawAmt) GetBridgeRate() float32 {
	if m != nil {
		return m.BridgeRate
	}
	return 0
}

func (m *EstimateWithdrawAmt) GetPercFee() string {
	if m != nil {
		return m.PercFee
	}
	return ""
}

func (m *EstimateWithdrawAmt) GetBaseFee() string {
	if m != nil {
		return m.BaseFee
	}
	return ""
}

func (m *EstimateWithdrawAmt) GetSlippageTolerance() uint32 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *EstimateWithdrawAmt) GetMaxSlippage() uint32 {
	if m != nil {
		return m.MaxSlippage
	}
	return 0
}

type MarkTransferRequest struct {
	TransferId         string        `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	SrcSendInfo        *TransferInfo `protobuf:"bytes,2,opt,name=src_send_info,json=srcSendInfo,proto3" json:"src_send_info,omitempty"`
	DstMinReceivedInfo *TransferInfo `protobuf:"bytes,3,opt,name=dst_min_received_info,json=dstMinReceivedInfo,proto3" json:"dst_min_received_info,omitempty"`
	Addr               string        `protobuf:"bytes,4,opt,name=addr,proto3" json:"addr,omitempty"`
	SrcTxHash          string        `protobuf:"bytes,5,opt,name=src_tx_hash,json=srcTxHash,proto3" json:"src_tx_hash,omitempty"`
	Type               TransferType  `protobuf:"varint,6,opt,name=type,proto3,enum=sgn.gateway.v1.TransferType" json:"type,omitempty"`
}

func (m *MarkTransferRequest) Reset()         { *m = MarkTransferRequest{} }
func (m *MarkTransferRequest) String() string { return proto.CompactTextString(m) }
func (*MarkTransferRequest) ProtoMessage()    {}
func (*MarkTransferRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{20}
}
func (m *MarkTransferRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkTransferRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkTransferRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkTransferRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkTransferRequest.Merge(m, src)
}
func (m *MarkTransferRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkTransferRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkTransferRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkTransferRequest proto.InternalMessageInfo

func (m *MarkTransferRequest) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

func (m *MarkTransferRequest) GetSrcSendInfo() *TransferInfo {
	if m != nil {
		return m.SrcSendInfo
	}
	return nil
}

func (m *MarkTransferRequest) GetDstMinReceivedInfo() *TransferInfo {
	if m != nil {
		return m.DstMinReceivedInfo
	}
	return nil
}

func (m *MarkTransferRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *MarkTransferRequest) GetSrcTxHash() string {
	if m != nil {
		return m.SrcTxHash
	}
	return ""
}

func (m *MarkTransferRequest) GetType() TransferType {
	if m != nil {
		return m.Type
	}
	return TransferType_TRANSFER_TYPE_UNKNOWN
}

type MarkTransferResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *MarkTransferResponse) Reset()         { *m = MarkTransferResponse{} }
func (m *MarkTransferResponse) String() string { return proto.CompactTextString(m) }
func (*MarkTransferResponse) ProtoMessage()    {}
func (*MarkTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{21}
}
func (m *MarkTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkTransferResponse.Merge(m, src)
}
func (m *MarkTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkTransferResponse proto.InternalMessageInfo

func (m *MarkTransferResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetLPInfoListRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetLPInfoListRequest) Reset()         { *m = GetLPInfoListRequest{} }
func (m *GetLPInfoListRequest) String() string { return proto.CompactTextString(m) }
func (*GetLPInfoListRequest) ProtoMessage()    {}
func (*GetLPInfoListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{22}
}
func (m *GetLPInfoListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLPInfoListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLPInfoListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLPInfoListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLPInfoListRequest.Merge(m, src)
}
func (m *GetLPInfoListRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLPInfoListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLPInfoListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLPInfoListRequest proto.InternalMessageInfo

func (m *GetLPInfoListRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type LPInfo struct {
	Chain                *Chain     `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token                *TokenInfo `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Liquidity            float64    `protobuf:"fixed64,3,opt,name=liquidity,proto3" json:"liquidity,omitempty"`
	LiquidityAmt         string     `protobuf:"bytes,4,opt,name=liquidity_amt,json=liquidityAmt,proto3" json:"liquidity_amt,omitempty"`
	HasFarmingSessions   bool       `protobuf:"varint,5,opt,name=has_farming_sessions,json=hasFarmingSessions,proto3" json:"has_farming_sessions,omitempty"`
	LpFeeEarning         float64    `protobuf:"fixed64,6,opt,name=lp_fee_earning,json=lpFeeEarning,proto3" json:"lp_fee_earning,omitempty"`
	FarmingRewardEarning float64    `protobuf:"fixed64,7,opt,name=farming_reward_earning,json=farmingRewardEarning,proto3" json:"farming_reward_earning,omitempty"`
	Volume_24H           float64    `protobuf:"fixed64,8,opt,name=volume_24h,json=volume24h,proto3" json:"volume_24h,omitempty"`
	TotalLiquidity       float64    `protobuf:"fixed64,9,opt,name=total_liquidity,json=totalLiquidity,proto3" json:"total_liquidity,omitempty"`
	TotalLiquidityAmt    string     `protobuf:"bytes,10,opt,name=total_liquidity_amt,json=totalLiquidityAmt,proto3" json:"total_liquidity_amt,omitempty"`
	LpFeeEarningApy      float64    `protobuf:"fixed64,11,opt,name=lp_fee_earning_apy,json=lpFeeEarningApy,proto3" json:"lp_fee_earning_apy,omitempty"`
	FarmingApy           float64    `protobuf:"fixed64,12,opt,name=farming_apy,json=farmingApy,proto3" json:"farming_apy,omitempty"`
}

func (m *LPInfo) Reset()         { *m = LPInfo{} }
func (m *LPInfo) String() string { return proto.CompactTextString(m) }
func (*LPInfo) ProtoMessage()    {}
func (*LPInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{23}
}
func (m *LPInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPInfo.Merge(m, src)
}
func (m *LPInfo) XXX_Size() int {
	return m.Size()
}
func (m *LPInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LPInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LPInfo proto.InternalMessageInfo

func (m *LPInfo) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *LPInfo) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *LPInfo) GetLiquidity() float64 {
	if m != nil {
		return m.Liquidity
	}
	return 0
}

func (m *LPInfo) GetLiquidityAmt() string {
	if m != nil {
		return m.LiquidityAmt
	}
	return ""
}

func (m *LPInfo) GetHasFarmingSessions() bool {
	if m != nil {
		return m.HasFarmingSessions
	}
	return false
}

func (m *LPInfo) GetLpFeeEarning() float64 {
	if m != nil {
		return m.LpFeeEarning
	}
	return 0
}

func (m *LPInfo) GetFarmingRewardEarning() float64 {
	if m != nil {
		return m.FarmingRewardEarning
	}
	return 0
}

func (m *LPInfo) GetVolume_24H() float64 {
	if m != nil {
		return m.Volume_24H
	}
	return 0
}

func (m *LPInfo) GetTotalLiquidity() float64 {
	if m != nil {
		return m.TotalLiquidity
	}
	return 0
}

func (m *LPInfo) GetTotalLiquidityAmt() string {
	if m != nil {
		return m.TotalLiquidityAmt
	}
	return ""
}

func (m *LPInfo) GetLpFeeEarningApy() float64 {
	if m != nil {
		return m.LpFeeEarningApy
	}
	return 0
}

func (m *LPInfo) GetFarmingApy() float64 {
	if m != nil {
		return m.FarmingApy
	}
	return 0
}

type GetLPInfoListResponse struct {
	Err    *ErrMsg   `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	LpInfo []*LPInfo `protobuf:"bytes,2,rep,name=lp_info,json=lpInfo,proto3" json:"lp_info,omitempty"`
}

func (m *GetLPInfoListResponse) Reset()         { *m = GetLPInfoListResponse{} }
func (m *GetLPInfoListResponse) String() string { return proto.CompactTextString(m) }
func (*GetLPInfoListResponse) ProtoMessage()    {}
func (*GetLPInfoListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{24}
}
func (m *GetLPInfoListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLPInfoListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLPInfoListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLPInfoListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLPInfoListResponse.Merge(m, src)
}
func (m *GetLPInfoListResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLPInfoListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLPInfoListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLPInfoListResponse proto.InternalMessageInfo

func (m *GetLPInfoListResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetLPInfoListResponse) GetLpInfo() []*LPInfo {
	if m != nil {
		return m.LpInfo
	}
	return nil
}

type WithdrawLiquidityRequest struct {
	WithdrawReq          []byte             `protobuf:"bytes,1,opt,name=withdraw_req,json=withdrawReq,proto3" json:"withdraw_req,omitempty"`
	Sig                  []byte             `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
	EstimatedReceivedAmt string             `protobuf:"bytes,3,opt,name=estimated_received_amt,json=estimatedReceivedAmt,proto3" json:"estimated_received_amt,omitempty"`
	MethodType           WithdrawMethodType `protobuf:"varint,4,opt,name=method_type,json=methodType,proto3,enum=sgn.gateway.v1.WithdrawMethodType" json:"method_type,omitempty"`
}

func (m *WithdrawLiquidityRequest) Reset()         { *m = WithdrawLiquidityRequest{} }
func (m *WithdrawLiquidityRequest) String() string { return proto.CompactTextString(m) }
func (*WithdrawLiquidityRequest) ProtoMessage()    {}
func (*WithdrawLiquidityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{25}
}
func (m *WithdrawLiquidityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawLiquidityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawLiquidityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawLiquidityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawLiquidityRequest.Merge(m, src)
}
func (m *WithdrawLiquidityRequest) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawLiquidityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawLiquidityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawLiquidityRequest proto.InternalMessageInfo

func (m *WithdrawLiquidityRequest) GetWithdrawReq() []byte {
	if m != nil {
		return m.WithdrawReq
	}
	return nil
}

func (m *WithdrawLiquidityRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *WithdrawLiquidityRequest) GetEstimatedReceivedAmt() string {
	if m != nil {
		return m.EstimatedReceivedAmt
	}
	return ""
}

func (m *WithdrawLiquidityRequest) GetMethodType() WithdrawMethodType {
	if m != nil {
		return m.MethodType
	}
	return WithdrawMethodType_WD_METHOD_TYPE_UNDEFINED
}

type WithdrawLiquidityResponse struct {
	Err    *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	SeqNum uint64  `protobuf:"varint,2,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
}

func (m *WithdrawLiquidityResponse) Reset()         { *m = WithdrawLiquidityResponse{} }
func (m *WithdrawLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*WithdrawLiquidityResponse) ProtoMessage()    {}
func (*WithdrawLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{26}
}
func (m *WithdrawLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WithdrawLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WithdrawLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WithdrawLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WithdrawLiquidityResponse.Merge(m, src)
}
func (m *WithdrawLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *WithdrawLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WithdrawLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WithdrawLiquidityResponse proto.InternalMessageInfo

func (m *WithdrawLiquidityResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *WithdrawLiquidityResponse) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

type MarkLiquidityRequest struct {
	LpAddr    string `protobuf:"bytes,1,opt,name=lp_addr,json=lpAddr,proto3" json:"lp_addr,omitempty"`
	Amt       string `protobuf:"bytes,2,opt,name=amt,proto3" json:"amt,omitempty"`
	TokenAddr string `protobuf:"bytes,3,opt,name=token_addr,json=tokenAddr,proto3" json:"token_addr,omitempty"`
	ChainId   uint32 `protobuf:"varint,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	SeqNum    uint64 `protobuf:"varint,5,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	TxHash    string `protobuf:"bytes,6,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	Type      LPType `protobuf:"varint,7,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
}

func (m *MarkLiquidityRequest) Reset()         { *m = MarkLiquidityRequest{} }
func (m *MarkLiquidityRequest) String() string { return proto.CompactTextString(m) }
func (*MarkLiquidityRequest) ProtoMessage()    {}
func (*MarkLiquidityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{27}
}
func (m *MarkLiquidityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkLiquidityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkLiquidityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkLiquidityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkLiquidityRequest.Merge(m, src)
}
func (m *MarkLiquidityRequest) XXX_Size() int {
	return m.Size()
}
func (m *MarkLiquidityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkLiquidityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkLiquidityRequest proto.InternalMessageInfo

func (m *MarkLiquidityRequest) GetLpAddr() string {
	if m != nil {
		return m.LpAddr
	}
	return ""
}

func (m *MarkLiquidityRequest) GetAmt() string {
	if m != nil {
		return m.Amt
	}
	return ""
}

func (m *MarkLiquidityRequest) GetTokenAddr() string {
	if m != nil {
		return m.TokenAddr
	}
	return ""
}

func (m *MarkLiquidityRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *MarkLiquidityRequest) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *MarkLiquidityRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *MarkLiquidityRequest) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

type MarkLiquidityResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *MarkLiquidityResponse) Reset()         { *m = MarkLiquidityResponse{} }
func (m *MarkLiquidityResponse) String() string { return proto.CompactTextString(m) }
func (*MarkLiquidityResponse) ProtoMessage()    {}
func (*MarkLiquidityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{28}
}
func (m *MarkLiquidityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarkLiquidityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarkLiquidityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarkLiquidityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkLiquidityResponse.Merge(m, src)
}
func (m *MarkLiquidityResponse) XXX_Size() int {
	return m.Size()
}
func (m *MarkLiquidityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkLiquidityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkLiquidityResponse proto.InternalMessageInfo

func (m *MarkLiquidityResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type UnlockFarmingRewardRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *UnlockFarmingRewardRequest) Reset()         { *m = UnlockFarmingRewardRequest{} }
func (m *UnlockFarmingRewardRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockFarmingRewardRequest) ProtoMessage()    {}
func (*UnlockFarmingRewardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{29}
}
func (m *UnlockFarmingRewardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockFarmingRewardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockFarmingRewardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockFarmingRewardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockFarmingRewardRequest.Merge(m, src)
}
func (m *UnlockFarmingRewardRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockFarmingRewardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockFarmingRewardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockFarmingRewardRequest proto.InternalMessageInfo

func (m *UnlockFarmingRewardRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type UnlockFarmingRewardResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *UnlockFarmingRewardResponse) Reset()         { *m = UnlockFarmingRewardResponse{} }
func (m *UnlockFarmingRewardResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockFarmingRewardResponse) ProtoMessage()    {}
func (*UnlockFarmingRewardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{30}
}
func (m *UnlockFarmingRewardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockFarmingRewardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockFarmingRewardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockFarmingRewardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockFarmingRewardResponse.Merge(m, src)
}
func (m *UnlockFarmingRewardResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockFarmingRewardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockFarmingRewardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockFarmingRewardResponse proto.InternalMessageInfo

func (m *UnlockFarmingRewardResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetFarmingRewardDetailsRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *GetFarmingRewardDetailsRequest) Reset()         { *m = GetFarmingRewardDetailsRequest{} }
func (m *GetFarmingRewardDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*GetFarmingRewardDetailsRequest) ProtoMessage()    {}
func (*GetFarmingRewardDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{31}
}
func (m *GetFarmingRewardDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFarmingRewardDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFarmingRewardDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFarmingRewardDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFarmingRewardDetailsRequest.Merge(m, src)
}
func (m *GetFarmingRewardDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFarmingRewardDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFarmingRewardDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFarmingRewardDetailsRequest proto.InternalMessageInfo

func (m *GetFarmingRewardDetailsRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type GetFarmingRewardDetailsResponse struct {
	Err     *ErrMsg                      `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Details []*types1.RewardClaimDetails `protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty"`
}

func (m *GetFarmingRewardDetailsResponse) Reset()         { *m = GetFarmingRewardDetailsResponse{} }
func (m *GetFarmingRewardDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*GetFarmingRewardDetailsResponse) ProtoMessage()    {}
func (*GetFarmingRewardDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{32}
}
func (m *GetFarmingRewardDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFarmingRewardDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFarmingRewardDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFarmingRewardDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFarmingRewardDetailsResponse.Merge(m, src)
}
func (m *GetFarmingRewardDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetFarmingRewardDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFarmingRewardDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetFarmingRewardDetailsResponse proto.InternalMessageInfo

func (m *GetFarmingRewardDetailsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetFarmingRewardDetailsResponse) GetDetails() []*types1.RewardClaimDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type QueryLiquidityStatusRequest struct {
	SeqNum  uint64 `protobuf:"varint,1,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	TxHash  string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	LpAddr  string `protobuf:"bytes,3,opt,name=lp_addr,json=lpAddr,proto3" json:"lp_addr,omitempty"`
	ChainId uint32 `protobuf:"varint,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Type    LPType `protobuf:"varint,5,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
}

func (m *QueryLiquidityStatusRequest) Reset()         { *m = QueryLiquidityStatusRequest{} }
func (m *QueryLiquidityStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryLiquidityStatusRequest) ProtoMessage()    {}
func (*QueryLiquidityStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{33}
}
func (m *QueryLiquidityStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryLiquidityStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryLiquidityStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryLiquidityStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryLiquidityStatusRequest.Merge(m, src)
}
func (m *QueryLiquidityStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryLiquidityStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryLiquidityStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryLiquidityStatusRequest proto.InternalMessageInfo

func (m *QueryLiquidityStatusRequest) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *QueryLiquidityStatusRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *QueryLiquidityStatusRequest) GetLpAddr() string {
	if m != nil {
		return m.LpAddr
	}
	return ""
}

func (m *QueryLiquidityStatusRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *QueryLiquidityStatusRequest) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

type TransferHistory struct {
	TransferId      string                      `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	SrcSendInfo     *TransferInfo               `protobuf:"bytes,2,opt,name=src_send_info,json=srcSendInfo,proto3" json:"src_send_info,omitempty"`
	DstReceivedInfo *TransferInfo               `protobuf:"bytes,3,opt,name=dst_received_info,json=dstReceivedInfo,proto3" json:"dst_received_info,omitempty"`
	Ts              uint64                      `protobuf:"varint,4,opt,name=ts,proto3" json:"ts,omitempty"`
	SrcBlockTxLink  string                      `protobuf:"bytes,5,opt,name=src_block_tx_link,json=srcBlockTxLink,proto3" json:"src_block_tx_link,omitempty"`
	DstBlockTxLink  string                      `protobuf:"bytes,6,opt,name=dst_block_tx_link,json=dstBlockTxLink,proto3" json:"dst_block_tx_link,omitempty"`
	Status          types.TransferHistoryStatus `protobuf:"varint,7,opt,name=status,proto3,enum=sgn.cbridge.v1.TransferHistoryStatus" json:"status,omitempty"`
	RefundReason    types.XferStatus            `protobuf:"varint,8,opt,name=refund_reason,json=refundReason,proto3,enum=sgn.cbridge.v1.XferStatus" json:"refund_reason,omitempty"`
}

func (m *TransferHistory) Reset()         { *m = TransferHistory{} }
func (m *TransferHistory) String() string { return proto.CompactTextString(m) }
func (*TransferHistory) ProtoMessage()    {}
func (*TransferHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{34}
}
func (m *TransferHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistory.Merge(m, src)
}
func (m *TransferHistory) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistory.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistory proto.InternalMessageInfo

func (m *TransferHistory) GetTransferId() string {
	if m != nil {
		return m.TransferId
	}
	return ""
}

func (m *TransferHistory) GetSrcSendInfo() *TransferInfo {
	if m != nil {
		return m.SrcSendInfo
	}
	return nil
}

func (m *TransferHistory) GetDstReceivedInfo() *TransferInfo {
	if m != nil {
		return m.DstReceivedInfo
	}
	return nil
}

func (m *TransferHistory) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *TransferHistory) GetSrcBlockTxLink() string {
	if m != nil {
		return m.SrcBlockTxLink
	}
	return ""
}

func (m *TransferHistory) GetDstBlockTxLink() string {
	if m != nil {
		return m.DstBlockTxLink
	}
	return ""
}

func (m *TransferHistory) GetStatus() types.TransferHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.TransferHistoryStatus_TRANSFER_UNKNOWN
}

func (m *TransferHistory) GetRefundReason() types.XferStatus {
	if m != nil {
		return m.RefundReason
	}
	return types.XferStatus_UNKNOWN
}

type LPHistory struct {
	Chain       *Chain                `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Token       *TokenInfo            `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Amount      string                `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Ts          uint64                `protobuf:"varint,4,opt,name=ts,proto3" json:"ts,omitempty"`
	BlockTxLink string                `protobuf:"bytes,5,opt,name=block_tx_link,json=blockTxLink,proto3" json:"block_tx_link,omitempty"`
	Status      types.LPHistoryStatus `protobuf:"varint,6,opt,name=status,proto3,enum=sgn.cbridge.v1.LPHistoryStatus" json:"status,omitempty"`
	Type        LPType                `protobuf:"varint,7,opt,name=type,proto3,enum=sgn.gateway.v1.LPType" json:"type,omitempty"`
	SeqNum      uint64                `protobuf:"varint,8,opt,name=seq_num,json=seqNum,proto3" json:"seq_num,omitempty"`
	MethodType  WithdrawMethodType    `protobuf:"varint,9,opt,name=method_type,json=methodType,proto3,enum=sgn.gateway.v1.WithdrawMethodType" json:"method_type,omitempty"`
}

func (m *LPHistory) Reset()         { *m = LPHistory{} }
func (m *LPHistory) String() string { return proto.CompactTextString(m) }
func (*LPHistory) ProtoMessage()    {}
func (*LPHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{35}
}
func (m *LPHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistory.Merge(m, src)
}
func (m *LPHistory) XXX_Size() int {
	return m.Size()
}
func (m *LPHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistory.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistory proto.InternalMessageInfo

func (m *LPHistory) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *LPHistory) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *LPHistory) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *LPHistory) GetTs() uint64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *LPHistory) GetBlockTxLink() string {
	if m != nil {
		return m.BlockTxLink
	}
	return ""
}

func (m *LPHistory) GetStatus() types.LPHistoryStatus {
	if m != nil {
		return m.Status
	}
	return types.LPHistoryStatus_LP_UNKNOWN
}

func (m *LPHistory) GetType() LPType {
	if m != nil {
		return m.Type
	}
	return LPType_LP_TYPE_UNKNOWN
}

func (m *LPHistory) GetSeqNum() uint64 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *LPHistory) GetMethodType() WithdrawMethodType {
	if m != nil {
		return m.MethodType
	}
	return WithdrawMethodType_WD_METHOD_TYPE_UNDEFINED
}

type TransferHistoryRequest struct {
	NextPageToken string `protobuf:"bytes,1,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	PageSize      uint64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Addr          string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *TransferHistoryRequest) Reset()         { *m = TransferHistoryRequest{} }
func (m *TransferHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*TransferHistoryRequest) ProtoMessage()    {}
func (*TransferHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{36}
}
func (m *TransferHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistoryRequest.Merge(m, src)
}
func (m *TransferHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistoryRequest proto.InternalMessageInfo

func (m *TransferHistoryRequest) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *TransferHistoryRequest) GetPageSize() uint64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *TransferHistoryRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type TransferHistoryResponse struct {
	Err           *ErrMsg            `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	History       []*TransferHistory `protobuf:"bytes,2,rep,name=history,proto3" json:"history,omitempty"`
	NextPageToken string             `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	CurrentSize   uint64             `protobuf:"varint,4,opt,name=current_size,json=currentSize,proto3" json:"current_size,omitempty"`
}

func (m *TransferHistoryResponse) Reset()         { *m = TransferHistoryResponse{} }
func (m *TransferHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*TransferHistoryResponse) ProtoMessage()    {}
func (*TransferHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{37}
}
func (m *TransferHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferHistoryResponse.Merge(m, src)
}
func (m *TransferHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransferHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransferHistoryResponse proto.InternalMessageInfo

func (m *TransferHistoryResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *TransferHistoryResponse) GetHistory() []*TransferHistory {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *TransferHistoryResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *TransferHistoryResponse) GetCurrentSize() uint64 {
	if m != nil {
		return m.CurrentSize
	}
	return 0
}

type LPHistoryRequest struct {
	NextPageToken string `protobuf:"bytes,1,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	PageSize      uint64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Addr          string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *LPHistoryRequest) Reset()         { *m = LPHistoryRequest{} }
func (m *LPHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*LPHistoryRequest) ProtoMessage()    {}
func (*LPHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{38}
}
func (m *LPHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistoryRequest.Merge(m, src)
}
func (m *LPHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *LPHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistoryRequest proto.InternalMessageInfo

func (m *LPHistoryRequest) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *LPHistoryRequest) GetPageSize() uint64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *LPHistoryRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type LPHistoryResponse struct {
	Err           *ErrMsg      `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	History       []*LPHistory `protobuf:"bytes,2,rep,name=history,proto3" json:"history,omitempty"`
	NextPageToken string       `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	CurrentSize   uint64       `protobuf:"varint,4,opt,name=current_size,json=currentSize,proto3" json:"current_size,omitempty"`
}

func (m *LPHistoryResponse) Reset()         { *m = LPHistoryResponse{} }
func (m *LPHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*LPHistoryResponse) ProtoMessage()    {}
func (*LPHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{39}
}
func (m *LPHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPHistoryResponse.Merge(m, src)
}
func (m *LPHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *LPHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LPHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LPHistoryResponse proto.InternalMessageInfo

func (m *LPHistoryResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *LPHistoryResponse) GetHistory() []*LPHistory {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *LPHistoryResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *LPHistoryResponse) GetCurrentSize() uint64 {
	if m != nil {
		return m.CurrentSize
	}
	return 0
}

type RewardingDataRequest struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *RewardingDataRequest) Reset()         { *m = RewardingDataRequest{} }
func (m *RewardingDataRequest) String() string { return proto.CompactTextString(m) }
func (*RewardingDataRequest) ProtoMessage()    {}
func (*RewardingDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{40}
}
func (m *RewardingDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardingDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardingDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardingDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardingDataRequest.Merge(m, src)
}
func (m *RewardingDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *RewardingDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardingDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RewardingDataRequest proto.InternalMessageInfo

func (m *RewardingDataRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type Reward struct {
	Amt   float64      `protobuf:"fixed64,1,opt,name=amt,proto3" json:"amt,omitempty"`
	Token *types.Token `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *Reward) Reset()         { *m = Reward{} }
func (m *Reward) String() string { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()    {}
func (*Reward) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{41}
}
func (m *Reward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reward.Merge(m, src)
}
func (m *Reward) XXX_Size() int {
	return m.Size()
}
func (m *Reward) XXX_DiscardUnknown() {
	xxx_messageInfo_Reward.DiscardUnknown(m)
}

var xxx_messageInfo_Reward proto.InternalMessageInfo

func (m *Reward) GetAmt() float64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *Reward) GetToken() *types.Token {
	if m != nil {
		return m.Token
	}
	return nil
}

type RewardingDataResponse struct {
	Err                         *ErrMsg            `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	UsdPrice                    map[string]float64 `protobuf:"bytes,2,rep,name=usd_price,json=usdPrice,proto3" json:"usd_price,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	HistoricalCumulativeRewards []*Reward          `protobuf:"bytes,3,rep,name=historical_cumulative_rewards,json=historicalCumulativeRewards,proto3" json:"historical_cumulative_rewards,omitempty"`
	UnlockedCumulativeRewards   []*Reward          `protobuf:"bytes,4,rep,name=unlocked_cumulative_rewards,json=unlockedCumulativeRewards,proto3" json:"unlocked_cumulative_rewards,omitempty"`
}

func (m *RewardingDataResponse) Reset()         { *m = RewardingDataResponse{} }
func (m *RewardingDataResponse) String() string { return proto.CompactTextString(m) }
func (*RewardingDataResponse) ProtoMessage()    {}
func (*RewardingDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{42}
}
func (m *RewardingDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardingDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardingDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardingDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardingDataResponse.Merge(m, src)
}
func (m *RewardingDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *RewardingDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardingDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RewardingDataResponse proto.InternalMessageInfo

func (m *RewardingDataResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *RewardingDataResponse) GetUsdPrice() map[string]float64 {
	if m != nil {
		return m.UsdPrice
	}
	return nil
}

func (m *RewardingDataResponse) GetHistoricalCumulativeRewards() []*Reward {
	if m != nil {
		return m.HistoricalCumulativeRewards
	}
	return nil
}

func (m *RewardingDataResponse) GetUnlockedCumulativeRewards() []*Reward {
	if m != nil {
		return m.UnlockedCumulativeRewards
	}
	return nil
}

type UpdateChainRequest struct {
	Chain       *Chain `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	TxUrlPrefix string `protobuf:"bytes,2,opt,name=tx_url_prefix,json=txUrlPrefix,proto3" json:"tx_url_prefix,omitempty"`
	Sig         []byte `protobuf:"bytes,3,opt,name=sig,proto3" json:"sig,omitempty"`
	Addr        string `protobuf:"bytes,4,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *UpdateChainRequest) Reset()         { *m = UpdateChainRequest{} }
func (m *UpdateChainRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateChainRequest) ProtoMessage()    {}
func (*UpdateChainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{43}
}
func (m *UpdateChainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateChainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateChainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateChainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateChainRequest.Merge(m, src)
}
func (m *UpdateChainRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateChainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateChainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateChainRequest proto.InternalMessageInfo

func (m *UpdateChainRequest) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *UpdateChainRequest) GetTxUrlPrefix() string {
	if m != nil {
		return m.TxUrlPrefix
	}
	return ""
}

func (m *UpdateChainRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *UpdateChainRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type UpdateChainResponse struct {
	Err         *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Chain       *Chain  `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	TxUrlPrefix string  `protobuf:"bytes,3,opt,name=tx_url_prefix,json=txUrlPrefix,proto3" json:"tx_url_prefix,omitempty"`
}

func (m *UpdateChainResponse) Reset()         { *m = UpdateChainResponse{} }
func (m *UpdateChainResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateChainResponse) ProtoMessage()    {}
func (*UpdateChainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{44}
}
func (m *UpdateChainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateChainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateChainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateChainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateChainResponse.Merge(m, src)
}
func (m *UpdateChainResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateChainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateChainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateChainResponse proto.InternalMessageInfo

func (m *UpdateChainResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *UpdateChainResponse) GetChain() *Chain {
	if m != nil {
		return m.Chain
	}
	return nil
}

func (m *UpdateChainResponse) GetTxUrlPrefix() string {
	if m != nil {
		return m.TxUrlPrefix
	}
	return ""
}

type UpdateTokenRequest struct {
	ChainId     uint32 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TokenSymbol string `protobuf:"bytes,2,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
	TokenName   string `protobuf:"bytes,3,opt,name=token_name,json=tokenName,proto3" json:"token_name,omitempty"`
	TokenIcon   string `protobuf:"bytes,4,opt,name=token_icon,json=tokenIcon,proto3" json:"token_icon,omitempty"`
	Sig         []byte `protobuf:"bytes,5,opt,name=sig,proto3" json:"sig,omitempty"`
	Addr        string `protobuf:"bytes,6,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *UpdateTokenRequest) Reset()         { *m = UpdateTokenRequest{} }
func (m *UpdateTokenRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateTokenRequest) ProtoMessage()    {}
func (*UpdateTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{45}
}
func (m *UpdateTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTokenRequest.Merge(m, src)
}
func (m *UpdateTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTokenRequest proto.InternalMessageInfo

func (m *UpdateTokenRequest) GetChainId() uint32 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *UpdateTokenRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

func (m *UpdateTokenRequest) GetTokenName() string {
	if m != nil {
		return m.TokenName
	}
	return ""
}

func (m *UpdateTokenRequest) GetTokenIcon() string {
	if m != nil {
		return m.TokenIcon
	}
	return ""
}

func (m *UpdateTokenRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *UpdateTokenRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type UpdateTokenResponse struct {
	Err   *ErrMsg    `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Token *TokenInfo `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *UpdateTokenResponse) Reset()         { *m = UpdateTokenResponse{} }
func (m *UpdateTokenResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateTokenResponse) ProtoMessage()    {}
func (*UpdateTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{46}
}
func (m *UpdateTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTokenResponse.Merge(m, src)
}
func (m *UpdateTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTokenResponse proto.InternalMessageInfo

func (m *UpdateTokenResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *UpdateTokenResponse) GetToken() *TokenInfo {
	if m != nil {
		return m.Token
	}
	return nil
}

type StakingConfigRequest struct {
}

func (m *StakingConfigRequest) Reset()         { *m = StakingConfigRequest{} }
func (m *StakingConfigRequest) String() string { return proto.CompactTextString(m) }
func (*StakingConfigRequest) ProtoMessage()    {}
func (*StakingConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{47}
}
func (m *StakingConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakingConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakingConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakingConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakingConfigRequest.Merge(m, src)
}
func (m *StakingConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *StakingConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StakingConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StakingConfigRequest proto.InternalMessageInfo

type StakingConfigResponse struct {
	ViewerContract        string `protobuf:"bytes,1,opt,name=viewer_contract,json=viewerContract,proto3" json:"viewer_contract,omitempty"`
	StakingContract       string `protobuf:"bytes,2,opt,name=staking_contract,json=stakingContract,proto3" json:"staking_contract,omitempty"`
	StakingRewardContract string `protobuf:"bytes,3,opt,name=staking_reward_contract,json=stakingRewardContract,proto3" json:"staking_reward_contract,omitempty"`
	CelrContract          string `protobuf:"bytes,4,opt,name=celr_contract,json=celrContract,proto3" json:"celr_contract,omitempty"`
}

func (m *StakingConfigResponse) Reset()         { *m = StakingConfigResponse{} }
func (m *StakingConfigResponse) String() string { return proto.CompactTextString(m) }
func (*StakingConfigResponse) ProtoMessage()    {}
func (*StakingConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{48}
}
func (m *StakingConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakingConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakingConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakingConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakingConfigResponse.Merge(m, src)
}
func (m *StakingConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *StakingConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StakingConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StakingConfigResponse proto.InternalMessageInfo

func (m *StakingConfigResponse) GetViewerContract() string {
	if m != nil {
		return m.ViewerContract
	}
	return ""
}

func (m *StakingConfigResponse) GetStakingContract() string {
	if m != nil {
		return m.StakingContract
	}
	return ""
}

func (m *StakingConfigResponse) GetStakingRewardContract() string {
	if m != nil {
		return m.StakingRewardContract
	}
	return ""
}

func (m *StakingConfigResponse) GetCelrContract() string {
	if m != nil {
		return m.CelrContract
	}
	return ""
}

type UnlockStakingRewardRequest struct {
	DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
}

func (m *UnlockStakingRewardRequest) Reset()         { *m = UnlockStakingRewardRequest{} }
func (m *UnlockStakingRewardRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockStakingRewardRequest) ProtoMessage()    {}
func (*UnlockStakingRewardRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{49}
}
func (m *UnlockStakingRewardRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockStakingRewardRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockStakingRewardRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockStakingRewardRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockStakingRewardRequest.Merge(m, src)
}
func (m *UnlockStakingRewardRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockStakingRewardRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockStakingRewardRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockStakingRewardRequest proto.InternalMessageInfo

func (m *UnlockStakingRewardRequest) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

type UnlockStakingRewardResponse struct {
	Err *ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *UnlockStakingRewardResponse) Reset()         { *m = UnlockStakingRewardResponse{} }
func (m *UnlockStakingRewardResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockStakingRewardResponse) ProtoMessage()    {}
func (*UnlockStakingRewardResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{50}
}
func (m *UnlockStakingRewardResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockStakingRewardResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockStakingRewardResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnlockStakingRewardResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockStakingRewardResponse.Merge(m, src)
}
func (m *UnlockStakingRewardResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockStakingRewardResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockStakingRewardResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockStakingRewardResponse proto.InternalMessageInfo

func (m *UnlockStakingRewardResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

type GetStakingRewardDetailsRequest struct {
	DelegatorAddress string `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3" json:"delegator_address,omitempty"`
}

func (m *GetStakingRewardDetailsRequest) Reset()         { *m = GetStakingRewardDetailsRequest{} }
func (m *GetStakingRewardDetailsRequest) String() string { return proto.CompactTextString(m) }
func (*GetStakingRewardDetailsRequest) ProtoMessage()    {}
func (*GetStakingRewardDetailsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{51}
}
func (m *GetStakingRewardDetailsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStakingRewardDetailsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStakingRewardDetailsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStakingRewardDetailsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStakingRewardDetailsRequest.Merge(m, src)
}
func (m *GetStakingRewardDetailsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetStakingRewardDetailsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStakingRewardDetailsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStakingRewardDetailsRequest proto.InternalMessageInfo

func (m *GetStakingRewardDetailsRequest) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

type GetStakingRewardDetailsResponse struct {
	Err    *ErrMsg                        `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	Detail *types2.StakingRewardClaimInfo `protobuf:"bytes,2,opt,name=detail,proto3" json:"detail,omitempty"`
}

func (m *GetStakingRewardDetailsResponse) Reset()         { *m = GetStakingRewardDetailsResponse{} }
func (m *GetStakingRewardDetailsResponse) String() string { return proto.CompactTextString(m) }
func (*GetStakingRewardDetailsResponse) ProtoMessage()    {}
func (*GetStakingRewardDetailsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{52}
}
func (m *GetStakingRewardDetailsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStakingRewardDetailsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStakingRewardDetailsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStakingRewardDetailsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStakingRewardDetailsResponse.Merge(m, src)
}
func (m *GetStakingRewardDetailsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetStakingRewardDetailsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStakingRewardDetailsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStakingRewardDetailsResponse proto.InternalMessageInfo

func (m *GetStakingRewardDetailsResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetStakingRewardDetailsResponse) GetDetail() *types2.StakingRewardClaimInfo {
	if m != nil {
		return m.Detail
	}
	return nil
}

type GetTotalLiquidityProviderTokenBalanceRequest struct {
	ChainIds    []uint32 `protobuf:"varint,1,rep,packed,name=chain_ids,json=chainIds,proto3" json:"chain_ids,omitempty"`
	TokenSymbol string   `protobuf:"bytes,2,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) Reset() {
	*m = GetTotalLiquidityProviderTokenBalanceRequest{}
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) String() string {
	return proto.CompactTextString(m)
}
func (*GetTotalLiquidityProviderTokenBalanceRequest) ProtoMessage() {}
func (*GetTotalLiquidityProviderTokenBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{53}
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest.Merge(m, src)
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceRequest proto.InternalMessageInfo

func (m *GetTotalLiquidityProviderTokenBalanceRequest) GetChainIds() []uint32 {
	if m != nil {
		return m.ChainIds
	}
	return nil
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) GetTokenSymbol() string {
	if m != nil {
		return m.TokenSymbol
	}
	return ""
}

type GetTotalLiquidityProviderTokenBalanceResponse struct {
	Err      *ErrMsg           `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	TotalLiq map[uint64]string `protobuf:"bytes,2,rep,name=total_liq,json=totalLiq,proto3" json:"total_liq,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) Reset() {
	*m = GetTotalLiquidityProviderTokenBalanceResponse{}
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) String() string {
	return proto.CompactTextString(m)
}
func (*GetTotalLiquidityProviderTokenBalanceResponse) ProtoMessage() {}
func (*GetTotalLiquidityProviderTokenBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{54}
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse.Merge(m, src)
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTotalLiquidityProviderTokenBalanceResponse proto.InternalMessageInfo

func (m *GetTotalLiquidityProviderTokenBalanceResponse) GetErr() *ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) GetTotalLiq() map[uint64]string {
	if m != nil {
		return m.TotalLiq
	}
	return nil
}

type ErrMsg struct {
	Code ErrCode `protobuf:"varint,1,opt,name=code,proto3,enum=sgn.gateway.v1.ErrCode" json:"code,omitempty"`
	Msg  string  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ErrMsg) Reset()         { *m = ErrMsg{} }
func (m *ErrMsg) String() string { return proto.CompactTextString(m) }
func (*ErrMsg) ProtoMessage()    {}
func (*ErrMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4ec1f1e4252d2467, []int{55}
}
func (m *ErrMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ErrMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrMsg.Merge(m, src)
}
func (m *ErrMsg) XXX_Size() int {
	return m.Size()
}
func (m *ErrMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ErrMsg proto.InternalMessageInfo

func (m *ErrMsg) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_ERROR_CODE_UNDEFINED
}

func (m *ErrMsg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("sgn.gateway.v1.TransferType", TransferType_name, TransferType_value)
	proto.RegisterEnum("sgn.gateway.v1.LPType", LPType_name, LPType_value)
	proto.RegisterEnum("sgn.gateway.v1.WithdrawMethodType", WithdrawMethodType_name, WithdrawMethodType_value)
	proto.RegisterEnum("sgn.gateway.v1.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterType((*GetCampaignScoresRequest)(nil), "sgn.gateway.v1.GetCampaignScoresRequest")
	proto.RegisterType((*GetCampaignScoresResponse)(nil), "sgn.gateway.v1.GetCampaignScoresResponse")
	proto.RegisterType((*CampaignScore)(nil), "sgn.gateway.v1.CampaignScore")
	proto.RegisterType((*QueryLiquidityStatusResponse)(nil), "sgn.gateway.v1.QueryLiquidityStatusResponse")
	proto.RegisterType((*Chain)(nil), "sgn.gateway.v1.Chain")
	proto.RegisterType((*ChainTokenInfo)(nil), "sgn.gateway.v1.ChainTokenInfo")
	proto.RegisterType((*TokenInfo)(nil), "sgn.gateway.v1.TokenInfo")
	proto.RegisterType((*TransferInfo)(nil), "sgn.gateway.v1.TransferInfo")
	proto.RegisterType((*GetTransferStatusRequest)(nil), "sgn.gateway.v1.GetTransferStatusRequest")
	proto.RegisterType((*GetTransferStatusResponse)(nil), "sgn.gateway.v1.GetTransferStatusResponse")
	proto.RegisterType((*GetTransferConfigsRequest)(nil), "sgn.gateway.v1.GetTransferConfigsRequest")
	proto.RegisterType((*GetTransferConfigsResponse)(nil), "sgn.gateway.v1.GetTransferConfigsResponse")
	proto.RegisterMapType((map[uint32]*ChainTokenInfo)(nil), "sgn.gateway.v1.GetTransferConfigsResponse.ChainTokenEntry")
	proto.RegisterType((*GetTokenInfoRequest)(nil), "sgn.gateway.v1.GetTokenInfoRequest")
	proto.RegisterType((*GetTokenInfoResponse)(nil), "sgn.gateway.v1.GetTokenInfoResponse")
	proto.RegisterType((*EstimateAmtRequest)(nil), "sgn.gateway.v1.EstimateAmtRequest")
	proto.RegisterType((*EstimateAmtResponse)(nil), "sgn.gateway.v1.EstimateAmtResponse")
	proto.RegisterType((*WithdrawInfo)(nil), "sgn.gateway.v1.WithdrawInfo")
	proto.RegisterType((*EstimateWithdrawAmtRequest)(nil), "sgn.gateway.v1.EstimateWithdrawAmtRequest")
	proto.RegisterType((*EstimateWithdrawAmtResponse)(nil), "sgn.gateway.v1.EstimateWithdrawAmtResponse")
	proto.RegisterMapType((map[uint32]*EstimateWithdrawAmt)(nil), "sgn.gateway.v1.EstimateWithdrawAmtResponse.ReqAmtEntry")
	proto.RegisterType((*EstimateWithdrawAmt)(nil), "sgn.gateway.v1.EstimateWithdrawAmt")
	proto.RegisterType((*MarkTransferRequest)(nil), "sgn.gateway.v1.MarkTransferRequest")
	proto.RegisterType((*MarkTransferResponse)(nil), "sgn.gateway.v1.MarkTransferResponse")
	proto.RegisterType((*GetLPInfoListRequest)(nil), "sgn.gateway.v1.GetLPInfoListRequest")
	proto.RegisterType((*LPInfo)(nil), "sgn.gateway.v1.LPInfo")
	proto.RegisterType((*GetLPInfoListResponse)(nil), "sgn.gateway.v1.GetLPInfoListResponse")
	proto.RegisterType((*WithdrawLiquidityRequest)(nil), "sgn.gateway.v1.WithdrawLiquidityRequest")
	proto.RegisterType((*WithdrawLiquidityResponse)(nil), "sgn.gateway.v1.WithdrawLiquidityResponse")
	proto.RegisterType((*MarkLiquidityRequest)(nil), "sgn.gateway.v1.MarkLiquidityRequest")
	proto.RegisterType((*MarkLiquidityResponse)(nil), "sgn.gateway.v1.MarkLiquidityResponse")
	proto.RegisterType((*UnlockFarmingRewardRequest)(nil), "sgn.gateway.v1.UnlockFarmingRewardRequest")
	proto.RegisterType((*UnlockFarmingRewardResponse)(nil), "sgn.gateway.v1.UnlockFarmingRewardResponse")
	proto.RegisterType((*GetFarmingRewardDetailsRequest)(nil), "sgn.gateway.v1.GetFarmingRewardDetailsRequest")
	proto.RegisterType((*GetFarmingRewardDetailsResponse)(nil), "sgn.gateway.v1.GetFarmingRewardDetailsResponse")
	proto.RegisterType((*QueryLiquidityStatusRequest)(nil), "sgn.gateway.v1.QueryLiquidityStatusRequest")
	proto.RegisterType((*TransferHistory)(nil), "sgn.gateway.v1.TransferHistory")
	proto.RegisterType((*LPHistory)(nil), "sgn.gateway.v1.LPHistory")
	proto.RegisterType((*TransferHistoryRequest)(nil), "sgn.gateway.v1.TransferHistoryRequest")
	proto.RegisterType((*TransferHistoryResponse)(nil), "sgn.gateway.v1.TransferHistoryResponse")
	proto.RegisterType((*LPHistoryRequest)(nil), "sgn.gateway.v1.LPHistoryRequest")
	proto.RegisterType((*LPHistoryResponse)(nil), "sgn.gateway.v1.LPHistoryResponse")
	proto.RegisterType((*RewardingDataRequest)(nil), "sgn.gateway.v1.RewardingDataRequest")
	proto.RegisterType((*Reward)(nil), "sgn.gateway.v1.Reward")
	proto.RegisterType((*RewardingDataResponse)(nil), "sgn.gateway.v1.RewardingDataResponse")
	proto.RegisterMapType((map[string]float64)(nil), "sgn.gateway.v1.RewardingDataResponse.UsdPriceEntry")
	proto.RegisterType((*UpdateChainRequest)(nil), "sgn.gateway.v1.UpdateChainRequest")
	proto.RegisterType((*UpdateChainResponse)(nil), "sgn.gateway.v1.UpdateChainResponse")
	proto.RegisterType((*UpdateTokenRequest)(nil), "sgn.gateway.v1.UpdateTokenRequest")
	proto.RegisterType((*UpdateTokenResponse)(nil), "sgn.gateway.v1.UpdateTokenResponse")
	proto.RegisterType((*StakingConfigRequest)(nil), "sgn.gateway.v1.StakingConfigRequest")
	proto.RegisterType((*StakingConfigResponse)(nil), "sgn.gateway.v1.StakingConfigResponse")
	proto.RegisterType((*UnlockStakingRewardRequest)(nil), "sgn.gateway.v1.UnlockStakingRewardRequest")
	proto.RegisterType((*UnlockStakingRewardResponse)(nil), "sgn.gateway.v1.UnlockStakingRewardResponse")
	proto.RegisterType((*GetStakingRewardDetailsRequest)(nil), "sgn.gateway.v1.GetStakingRewardDetailsRequest")
	proto.RegisterType((*GetStakingRewardDetailsResponse)(nil), "sgn.gateway.v1.GetStakingRewardDetailsResponse")
	proto.RegisterType((*GetTotalLiquidityProviderTokenBalanceRequest)(nil), "sgn.gateway.v1.GetTotalLiquidityProviderTokenBalanceRequest")
	proto.RegisterType((*GetTotalLiquidityProviderTokenBalanceResponse)(nil), "sgn.gateway.v1.GetTotalLiquidityProviderTokenBalanceResponse")
	proto.RegisterMapType((map[uint64]string)(nil), "sgn.gateway.v1.GetTotalLiquidityProviderTokenBalanceResponse.TotalLiqEntry")
	proto.RegisterType((*ErrMsg)(nil), "sgn.gateway.v1.ErrMsg")
}

func init() { proto.RegisterFile("sgn/gateway/v1/gateway.proto", fileDescriptor_4ec1f1e4252d2467) }

var fileDescriptor_4ec1f1e4252d2467 = []byte{
	// 3677 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x3b, 0x4b, 0x70, 0x1b, 0x47,
	0x76, 0x1a, 0x00, 0x04, 0x88, 0x07, 0x80, 0x04, 0x9b, 0x3f, 0x10, 0xa4, 0x28, 0x6a, 0x64, 0xd9,
	0x12, 0xb5, 0x22, 0x2d, 0x5a, 0xc9, 0xee, 0x7a, 0x77, 0x6b, 0x0d, 0x91, 0x90, 0xc4, 0x12, 0x7f,
	0x19, 0x50, 0x56, 0xb2, 0x5b, 0xd9, 0xc9, 0x10, 0xd3, 0x04, 0xa7, 0x08, 0xcc, 0x80, 0xd3, 0x03,
	0x7e, 0x74, 0xb1, 0x2b, 0x95, 0x4b, 0x3e, 0x95, 0x72, 0xd9, 0x95, 0x4b, 0x2e, 0xb9, 0xa4, 0x2a,
	0xb7, 0xf8, 0x96, 0xca, 0x25, 0x95, 0xab, 0x93, 0x93, 0xab, 0x72, 0x70, 0x72, 0x4b, 0xd9, 0xbe,
	0x38, 0xb9, 0xa5, 0x72, 0x48, 0x0e, 0xa9, 0x4a, 0xf5, 0x0f, 0x98, 0x1f, 0x20, 0x40, 0xb1, 0x52,
	0x7b, 0xeb, 0x79, 0xef, 0x75, 0xbf, 0x4f, 0xbf, 0xf7, 0xfa, 0xf5, 0x6b, 0x00, 0x96, 0x48, 0xc3,
	0x5e, 0x6f, 0x18, 0x1e, 0xbe, 0x30, 0xae, 0xd6, 0xcf, 0x1f, 0xc8, 0xe1, 0x5a, 0xdb, 0x75, 0x3c,
	0x07, 0x4d, 0x90, 0x86, 0xbd, 0x26, 0x41, 0xe7, 0x0f, 0xca, 0x4b, 0x0d, 0xc7, 0x69, 0x34, 0xf1,
	0xba, 0xd1, 0xb6, 0xd6, 0x0d, 0xdb, 0x76, 0x3c, 0xc3, 0xb3, 0x1c, 0x9b, 0x70, 0xea, 0x72, 0x99,
	0xae, 0x55, 0x3f, 0x72, 0x2d, 0xb3, 0x81, 0xe9, 0x5a, 0x67, 0x1d, 0xec, 0x8a, 0x95, 0xca, 0x4b,
	0x21, 0x9c, 0x18, 0xfa, 0xb1, 0xc7, 0x86, 0xdb, 0xb2, 0xec, 0x06, 0xc5, 0x8a, 0xa1, 0xc0, 0xbe,
	0x4d, 0xb1, 0xa6, 0x45, 0x3c, 0xd7, 0x3a, 0xea, 0x50, 0x86, 0x94, 0xc4, 0xff, 0x2d, 0xe8, 0x96,
	0xeb, 0x0e, 0x69, 0x39, 0x64, 0xfd, 0xc8, 0x20, 0x94, 0xc7, 0x11, 0xf6, 0x8c, 0x07, 0xeb, 0x75,
	0xc7, 0x12, 0x78, 0xb5, 0x09, 0xa5, 0x27, 0xd8, 0xdb, 0x34, 0x5a, 0x6d, 0xc3, 0x6a, 0xd8, 0xb5,
	0xba, 0xe3, 0x62, 0xa2, 0xe1, 0xb3, 0x0e, 0x26, 0x1e, 0x42, 0x90, 0x32, 0x0d, 0x0f, 0x97, 0x94,
	0x15, 0xe5, 0x4e, 0x41, 0x63, 0x63, 0x74, 0x03, 0x72, 0x47, 0xb8, 0x61, 0xd9, 0xfa, 0x51, 0xd3,
	0xa9, 0x9f, 0x96, 0x12, 0x2b, 0xca, 0x9d, 0x94, 0x06, 0x0c, 0xf4, 0x88, 0x42, 0xd0, 0x22, 0x64,
	0xb1, 0x6d, 0x0a, 0x74, 0x92, 0xa1, 0xc7, 0xb1, 0x6d, 0x32, 0xa4, 0xfa, 0xa9, 0x02, 0x0b, 0x31,
	0xec, 0x48, 0xdb, 0xb1, 0x09, 0x46, 0xbf, 0x01, 0x69, 0xc2, 0x20, 0x25, 0x65, 0x25, 0x79, 0x27,
	0xb7, 0x71, 0x7d, 0x2d, 0x68, 0xea, 0xb5, 0xc0, 0x3c, 0x4d, 0x10, 0xa3, 0x3b, 0x90, 0xc4, 0xae,
	0xcb, 0x44, 0xc9, 0x6d, 0xcc, 0x85, 0xe7, 0x54, 0x5d, 0x77, 0x97, 0x34, 0x34, 0x4a, 0x82, 0x66,
	0x60, 0x8c, 0x49, 0x2a, 0xe4, 0xe2, 0x1f, 0xea, 0x07, 0x50, 0x08, 0x2c, 0x8c, 0x16, 0x60, 0xbc,
	0x43, 0x5c, 0xdd, 0x30, 0x4d, 0x97, 0xe9, 0x9e, 0xd5, 0x32, 0x1d, 0xe2, 0x56, 0x4c, 0x93, 0xad,
	0xc0, 0xb8, 0x0a, 0xc5, 0xf9, 0x87, 0xfa, 0xb7, 0x09, 0x58, 0xfa, 0x2d, 0xba, 0xb1, 0x3b, 0xd6,
	0x59, 0xc7, 0x32, 0x2d, 0xef, 0xaa, 0xe6, 0x19, 0x5e, 0xa7, 0xa7, 0x99, 0x10, 0x51, 0x79, 0xb5,
	0x88, 0x3f, 0x84, 0x34, 0x61, 0x73, 0x19, 0x87, 0x89, 0x8d, 0x1b, 0x8c, 0x58, 0x7a, 0xc6, 0xf9,
	0x83, 0xb5, 0x9d, 0x83, 0xa7, 0x16, 0xf1, 0x1c, 0x57, 0xb2, 0x10, 0xe4, 0xe8, 0x3a, 0xc0, 0x85,
	0xa9, 0x3b, 0x76, 0xfd, 0xc4, 0x10, 0x0a, 0xe6, 0xb5, 0xec, 0x85, 0xb9, 0xcf, 0x01, 0x74, 0xdf,
	0x88, 0xe3, 0x7a, 0xd8, 0xd4, 0x89, 0xd5, 0x20, 0xa5, 0xd4, 0x4a, 0xf2, 0x4e, 0x5e, 0x03, 0x0e,
	0xaa, 0x59, 0x0d, 0x82, 0x4a, 0x90, 0x21, 0x56, 0xc3, 0xc6, 0x2e, 0x29, 0x8d, 0x31, 0xa4, 0xfc,
	0x44, 0x73, 0x90, 0x6e, 0x3b, 0x17, 0x14, 0x91, 0x66, 0x08, 0xf1, 0x85, 0x54, 0x28, 0xb0, 0x5d,
	0xd6, 0xbd, 0x4b, 0xbd, 0x69, 0xd9, 0xa7, 0xa5, 0x0c, 0xb3, 0x55, 0x8e, 0x01, 0x0f, 0x2f, 0x77,
	0x2c, 0xfb, 0x94, 0xb9, 0x0b, 0xa3, 0x31, 0x71, 0xd3, 0xb8, 0x2a, 0x8d, 0x33, 0x4f, 0x02, 0x06,
	0xda, 0xa2, 0x10, 0xf5, 0x3b, 0x05, 0xc6, 0x36, 0x99, 0x84, 0x13, 0x90, 0xb0, 0x4c, 0xe1, 0x6b,
	0x09, 0xcb, 0xa4, 0xde, 0x67, 0x1b, 0x2d, 0x6e, 0xe9, 0xac, 0xc6, 0xc6, 0x14, 0x66, 0xd5, 0x1d,
	0xae, 0x5e, 0x56, 0x63, 0xe3, 0x30, 0x8b, 0x54, 0x98, 0x05, 0xba, 0x03, 0xc5, 0x86, 0x41, 0x74,
	0xcf, 0x39, 0xc5, 0xb6, 0x4e, 0xae, 0x5a, 0x47, 0x4e, 0xb3, 0x34, 0xc6, 0x16, 0x98, 0x68, 0x18,
	0xe4, 0x90, 0x82, 0x6b, 0x0c, 0x4a, 0x97, 0xc2, 0x97, 0xed, 0xa6, 0xe3, 0x62, 0xbd, 0xe3, 0x36,
	0x4b, 0x69, 0x46, 0x04, 0x02, 0xf4, 0xdc, 0x6d, 0xa2, 0x79, 0xc8, 0xb8, 0xed, 0x3a, 0x43, 0x72,
	0x65, 0xd3, 0x6e, 0xbb, 0x4e, 0x11, 0xb7, 0xa0, 0x50, 0x77, 0x6c, 0xcf, 0x35, 0xea, 0x1e, 0xf7,
	0x9b, 0x71, 0x86, 0xce, 0x4b, 0x20, 0x75, 0x1e, 0xb5, 0x02, 0x13, 0x4c, 0x55, 0xc6, 0x72, 0xdb,
	0x3e, 0x76, 0xd0, 0x3a, 0x8c, 0x31, 0xb1, 0x84, 0xc3, 0x2f, 0x84, 0x3d, 0xa3, 0x4b, 0xa9, 0x71,
	0x3a, 0xf5, 0xf7, 0x20, 0xdb, 0x9b, 0x7d, 0xaf, 0x37, 0x9b, 0xfa, 0xd5, 0x6c, 0xd8, 0x55, 0x18,
	0xa5, 0x98, 0x39, 0xac, 0x39, 0xd5, 0x8f, 0x15, 0xc8, 0x1f, 0xba, 0x86, 0x4d, 0x8e, 0xb1, 0x2b,
	0xb9, 0x70, 0x9f, 0xf2, 0x73, 0xf1, 0x07, 0x25, 0x45, 0x6a, 0x9c, 0xa6, 0x27, 0x52, 0x62, 0x08,
	0x91, 0xe6, 0x20, 0x6d, 0xb4, 0x9c, 0x8e, 0xed, 0x09, 0x01, 0xc4, 0x97, 0xfa, 0x13, 0x96, 0x93,
	0xa4, 0x10, 0x32, 0x94, 0x78, 0x4e, 0xba, 0x01, 0x39, 0x4f, 0x20, 0x74, 0xe1, 0x2e, 0x59, 0x0d,
	0x24, 0x68, 0xdb, 0x54, 0xff, 0x3a, 0xc9, 0x52, 0x4c, 0x78, 0xf6, 0xc8, 0x81, 0xf8, 0xb3, 0x50,
	0x20, 0xde, 0x8e, 0xa8, 0x22, 0x38, 0xfc, 0xba, 0x84, 0xe3, 0xcf, 0xa1, 0xe0, 0xe2, 0xe3, 0x8e,
	0x6d, 0xea, 0x2e, 0x36, 0x88, 0x63, 0x33, 0x0f, 0x9d, 0xd8, 0x28, 0x87, 0xe5, 0xfe, 0xed, 0x9e,
	0x55, 0xf2, 0x7c, 0x82, 0xc6, 0xe8, 0x5f, 0x19, 0xab, 0xe8, 0x2e, 0x4c, 0x11, 0xb7, 0xae, 0x07,
	0x83, 0x3e, 0xcb, 0x23, 0x89, 0xb8, 0xf5, 0x47, 0xbe, 0xb8, 0xbf, 0x0b, 0x53, 0x26, 0xf1, 0x42,
	0xa4, 0xc0, 0x49, 0x4d, 0xe2, 0xf9, 0x48, 0xd5, 0xc5, 0xc0, 0x7e, 0x6d, 0x3a, 0xf6, 0xb1, 0xd5,
	0x90, 0xdb, 0xad, 0xfe, 0x47, 0x02, 0xca, 0x71, 0xd8, 0x91, 0xb7, 0xf3, 0x3e, 0xa4, 0x99, 0xe5,
	0xe9, 0x76, 0x26, 0xfb, 0xbb, 0xb1, 0x20, 0x42, 0xbf, 0x84, 0x1c, 0x1b, 0xf1, 0xac, 0x51, 0x4a,
	0xb2, 0x39, 0xef, 0x87, 0xe7, 0xf4, 0x97, 0x6c, 0xad, 0x17, 0xe8, 0x55, 0xdb, 0x73, 0xaf, 0x34,
	0xa8, 0x77, 0x01, 0xe8, 0xe7, 0xb0, 0x24, 0x0e, 0x73, 0xdd, 0xc5, 0x17, 0x86, 0x6b, 0xea, 0xc1,
	0xdc, 0x91, 0x62, 0x76, 0x5a, 0x10, 0x34, 0x1a, 0x23, 0xd9, 0xf4, 0x25, 0x92, 0xf2, 0xef, 0xc2,
	0x64, 0x68, 0x7d, 0x54, 0x84, 0xe4, 0x29, 0xbe, 0x12, 0xe9, 0x93, 0x0e, 0xd1, 0x43, 0x18, 0x3b,
	0x37, 0x9a, 0x1d, 0x2c, 0x42, 0x71, 0x39, 0x56, 0x61, 0x5f, 0x82, 0x61, 0xc4, 0xef, 0x27, 0x7e,
	0xa4, 0xa8, 0x35, 0x98, 0xa6, 0x9a, 0x75, 0x51, 0x22, 0xf4, 0x16, 0x60, 0x9c, 0xdb, 0xa4, 0x9b,
	0xa6, 0x33, 0xec, 0x7b, 0xdb, 0x44, 0x37, 0x21, 0x1f, 0x48, 0xaf, 0x3c, 0xc9, 0xe4, 0xbc, 0x5e,
	0x6e, 0x55, 0x5f, 0xc2, 0x4c, 0x70, 0xd1, 0x91, 0xb7, 0xf0, 0x47, 0x00, 0x9c, 0x89, 0x65, 0x1f,
	0x3b, 0x42, 0xab, 0x01, 0x19, 0x33, 0xeb, 0xc9, 0xa1, 0xfa, 0x95, 0x02, 0xa8, 0x4a, 0x3c, 0xab,
	0x65, 0x78, 0xb8, 0xd2, 0xf2, 0xa4, 0x42, 0x2b, 0x90, 0xa7, 0xfe, 0x1c, 0x52, 0x0a, 0x88, 0x5b,
	0xdf, 0x14, 0x7a, 0xad, 0x40, 0x9e, 0xba, 0x71, 0x97, 0x22, 0xc1, 0x29, 0x4c, 0xe2, 0x6d, 0xf6,
	0xd1, 0x3c, 0x19, 0xd1, 0x9c, 0x6e, 0x8d, 0xd1, 0xf2, 0xc4, 0xae, 0xd2, 0x61, 0xa0, 0xc0, 0x18,
	0x0b, 0x16, 0x18, 0xf7, 0x01, 0x91, 0xa6, 0xd5, 0x6e, 0x1b, 0x0d, 0xac, 0x7b, 0x4e, 0x13, 0xbb,
	0x86, 0x5d, 0xc7, 0xec, 0x24, 0x2a, 0x68, 0x53, 0x12, 0x73, 0x28, 0x11, 0xea, 0x9f, 0x25, 0x60,
	0x3a, 0xa0, 0xd9, 0xc8, 0x56, 0xbd, 0x07, 0x08, 0x9f, 0xe9, 0x6c, 0xf3, 0xc5, 0x11, 0x49, 0x85,
	0xe5, 0x1b, 0x38, 0x89, 0xcf, 0x3e, 0xa4, 0x08, 0x66, 0xd4, 0x4a, 0x8b, 0x65, 0x5f, 0x9e, 0x48,
	0x74, 0x97, 0x16, 0x86, 0x54, 0xd9, 0x84, 0x06, 0x1c, 0xa4, 0xd1, 0xf2, 0x70, 0x01, 0xc6, 0xdb,
	0xd8, 0xad, 0xeb, 0xc7, 0x18, 0x0b, 0x85, 0x33, 0xf4, 0xfb, 0x31, 0x66, 0x28, 0x5a, 0x84, 0x32,
	0x14, 0x3f, 0x3c, 0x33, 0xf4, 0x9b, 0xa2, 0xe2, 0x95, 0x1e, 0xeb, 0xa3, 0x34, 0xb5, 0x79, 0xcb,
	0xb8, 0xd4, 0x25, 0x42, 0x58, 0x27, 0xd7, 0x32, 0x2e, 0x6b, 0x02, 0xa4, 0xb6, 0x21, 0xff, 0xc2,
	0xf2, 0x4e, 0x4c, 0xd7, 0xb8, 0x60, 0x87, 0xd8, 0x00, 0xdf, 0xed, 0x9d, 0x42, 0x09, 0xff, 0x29,
	0xd4, 0x47, 0xa8, 0x64, 0xbf, 0x9d, 0xf8, 0x7b, 0x05, 0xca, 0x72, 0x27, 0x24, 0x6b, 0x9f, 0xaf,
	0x55, 0xa0, 0x40, 0x7d, 0xed, 0x42, 0x60, 0x64, 0x89, 0xbb, 0x14, 0xde, 0x1a, 0xbf, 0xd4, 0x1a,
	0x75, 0x4f, 0x09, 0x20, 0xdf, 0x8f, 0x33, 0xfa, 0x5d, 0x2f, 0x15, 0x70, 0x3d, 0xf5, 0xbf, 0x15,
	0x58, 0x8c, 0xd5, 0x60, 0x64, 0x9f, 0x3a, 0x80, 0x8c, 0x8b, 0xcf, 0x84, 0x23, 0x51, 0x35, 0x7f,
	0x18, 0xa1, 0xee, 0xcf, 0x67, 0x4d, 0xc3, 0x67, 0x95, 0x96, 0xc7, 0xd3, 0x66, 0xda, 0x65, 0x1f,
	0xe5, 0x5f, 0x41, 0xce, 0x07, 0x8e, 0xc9, 0x76, 0x3f, 0x0e, 0x66, 0xbb, 0x5b, 0xc3, 0x30, 0xf4,
	0xa5, 0xbc, 0x7f, 0x57, 0x7a, 0x71, 0xe4, 0x23, 0xe9, 0x13, 0x1d, 0xca, 0x50, 0xd1, 0x91, 0x18,
	0x18, 0x1d, 0xc9, 0xfe, 0xd1, 0x91, 0x7a, 0xd3, 0xd1, 0xf1, 0x79, 0x02, 0xa6, 0x77, 0x0d, 0xf7,
	0x54, 0x1e, 0x5e, 0xc3, 0x16, 0x57, 0xe8, 0x03, 0xee, 0xc5, 0x84, 0xde, 0xf0, 0x7c, 0x59, 0x38,
	0xe2, 0xc5, 0xfe, 0x02, 0x52, 0xcb, 0x11, 0xb7, 0x5e, 0xc3, 0xb6, 0xc9, 0x02, 0x71, 0x1f, 0x66,
	0xa9, 0x13, 0xb7, 0x2c, 0x5b, 0x77, 0x71, 0x1d, 0x5b, 0xe7, 0x58, 0xac, 0x94, 0x1c, 0x62, 0x25,
	0x64, 0x12, 0x6f, 0xd7, 0xb2, 0x35, 0x31, 0x91, 0x2d, 0x88, 0x20, 0xe5, 0x73, 0x66, 0x36, 0x46,
	0xcb, 0x40, 0x79, 0xd2, 0xba, 0xe3, 0xc4, 0x20, 0x27, 0x22, 0xc5, 0x66, 0x89, 0x5b, 0x3f, 0xbc,
	0x7c, 0x6a, 0x90, 0x13, 0xf4, 0x2e, 0xa4, 0xbc, 0xab, 0x36, 0x37, 0xcd, 0x44, 0x7f, 0x9e, 0x87,
	0x57, 0x6d, 0xac, 0x31, 0x4a, 0xf5, 0x03, 0x98, 0x09, 0x1a, 0x6c, 0xd4, 0x98, 0x50, 0x57, 0xd9,
	0xf9, 0xb7, 0x73, 0x40, 0x85, 0xde, 0xb1, 0x88, 0xe7, 0xbb, 0x64, 0xfb, 0x2e, 0x9a, 0x6c, 0xac,
	0xfe, 0x4f, 0x12, 0xd2, 0x9c, 0x72, 0xb4, 0xea, 0x7b, 0x3d, 0x58, 0x7d, 0xbf, 0xf2, 0x3a, 0x81,
	0x96, 0x20, 0xdb, 0x94, 0x57, 0x56, 0xb6, 0x03, 0x8a, 0xd6, 0x03, 0xd0, 0x4b, 0x4d, 0xf7, 0x43,
	0xef, 0x1d, 0x61, 0xf9, 0x2e, 0x90, 0x3a, 0xfd, 0xbb, 0x30, 0x73, 0x62, 0x10, 0x5d, 0x16, 0x34,
	0x04, 0x13, 0x62, 0x39, 0x36, 0x61, 0x46, 0x1f, 0xd7, 0xd0, 0x89, 0x41, 0x1e, 0x73, 0x54, 0x4d,
	0x60, 0xd0, 0x5b, 0x30, 0xd1, 0x6c, 0x53, 0x47, 0xd7, 0xb1, 0xe1, 0xda, 0x96, 0xdd, 0x60, 0xfb,
	0xa0, 0x68, 0xf9, 0x66, 0xfb, 0x31, 0xc6, 0x55, 0x0e, 0x43, 0x0f, 0x61, 0x2e, 0x54, 0x24, 0x49,
	0xea, 0x0c, 0xa3, 0x9e, 0x09, 0x94, 0x47, 0x72, 0xd6, 0x75, 0x80, 0x73, 0xa7, 0xd9, 0x69, 0x61,
	0x7d, 0xe3, 0xe1, 0x09, 0x2b, 0x61, 0x15, 0x2d, 0xcb, 0x21, 0x1b, 0x0f, 0x4f, 0xd0, 0x3b, 0x30,
	0xe9, 0x39, 0x9e, 0xd1, 0xd4, 0x7b, 0x5a, 0x67, 0x19, 0xcd, 0x04, 0x03, 0x77, 0xaf, 0xef, 0x68,
	0x0d, 0xa6, 0x43, 0x84, 0xcc, 0x00, 0xbc, 0x82, 0x9d, 0x0a, 0x12, 0x8b, 0x3c, 0x11, 0xd4, 0x49,
	0x37, 0xda, 0x57, 0xa5, 0x1c, 0x5b, 0x7b, 0xd2, 0xaf, 0x57, 0xa5, 0x7d, 0x45, 0xc3, 0x4c, 0xaa,
	0x46, 0xa9, 0xf2, 0x8c, 0x0a, 0x04, 0xa8, 0xd2, 0xbe, 0x52, 0x5d, 0x98, 0x0d, 0xf9, 0xca, 0xc8,
	0x29, 0x78, 0x1d, 0x32, 0xcd, 0xb6, 0x8c, 0xd1, 0x64, 0x1c, 0x35, 0x5f, 0x5e, 0x4b, 0x37, 0xdb,
	0xac, 0x46, 0xfa, 0x47, 0x05, 0x4a, 0x32, 0xf3, 0x75, 0x55, 0x93, 0x4e, 0x7a, 0x13, 0xf2, 0xf2,
	0xe4, 0xd2, 0x5d, 0x7c, 0xc6, 0x04, 0xc8, 0x6b, 0x39, 0x09, 0xd3, 0xf0, 0x19, 0x4d, 0xc9, 0xc4,
	0x6a, 0x30, 0xcf, 0xcb, 0x6b, 0x74, 0x48, 0x77, 0x10, 0x8b, 0x94, 0x6a, 0xf6, 0x82, 0x9d, 0x9a,
	0x91, 0xe7, 0xbe, 0x99, 0x2e, 0x56, 0x06, 0x34, 0xb5, 0xe4, 0x26, 0xe4, 0x5a, 0xd8, 0x3b, 0x71,
	0x4c, 0x9d, 0x85, 0x68, 0x8a, 0x85, 0xa8, 0xda, 0xef, 0x98, 0xdc, 0x65, 0xa4, 0x2c, 0x50, 0xa1,
	0xd5, 0x1d, 0xab, 0xbf, 0x82, 0x85, 0x18, 0x5d, 0x46, 0x36, 0xe2, 0x3c, 0x64, 0x08, 0x3e, 0xd3,
	0xed, 0x4e, 0x4b, 0xf4, 0x7b, 0xd2, 0x04, 0x9f, 0xed, 0x75, 0x5a, 0xea, 0xbf, 0x28, 0x3c, 0x1f,
	0x44, 0x0c, 0x35, 0xcf, 0xcc, 0xee, 0x0b, 0xe8, 0x74, 0xb3, 0xcd, 0xea, 0x3a, 0x51, 0x04, 0x26,
	0x7a, 0x45, 0xe0, 0x75, 0x59, 0xce, 0x32, 0x6a, 0x6e, 0x12, 0x5e, 0xb3, 0xb2, 0x09, 0xfe, 0x8a,
	0x25, 0x15, 0xac, 0x58, 0x7c, 0x62, 0x8d, 0xf9, 0xc5, 0xa2, 0x08, 0x99, 0xf3, 0x78, 0xef, 0x22,
	0xed, 0xf1, 0x84, 0xb7, 0x2a, 0x12, 0x1e, 0xbf, 0x12, 0xc6, 0xb8, 0x82, 0x2f, 0xd5, 0x55, 0x60,
	0x36, 0xa4, 0xda, 0xc8, 0xb9, 0xee, 0x5d, 0x28, 0x3f, 0xb7, 0xe9, 0x15, 0xef, 0xb1, 0x3f, 0x46,
	0x07, 0x65, 0xbc, 0x27, 0xb0, 0x18, 0x3b, 0x63, 0x64, 0xd6, 0x0f, 0x61, 0xf9, 0x09, 0xf6, 0x02,
	0xab, 0x6c, 0x61, 0xcf, 0xb0, 0x9a, 0x64, 0x10, 0xfb, 0x3f, 0x54, 0xe0, 0x46, 0xdf, 0x69, 0x23,
	0xbb, 0xcd, 0x4f, 0x21, 0x63, 0xf2, 0xc9, 0x22, 0xf6, 0xb8, 0xfb, 0xca, 0x06, 0xee, 0xf9, 0x83,
	0x35, 0x71, 0xa7, 0x6b, 0x1a, 0x56, 0x4b, 0xb2, 0x91, 0x53, 0xd4, 0xcf, 0x15, 0x58, 0x8c, 0x6f,
	0x26, 0x76, 0x5d, 0x4c, 0xee, 0xbe, 0xd2, 0x6f, 0xf7, 0x13, 0x81, 0xdd, 0xf7, 0x39, 0x65, 0x32,
	0xe0, 0x94, 0x03, 0x7c, 0x4c, 0x7a, 0xcc, 0xd8, 0x10, 0x1e, 0xf3, 0x97, 0x49, 0x98, 0x0c, 0x75,
	0x43, 0xfe, 0x3f, 0x4a, 0x89, 0xa7, 0xbc, 0xc7, 0x30, 0x7a, 0x19, 0x31, 0x69, 0xd2, 0x94, 0xea,
	0xab, 0x21, 0x26, 0x20, 0xe1, 0x11, 0x66, 0x81, 0x94, 0x96, 0xf0, 0x48, 0x7c, 0xa3, 0x63, 0x6c,
	0xf8, 0x46, 0x47, 0x3a, 0xae, 0xd1, 0xe1, 0xeb, 0x28, 0x65, 0x5e, 0xa7, 0xa3, 0x14, 0xe9, 0xef,
	0x8c, 0x8f, 0xd6, 0xdf, 0x51, 0xff, 0x2b, 0x01, 0xd9, 0x6e, 0xf7, 0xf8, 0x0d, 0x17, 0x16, 0x7d,
	0x5a, 0x7b, 0x11, 0x4b, 0x47, 0x7a, 0xc8, 0x63, 0xd1, 0x1e, 0x72, 0xaf, 0x25, 0x9e, 0x1e, 0xad,
	0x25, 0x3e, 0x42, 0xd6, 0xf3, 0x47, 0xd5, 0x78, 0x20, 0xaa, 0x42, 0xe7, 0x51, 0xf6, 0xb5, 0xce,
	0xa3, 0x33, 0x98, 0x0b, 0x6d, 0xae, 0x8c, 0xe6, 0xb7, 0x61, 0xd2, 0xc6, 0x97, 0x9e, 0x2e, 0xaa,
	0x7b, 0xd9, 0xcd, 0xcd, 0x6a, 0x05, 0x0a, 0x3e, 0x60, 0x95, 0x3d, 0x35, 0xe8, 0x22, 0x64, 0x19,
	0x09, 0xb1, 0x5e, 0xca, 0xc7, 0x87, 0x71, 0x0a, 0xa8, 0x59, 0x2f, 0x71, 0x37, 0xa5, 0x25, 0x7d,
	0x29, 0xed, 0x1f, 0x14, 0x98, 0x8f, 0xf0, 0x1c, 0x39, 0x95, 0xfd, 0x18, 0x32, 0x27, 0x7c, 0xb2,
	0x48, 0x65, 0x37, 0xfa, 0x45, 0x96, 0xe4, 0x21, 0xe9, 0xe3, 0x34, 0x4b, 0xc6, 0x69, 0x76, 0x13,
	0xf2, 0xf5, 0x8e, 0xeb, 0x62, 0xdb, 0xe3, 0xca, 0x71, 0xe7, 0xc8, 0x09, 0x18, 0xd5, 0x4f, 0x3d,
	0x85, 0x62, 0x77, 0x8f, 0xdf, 0xb8, 0xe1, 0xfe, 0x4e, 0x81, 0x29, 0x1f, 0xb7, 0x91, 0x4d, 0xf6,
	0x5e, 0xd8, 0x64, 0x0b, 0x51, 0xc7, 0x7b, 0x93, 0xc6, 0x5a, 0x85, 0x19, 0x7e, 0xbc, 0x58, 0x76,
	0x63, 0xcb, 0xf0, 0x8c, 0xc1, 0xc7, 0x6e, 0x9a, 0xd3, 0xca, 0xfa, 0x44, 0x61, 0xb5, 0x28, 0xab,
	0x4f, 0x46, 0x69, 0xe5, 0xab, 0x7f, 0x90, 0x84, 0xd9, 0x10, 0xd7, 0xd7, 0xe8, 0x1a, 0x64, 0x3b,
	0xc4, 0xd4, 0xdb, 0xae, 0x55, 0xc7, 0xc2, 0x74, 0xef, 0x85, 0xe9, 0x63, 0x79, 0xac, 0x3d, 0x27,
	0xe6, 0x01, 0x9d, 0xc5, 0x7b, 0x06, 0xe3, 0x1d, 0xf1, 0x89, 0x7e, 0x01, 0xd7, 0xb9, 0x81, 0xad,
	0xba, 0xd1, 0xd4, 0xeb, 0x9d, 0x56, 0xa7, 0x69, 0x78, 0xd6, 0x39, 0x16, 0x37, 0x0a, 0x22, 0xfa,
	0xba, 0x73, 0xf1, 0x5c, 0xb4, 0xc5, 0xde, 0xe4, 0xcd, 0xee, 0x5c, 0x8e, 0x23, 0xe8, 0x43, 0x58,
	0xec, 0xb0, 0x8a, 0x05, 0x9b, 0x71, 0x2b, 0xa7, 0x06, 0xae, 0xbc, 0x20, 0xa7, 0x46, 0xd6, 0x2d,
	0xff, 0x04, 0x0a, 0x01, 0x75, 0xfc, 0xbd, 0x8e, 0x2c, 0xef, 0x75, 0xcc, 0xf8, 0x7b, 0x1d, 0x8a,
	0xbf, 0x8d, 0xf1, 0xc7, 0x0a, 0xa0, 0xe7, 0x6d, 0xd3, 0xf0, 0x30, 0x4f, 0xdf, 0x62, 0xeb, 0x47,
	0xca, 0xf5, 0x2a, 0x14, 0xbc, 0x4b, 0xbd, 0xe3, 0x36, 0xf5, 0xb6, 0x8b, 0x8f, 0xad, 0xcb, 0x6e,
	0x33, 0xf7, 0xf2, 0xb9, 0xdb, 0x3c, 0x60, 0x20, 0x59, 0xec, 0x27, 0x7b, 0xc5, 0x7e, 0xcc, 0x35,
	0x5c, 0xfd, 0x44, 0x81, 0xe9, 0x80, 0x34, 0xaf, 0xd1, 0x9c, 0x14, 0x82, 0x27, 0x5e, 0x47, 0xf0,
	0x64, 0x44, 0x70, 0xf5, 0x6f, 0xba, 0x06, 0xe2, 0xee, 0xfb, 0x7d, 0xb4, 0xb6, 0x7b, 0x95, 0x3c,
	0x7b, 0x60, 0xf3, 0x57, 0xf2, 0x7b, 0x46, 0x0b, 0xf7, 0xd0, 0xec, 0xad, 0x2d, 0xe5, 0x43, 0x6f,
	0xd7, 0x1d, 0x5b, 0xda, 0x72, 0x2c, 0x6a, 0xcb, 0xb4, 0xcf, 0x96, 0x6d, 0x69, 0x4a, 0x21, 0xf7,
	0x6b, 0x5c, 0x08, 0x47, 0x3b, 0xc2, 0xd5, 0x39, 0x98, 0xa9, 0x79, 0xc6, 0xa9, 0x65, 0x37, 0xf8,
	0xdb, 0x86, 0x7c, 0x92, 0xf9, 0x42, 0x81, 0xd9, 0x10, 0x42, 0x08, 0xf3, 0x0e, 0x4c, 0x9e, 0x5b,
	0xf8, 0x02, 0xbb, 0xdd, 0xf7, 0x0c, 0xe1, 0xb5, 0x13, 0x1c, 0x2c, 0xdf, 0x30, 0xd0, 0x5d, 0x28,
	0x12, 0xbe, 0x42, 0x8f, 0x52, 0x74, 0x9c, 0x49, 0x77, 0x65, 0x4e, 0xfa, 0x9b, 0x30, 0x2f, 0x49,
	0x43, 0x6f, 0x25, 0xc2, 0xd0, 0xb3, 0x02, 0x1d, 0x7c, 0x26, 0x61, 0x0f, 0xb2, 0xb8, 0xe9, 0x93,
	0x44, 0xf4, 0x2e, 0x28, 0x50, 0x12, 0xa9, 0xdb, 0xf2, 0x9e, 0x52, 0xf3, 0xaf, 0xd1, 0x8b, 0x9a,
	0x29, 0x13, 0x37, 0x71, 0xc3, 0xf0, 0x1c, 0xde, 0x30, 0xc5, 0x84, 0x08, 0x85, 0x8a, 0x5d, 0x44,
	0x85, 0xc3, 0x7b, 0x17, 0x98, 0xd0, 0x52, 0x23, 0x5f, 0x60, 0x76, 0xd9, 0x05, 0x26, 0xb0, 0x4a,
	0xe8, 0x02, 0x33, 0x92, 0x5c, 0x9f, 0xf0, 0x9b, 0x4d, 0xfc, 0x7a, 0x23, 0x3b, 0xd1, 0x26, 0xa4,
	0xf9, 0x35, 0x45, 0x78, 0xd1, 0x3d, 0x46, 0x1c, 0xf8, 0xd9, 0xc9, 0xf9, 0x83, 0xb5, 0x00, 0x33,
	0x76, 0xc9, 0xe1, 0x9d, 0x06, 0x3e, 0x55, 0xb5, 0xe1, 0x07, 0xec, 0x25, 0xc8, 0xdf, 0x43, 0x39,
	0x70, 0x9d, 0x73, 0xcb, 0xc4, 0x2e, 0xf3, 0xc2, 0x47, 0x46, 0xd3, 0xb0, 0xeb, 0x58, 0xea, 0xbb,
	0x08, 0x59, 0x19, 0x9c, 0xbc, 0x6d, 0x5e, 0xd0, 0xc6, 0x45, 0x74, 0x92, 0x61, 0x5e, 0x9e, 0x3e,
	0x4e, 0xc0, 0xfd, 0x21, 0x19, 0x8e, 0x6c, 0x90, 0x13, 0xc8, 0x76, 0xfb, 0x44, 0xe2, 0xcc, 0x7a,
	0x16, 0xf7, 0x4a, 0x38, 0x34, 0xef, 0x35, 0x49, 0x2a, 0xce, 0x32, 0xd9, 0x6a, 0xa2, 0xe7, 0x42,
	0x00, 0xe5, 0x3f, 0x17, 0x52, 0x31, 0xe7, 0x42, 0xd6, 0x7f, 0x2e, 0x3c, 0x81, 0x34, 0x97, 0x1a,
	0xdd, 0x83, 0x54, 0xdd, 0x31, 0xf9, 0x6f, 0x7a, 0x26, 0x36, 0xe6, 0x63, 0x74, 0xdb, 0x74, 0x4c,
	0xac, 0x31, 0x22, 0xca, 0xa2, 0x45, 0x1a, 0xb2, 0x69, 0xd1, 0x22, 0x8d, 0xd5, 0x5f, 0xf6, 0x7e,
	0x1c, 0x40, 0x0b, 0x5b, 0xb4, 0x00, 0xb3, 0x87, 0x5a, 0x65, 0xaf, 0xf6, 0xb8, 0xaa, 0xe9, 0x87,
	0xbf, 0x73, 0x50, 0xd5, 0x9f, 0xef, 0x3d, 0xdb, 0xdb, 0x7f, 0xb1, 0x57, 0xbc, 0x86, 0xe6, 0x00,
	0x05, 0x51, 0xb5, 0xea, 0xde, 0x56, 0x51, 0x41, 0x25, 0x98, 0x09, 0xc2, 0xb5, 0xea, 0xe3, 0xe7,
	0x7b, 0x5b, 0xc5, 0xc4, 0xea, 0x23, 0x48, 0xf3, 0x9a, 0x1c, 0x4d, 0xc3, 0xe4, 0xce, 0x41, 0x78,
	0xc1, 0x49, 0xc8, 0x49, 0x60, 0x65, 0x8b, 0xae, 0x84, 0x60, 0x42, 0x02, 0xb4, 0xea, 0xee, 0xfe,
	0x87, 0xd5, 0x62, 0x62, 0xf5, 0x4f, 0x15, 0x40, 0xd1, 0x62, 0x1c, 0x2d, 0x41, 0xe9, 0xc5, 0x96,
	0xbe, 0x5b, 0x3d, 0x7c, 0xba, 0xbf, 0x25, 0xd7, 0xdd, 0xaa, 0x3e, 0xde, 0xde, 0xab, 0x6e, 0x15,
	0xaf, 0x51, 0x2d, 0x42, 0xd8, 0xfd, 0xbd, 0xaa, 0xae, 0xed, 0x16, 0x15, 0x74, 0x1d, 0x16, 0x42,
	0xa8, 0xca, 0xce, 0x8e, 0xbe, 0xbd, 0x47, 0x29, 0x8a, 0x09, 0xb4, 0x02, 0x4b, 0x21, 0x74, 0xed,
	0xb0, 0xf2, 0x6c, 0x7b, 0xef, 0x89, 0xbe, 0xb9, 0x53, 0xd9, 0xde, 0x2d, 0x26, 0x57, 0x3f, 0x82,
	0x8c, 0x30, 0x2a, 0xd5, 0xbc, 0xaa, 0x69, 0xfb, 0x9a, 0xbe, 0xb9, 0xbf, 0x15, 0x14, 0x60, 0x0e,
	0xa6, 0x7c, 0x98, 0xcd, 0xfd, 0xdd, 0xdd, 0xfd, 0xbd, 0xe2, 0x7f, 0x26, 0xd1, 0x0a, 0x2c, 0x72,
	0xf8, 0xde, 0xbe, 0x7e, 0xb8, 0xff, 0xac, 0x4a, 0xd9, 0xea, 0x5b, 0xb5, 0x43, 0x7d, 0xf3, 0x69,
	0x65, 0x7b, 0xaf, 0xf8, 0x5d, 0x26, 0x9e, 0xa2, 0xa6, 0x6d, 0x0a, 0x8a, 0x7f, 0xcb, 0x6c, 0x7c,
	0x3b, 0x0f, 0xc9, 0x17, 0xf8, 0x08, 0xd1, 0xda, 0x20, 0xfa, 0x60, 0x8d, 0xee, 0x0e, 0xf3, 0xa8,
	0xcd, 0x02, 0xb1, 0xbc, 0x3a, 0xfc, 0xfb, 0xb7, 0xba, 0xfc, 0xfb, 0xff, 0xf4, 0xed, 0x67, 0x89,
	0x12, 0x9a, 0x63, 0x3f, 0xa0, 0x8b, 0xb2, 0x25, 0x90, 0xf7, 0x3f, 0x07, 0xa3, 0x5b, 0xb1, 0x51,
	0x13, 0x7c, 0x81, 0x2e, 0xbf, 0x35, 0x98, 0x48, 0xb0, 0x2e, 0x31, 0xd6, 0x08, 0x15, 0x25, 0xeb,
	0x2e, 0x13, 0x07, 0x72, 0xbe, 0xc7, 0x52, 0xa4, 0xf6, 0x7b, 0x24, 0xea, 0xbd, 0xdb, 0x95, 0x6f,
	0x0d, 0xa4, 0x11, 0x1c, 0xe7, 0x19, 0xc7, 0x29, 0x34, 0x49, 0x39, 0x62, 0x1f, 0x87, 0x73, 0xc8,
	0xfb, 0x9f, 0x0d, 0xa2, 0x5a, 0xc6, 0xbc, 0xc2, 0x44, 0xb5, 0x8c, 0x7b, 0x79, 0x50, 0x17, 0x19,
	0xcf, 0x59, 0x95, 0x69, 0xd9, 0xf2, 0x51, 0xbc, 0xaf, 0xac, 0xa2, 0x3f, 0x52, 0x60, 0x2a, 0xf2,
	0x23, 0x18, 0x74, 0x67, 0xc0, 0xfe, 0x05, 0x7a, 0x4c, 0xe5, 0xbb, 0x43, 0x50, 0x0a, 0x39, 0x56,
	0x98, 0x1c, 0x65, 0x75, 0x36, 0xb4, 0xd1, 0x9c, 0x8c, 0x0a, 0x73, 0x01, 0x85, 0x40, 0x37, 0x1b,
	0xc5, 0x6d, 0x63, 0xe4, 0x61, 0xa4, 0x7c, 0xfb, 0x15, 0x54, 0x82, 0xff, 0x02, 0xe3, 0x3f, 0x8d,
	0xa6, 0x04, 0x7f, 0x1f, 0x9f, 0x97, 0x50, 0x08, 0x74, 0x32, 0x51, 0xac, 0x65, 0xc3, 0x3d, 0xdc,
	0x28, 0xe3, 0xd8, 0x76, 0xa8, 0xba, 0xc4, 0x18, 0xcf, 0xa9, 0x53, 0x72, 0x03, 0xba, 0x24, 0x72,
	0x07, 0x22, 0x2d, 0xe8, 0xe8, 0x0e, 0xf4, 0xeb, 0xb8, 0x47, 0x77, 0xa0, 0x6f, 0x3f, 0x3b, 0xb8,
	0x03, 0x17, 0x61, 0x32, 0x21, 0x4c, 0xec, 0xeb, 0xe6, 0xea, 0x50, 0xcf, 0xb2, 0x5c, 0xa0, 0x7b,
	0x23, 0x3c, 0xe1, 0xaa, 0x65, 0x26, 0xd2, 0x8c, 0x1a, 0x0e, 0x08, 0x2a, 0xcc, 0x67, 0x0a, 0xcc,
	0xc4, 0xf5, 0x37, 0x51, 0x84, 0xc3, 0x80, 0x2e, 0x68, 0xf9, 0x07, 0xc3, 0x11, 0x07, 0x4d, 0x84,
	0x4a, 0xdd, 0x9f, 0xe0, 0x86, 0x99, 0x7f, 0x4a, 0xef, 0x2a, 0xd1, 0x0e, 0x74, 0xd4, 0x44, 0xfd,
	0x1b, 0xdb, 0x51, 0x13, 0x0d, 0x68, 0x69, 0xab, 0x2a, 0x13, 0x69, 0x49, 0x9d, 0xa7, 0x22, 0x75,
	0xa2, 0x84, 0xd4, 0x54, 0x7f, 0xa1, 0xc0, 0x7c, 0x9f, 0xb6, 0x34, 0x5a, 0x8b, 0x09, 0x8f, 0x01,
	0x6d, 0xef, 0xf2, 0xfa, 0xd0, 0xf4, 0x42, 0xc0, 0x5b, 0x4c, 0xc0, 0xeb, 0x68, 0x51, 0x04, 0x56,
	0xac, 0x14, 0x1f, 0x45, 0x3b, 0xbf, 0x6f, 0xbf, 0xaa, 0x43, 0x24, 0x04, 0x7a, 0xe7, 0x95, 0x74,
	0xc1, 0x4c, 0x87, 0xa6, 0xa9, 0x20, 0x5e, 0x88, 0x5b, 0xc3, 0xdf, 0xd3, 0x5c, 0xe9, 0xdf, 0x69,
	0x11, 0x4c, 0x6f, 0x0e, 0xa0, 0x10, 0xec, 0x66, 0x19, 0xbb, 0x49, 0x54, 0xa0, 0xec, 0x9a, 0x6d,
	0xb9, 0xf6, 0x05, 0x14, 0x02, 0xcd, 0x87, 0x68, 0x32, 0x89, 0xeb, 0xba, 0x44, 0x93, 0x49, 0x6c,
	0x07, 0x23, 0x98, 0xc5, 0xdc, 0x00, 0x9f, 0x8f, 0xa0, 0x10, 0xb8, 0x6e, 0x45, 0x19, 0xc7, 0x5d,
	0xd3, 0xa2, 0x8c, 0x63, 0xef, 0x6c, 0xea, 0x4d, 0xc6, 0x78, 0x11, 0x2d, 0x50, 0xc6, 0xe2, 0x2a,
	0xb5, 0x4e, 0x02, 0xfc, 0xfe, 0xbc, 0x1b, 0x1a, 0x81, 0xc2, 0xbe, 0x5f, 0x68, 0xc4, 0xdd, 0xa5,
	0xfa, 0x85, 0x46, 0xec, 0x65, 0x49, 0x5d, 0x65, 0x32, 0xbd, 0xa5, 0xde, 0xf0, 0xcb, 0xd4, 0x89,
	0x4e, 0xa0, 0x21, 0xf2, 0x57, 0x3c, 0x44, 0xe2, 0xee, 0x37, 0xb1, 0x21, 0x32, 0xe0, 0x62, 0x15,
	0x1b, 0x22, 0x83, 0x2e, 0x4e, 0xea, 0x3d, 0x26, 0xe8, 0x6d, 0x74, 0xcb, 0x2f, 0x68, 0xa3, 0x8f,
	0x34, 0x5f, 0x29, 0x70, 0x7b, 0xa8, 0xab, 0x00, 0xfa, 0xe9, 0x6b, 0xde, 0x20, 0xb8, 0x16, 0x3f,
	0xfb, 0x3f, 0xdd, 0x3f, 0xd4, 0x07, 0x4c, 0xa7, 0x7b, 0xe8, 0x6e, 0xb7, 0x7a, 0x7a, 0xa5, 0xbc,
	0x57, 0x90, 0xf3, 0xb5, 0x79, 0xa2, 0x65, 0x55, 0xb4, 0x23, 0x15, 0x2d, 0xab, 0x62, 0xfa, 0x44,
	0xd2, 0x37, 0x55, 0x56, 0x43, 0xd6, 0x99, 0x33, 0xae, 0x77, 0x7a, 0x74, 0x74, 0xfb, 0xbb, 0xac,
	0x79, 0x7b, 0xb4, 0x0f, 0x6b, 0x7f, 0xaf, 0xa7, 0x1f, 0xeb, 0x40, 0x5f, 0x65, 0x00, 0x6b, 0x46,
	0x47, 0x59, 0xff, 0x09, 0xaf, 0xb1, 0x82, 0xff, 0x65, 0x88, 0xad, 0xb1, 0x62, 0xff, 0x5d, 0x11,
	0x5b, 0x63, 0xc5, 0xff, 0x31, 0x42, 0x9e, 0x15, 0xa8, 0x2c, 0xf6, 0x44, 0x92, 0xed, 0x60, 0xc3,
	0xc4, 0xee, 0x23, 0xc7, 0x70, 0xcd, 0x47, 0x4f, 0xbf, 0xf8, 0x7a, 0x59, 0xf9, 0xf2, 0xeb, 0x65,
	0xe5, 0x5f, 0xbf, 0x5e, 0x56, 0x3e, 0xf9, 0x66, 0xf9, 0xda, 0x97, 0xdf, 0x2c, 0x5f, 0xfb, 0xe7,
	0x6f, 0x96, 0xaf, 0xfd, 0x62, 0xad, 0x61, 0x79, 0x27, 0x9d, 0xa3, 0xb5, 0xba, 0xd3, 0x5a, 0xaf,
	0xe3, 0x26, 0x76, 0xef, 0xdb, 0xd8, 0xbb, 0x70, 0xdc, 0xd3, 0x75, 0xd2, 0xb0, 0xef, 0x9f, 0x6f,
	0x74, 0xff, 0xea, 0x72, 0x81, 0x8f, 0x8c, 0xb6, 0x75, 0x94, 0x66, 0xff, 0x0c, 0x79, 0xef, 0x7f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0xdb, 0xfe, 0x38, 0x6a, 0x07, 0x33, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WebClient is the client API for Web service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WebClient interface {
	// get chain and token selector
	// after getting these info, remember to record them(especially decimal)
	GetTransferConfigs(ctx context.Context, in *GetTransferConfigsRequest, opts ...grpc.CallOption) (*GetTransferConfigsResponse, error)
	// get chain and token info
	GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoResponse, error)
	// estimate transfer fee
	EstimateAmt(ctx context.Context, in *EstimateAmtRequest, opts ...grpc.CallOption) (*EstimateAmtResponse, error)
	// same as V1, call this api after user confirm transfer on metamask
	MarkTransfer(ctx context.Context, in *MarkTransferRequest, opts ...grpc.CallOption) (*MarkTransferResponse, error)
	GetTransferStatus(ctx context.Context, in *GetTransferStatusRequest, opts ...grpc.CallOption) (*GetTransferStatusResponse, error)
	//LP
	// get LP table info
	GetLPInfoList(ctx context.Context, in *GetLPInfoListRequest, opts ...grpc.CallOption) (*GetLPInfoListResponse, error)
	MarkLiquidity(ctx context.Context, in *MarkLiquidityRequest, opts ...grpc.CallOption) (*MarkLiquidityResponse, error)
	//https://github.com/celer-network/sgn-v2/blob/main/proto/sgn/cbridge/v1/tx.proto#L10
	// remove liquidity or refund transfer calling this api
	WithdrawLiquidity(ctx context.Context, in *WithdrawLiquidityRequest, opts ...grpc.CallOption) (*WithdrawLiquidityResponse, error)
	// estimate transfer fee
	// front end need post method for this api
	EstimateWithdrawAmt(ctx context.Context, in *EstimateWithdrawAmtRequest, opts ...grpc.CallOption) (*EstimateWithdrawAmtResponse, error)
	// bcz it's time cost for sgn voting, so we need a polling api to check the status
	QueryLiquidityStatus(ctx context.Context, in *QueryLiquidityStatusRequest, opts ...grpc.CallOption) (*QueryLiquidityStatusResponse, error)
	// web will use this api to init reward cliam
	UnlockFarmingReward(ctx context.Context, in *UnlockFarmingRewardRequest, opts ...grpc.CallOption) (*UnlockFarmingRewardResponse, error)
	// web polling this api after UnlockFarmingReward
	GetFarmingRewardDetails(ctx context.Context, in *GetFarmingRewardDetailsRequest, opts ...grpc.CallOption) (*GetFarmingRewardDetailsResponse, error)
	//History
	TransferHistory(ctx context.Context, in *TransferHistoryRequest, opts ...grpc.CallOption) (*TransferHistoryResponse, error)
	LPHistory(ctx context.Context, in *LPHistoryRequest, opts ...grpc.CallOption) (*LPHistoryResponse, error)
	RewardingData(ctx context.Context, in *RewardingDataRequest, opts ...grpc.CallOption) (*RewardingDataResponse, error)
	// staking api
	StakingConfig(ctx context.Context, in *StakingConfigRequest, opts ...grpc.CallOption) (*StakingConfigResponse, error)
	// web will use this api to init distribution reward claim
	UnlockStakingReward(ctx context.Context, in *UnlockStakingRewardRequest, opts ...grpc.CallOption) (*UnlockStakingRewardResponse, error)
	// web polling this api after UnlockStakingReward
	GetStakingRewardDetails(ctx context.Context, in *GetStakingRewardDetailsRequest, opts ...grpc.CallOption) (*GetStakingRewardDetailsResponse, error)
	// Safeguarding apis
	GetTotalLiquidityProviderTokenBalance(ctx context.Context, in *GetTotalLiquidityProviderTokenBalanceRequest, opts ...grpc.CallOption) (*GetTotalLiquidityProviderTokenBalanceResponse, error)
	// configs api, apis in these service need sign valid addr
	UpdateChain(ctx context.Context, in *UpdateChainRequest, opts ...grpc.CallOption) (*UpdateChainResponse, error)
	UpdateToken(ctx context.Context, in *UpdateTokenRequest, opts ...grpc.CallOption) (*UpdateTokenResponse, error)
	GetCampaignScores(ctx context.Context, in *GetCampaignScoresRequest, opts ...grpc.CallOption) (*GetCampaignScoresResponse, error)
}

type webClient struct {
	cc grpc1.ClientConn
}

func NewWebClient(cc grpc1.ClientConn) WebClient {
	return &webClient{cc}
}

func (c *webClient) GetTransferConfigs(ctx context.Context, in *GetTransferConfigsRequest, opts ...grpc.CallOption) (*GetTransferConfigsResponse, error) {
	out := new(GetTransferConfigsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTransferConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTokenInfo(ctx context.Context, in *GetTokenInfoRequest, opts ...grpc.CallOption) (*GetTokenInfoResponse, error) {
	out := new(GetTokenInfoResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTokenInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) EstimateAmt(ctx context.Context, in *EstimateAmtRequest, opts ...grpc.CallOption) (*EstimateAmtResponse, error) {
	out := new(EstimateAmtResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/EstimateAmt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) MarkTransfer(ctx context.Context, in *MarkTransferRequest, opts ...grpc.CallOption) (*MarkTransferResponse, error) {
	out := new(MarkTransferResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/MarkTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTransferStatus(ctx context.Context, in *GetTransferStatusRequest, opts ...grpc.CallOption) (*GetTransferStatusResponse, error) {
	out := new(GetTransferStatusResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTransferStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetLPInfoList(ctx context.Context, in *GetLPInfoListRequest, opts ...grpc.CallOption) (*GetLPInfoListResponse, error) {
	out := new(GetLPInfoListResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetLPInfoList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) MarkLiquidity(ctx context.Context, in *MarkLiquidityRequest, opts ...grpc.CallOption) (*MarkLiquidityResponse, error) {
	out := new(MarkLiquidityResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/MarkLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) WithdrawLiquidity(ctx context.Context, in *WithdrawLiquidityRequest, opts ...grpc.CallOption) (*WithdrawLiquidityResponse, error) {
	out := new(WithdrawLiquidityResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/WithdrawLiquidity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) EstimateWithdrawAmt(ctx context.Context, in *EstimateWithdrawAmtRequest, opts ...grpc.CallOption) (*EstimateWithdrawAmtResponse, error) {
	out := new(EstimateWithdrawAmtResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/EstimateWithdrawAmt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) QueryLiquidityStatus(ctx context.Context, in *QueryLiquidityStatusRequest, opts ...grpc.CallOption) (*QueryLiquidityStatusResponse, error) {
	out := new(QueryLiquidityStatusResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/QueryLiquidityStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UnlockFarmingReward(ctx context.Context, in *UnlockFarmingRewardRequest, opts ...grpc.CallOption) (*UnlockFarmingRewardResponse, error) {
	out := new(UnlockFarmingRewardResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UnlockFarmingReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetFarmingRewardDetails(ctx context.Context, in *GetFarmingRewardDetailsRequest, opts ...grpc.CallOption) (*GetFarmingRewardDetailsResponse, error) {
	out := new(GetFarmingRewardDetailsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetFarmingRewardDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) TransferHistory(ctx context.Context, in *TransferHistoryRequest, opts ...grpc.CallOption) (*TransferHistoryResponse, error) {
	out := new(TransferHistoryResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/TransferHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) LPHistory(ctx context.Context, in *LPHistoryRequest, opts ...grpc.CallOption) (*LPHistoryResponse, error) {
	out := new(LPHistoryResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/LPHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) RewardingData(ctx context.Context, in *RewardingDataRequest, opts ...grpc.CallOption) (*RewardingDataResponse, error) {
	out := new(RewardingDataResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/RewardingData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) StakingConfig(ctx context.Context, in *StakingConfigRequest, opts ...grpc.CallOption) (*StakingConfigResponse, error) {
	out := new(StakingConfigResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/StakingConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UnlockStakingReward(ctx context.Context, in *UnlockStakingRewardRequest, opts ...grpc.CallOption) (*UnlockStakingRewardResponse, error) {
	out := new(UnlockStakingRewardResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UnlockStakingReward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetStakingRewardDetails(ctx context.Context, in *GetStakingRewardDetailsRequest, opts ...grpc.CallOption) (*GetStakingRewardDetailsResponse, error) {
	out := new(GetStakingRewardDetailsResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetStakingRewardDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetTotalLiquidityProviderTokenBalance(ctx context.Context, in *GetTotalLiquidityProviderTokenBalanceRequest, opts ...grpc.CallOption) (*GetTotalLiquidityProviderTokenBalanceResponse, error) {
	out := new(GetTotalLiquidityProviderTokenBalanceResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetTotalLiquidityProviderTokenBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UpdateChain(ctx context.Context, in *UpdateChainRequest, opts ...grpc.CallOption) (*UpdateChainResponse, error) {
	out := new(UpdateChainResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UpdateChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) UpdateToken(ctx context.Context, in *UpdateTokenRequest, opts ...grpc.CallOption) (*UpdateTokenResponse, error) {
	out := new(UpdateTokenResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/UpdateToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webClient) GetCampaignScores(ctx context.Context, in *GetCampaignScoresRequest, opts ...grpc.CallOption) (*GetCampaignScoresResponse, error) {
	out := new(GetCampaignScoresResponse)
	err := c.cc.Invoke(ctx, "/sgn.gateway.v1.Web/GetCampaignScores", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebServer is the server API for Web service.
type WebServer interface {
	// get chain and token selector
	// after getting these info, remember to record them(especially decimal)
	GetTransferConfigs(context.Context, *GetTransferConfigsRequest) (*GetTransferConfigsResponse, error)
	// get chain and token info
	GetTokenInfo(context.Context, *GetTokenInfoRequest) (*GetTokenInfoResponse, error)
	// estimate transfer fee
	EstimateAmt(context.Context, *EstimateAmtRequest) (*EstimateAmtResponse, error)
	// same as V1, call this api after user confirm transfer on metamask
	MarkTransfer(context.Context, *MarkTransferRequest) (*MarkTransferResponse, error)
	GetTransferStatus(context.Context, *GetTransferStatusRequest) (*GetTransferStatusResponse, error)
	//LP
	// get LP table info
	GetLPInfoList(context.Context, *GetLPInfoListRequest) (*GetLPInfoListResponse, error)
	MarkLiquidity(context.Context, *MarkLiquidityRequest) (*MarkLiquidityResponse, error)
	//https://github.com/celer-network/sgn-v2/blob/main/proto/sgn/cbridge/v1/tx.proto#L10
	// remove liquidity or refund transfer calling this api
	WithdrawLiquidity(context.Context, *WithdrawLiquidityRequest) (*WithdrawLiquidityResponse, error)
	// estimate transfer fee
	// front end need post method for this api
	EstimateWithdrawAmt(context.Context, *EstimateWithdrawAmtRequest) (*EstimateWithdrawAmtResponse, error)
	// bcz it's time cost for sgn voting, so we need a polling api to check the status
	QueryLiquidityStatus(context.Context, *QueryLiquidityStatusRequest) (*QueryLiquidityStatusResponse, error)
	// web will use this api to init reward cliam
	UnlockFarmingReward(context.Context, *UnlockFarmingRewardRequest) (*UnlockFarmingRewardResponse, error)
	// web polling this api after UnlockFarmingReward
	GetFarmingRewardDetails(context.Context, *GetFarmingRewardDetailsRequest) (*GetFarmingRewardDetailsResponse, error)
	//History
	TransferHistory(context.Context, *TransferHistoryRequest) (*TransferHistoryResponse, error)
	LPHistory(context.Context, *LPHistoryRequest) (*LPHistoryResponse, error)
	RewardingData(context.Context, *RewardingDataRequest) (*RewardingDataResponse, error)
	// staking api
	StakingConfig(context.Context, *StakingConfigRequest) (*StakingConfigResponse, error)
	// web will use this api to init distribution reward claim
	UnlockStakingReward(context.Context, *UnlockStakingRewardRequest) (*UnlockStakingRewardResponse, error)
	// web polling this api after UnlockStakingReward
	GetStakingRewardDetails(context.Context, *GetStakingRewardDetailsRequest) (*GetStakingRewardDetailsResponse, error)
	// Safeguarding apis
	GetTotalLiquidityProviderTokenBalance(context.Context, *GetTotalLiquidityProviderTokenBalanceRequest) (*GetTotalLiquidityProviderTokenBalanceResponse, error)
	// configs api, apis in these service need sign valid addr
	UpdateChain(context.Context, *UpdateChainRequest) (*UpdateChainResponse, error)
	UpdateToken(context.Context, *UpdateTokenRequest) (*UpdateTokenResponse, error)
	GetCampaignScores(context.Context, *GetCampaignScoresRequest) (*GetCampaignScoresResponse, error)
}

// UnimplementedWebServer can be embedded to have forward compatible implementations.
type UnimplementedWebServer struct {
}

func (*UnimplementedWebServer) GetTransferConfigs(ctx context.Context, req *GetTransferConfigsRequest) (*GetTransferConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransferConfigs not implemented")
}
func (*UnimplementedWebServer) GetTokenInfo(ctx context.Context, req *GetTokenInfoRequest) (*GetTokenInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenInfo not implemented")
}
func (*UnimplementedWebServer) EstimateAmt(ctx context.Context, req *EstimateAmtRequest) (*EstimateAmtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateAmt not implemented")
}
func (*UnimplementedWebServer) MarkTransfer(ctx context.Context, req *MarkTransferRequest) (*MarkTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkTransfer not implemented")
}
func (*UnimplementedWebServer) GetTransferStatus(ctx context.Context, req *GetTransferStatusRequest) (*GetTransferStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransferStatus not implemented")
}
func (*UnimplementedWebServer) GetLPInfoList(ctx context.Context, req *GetLPInfoListRequest) (*GetLPInfoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLPInfoList not implemented")
}
func (*UnimplementedWebServer) MarkLiquidity(ctx context.Context, req *MarkLiquidityRequest) (*MarkLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkLiquidity not implemented")
}
func (*UnimplementedWebServer) WithdrawLiquidity(ctx context.Context, req *WithdrawLiquidityRequest) (*WithdrawLiquidityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawLiquidity not implemented")
}
func (*UnimplementedWebServer) EstimateWithdrawAmt(ctx context.Context, req *EstimateWithdrawAmtRequest) (*EstimateWithdrawAmtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EstimateWithdrawAmt not implemented")
}
func (*UnimplementedWebServer) QueryLiquidityStatus(ctx context.Context, req *QueryLiquidityStatusRequest) (*QueryLiquidityStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryLiquidityStatus not implemented")
}
func (*UnimplementedWebServer) UnlockFarmingReward(ctx context.Context, req *UnlockFarmingRewardRequest) (*UnlockFarmingRewardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockFarmingReward not implemented")
}
func (*UnimplementedWebServer) GetFarmingRewardDetails(ctx context.Context, req *GetFarmingRewardDetailsRequest) (*GetFarmingRewardDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFarmingRewardDetails not implemented")
}
func (*UnimplementedWebServer) TransferHistory(ctx context.Context, req *TransferHistoryRequest) (*TransferHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferHistory not implemented")
}
func (*UnimplementedWebServer) LPHistory(ctx context.Context, req *LPHistoryRequest) (*LPHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LPHistory not implemented")
}
func (*UnimplementedWebServer) RewardingData(ctx context.Context, req *RewardingDataRequest) (*RewardingDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardingData not implemented")
}
func (*UnimplementedWebServer) StakingConfig(ctx context.Context, req *StakingConfigRequest) (*StakingConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StakingConfig not implemented")
}
func (*UnimplementedWebServer) UnlockStakingReward(ctx context.Context, req *UnlockStakingRewardRequest) (*UnlockStakingRewardResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockStakingReward not implemented")
}
func (*UnimplementedWebServer) GetStakingRewardDetails(ctx context.Context, req *GetStakingRewardDetailsRequest) (*GetStakingRewardDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStakingRewardDetails not implemented")
}
func (*UnimplementedWebServer) GetTotalLiquidityProviderTokenBalance(ctx context.Context, req *GetTotalLiquidityProviderTokenBalanceRequest) (*GetTotalLiquidityProviderTokenBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalLiquidityProviderTokenBalance not implemented")
}
func (*UnimplementedWebServer) UpdateChain(ctx context.Context, req *UpdateChainRequest) (*UpdateChainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChain not implemented")
}
func (*UnimplementedWebServer) UpdateToken(ctx context.Context, req *UpdateTokenRequest) (*UpdateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateToken not implemented")
}
func (*UnimplementedWebServer) GetCampaignScores(ctx context.Context, req *GetCampaignScoresRequest) (*GetCampaignScoresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCampaignScores not implemented")
}

func RegisterWebServer(s grpc1.Server, srv WebServer) {
	s.RegisterService(&_Web_serviceDesc, srv)
}

func _Web_GetTransferConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransferConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTransferConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTransferConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTransferConfigs(ctx, req.(*GetTransferConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTokenInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTokenInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTokenInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTokenInfo(ctx, req.(*GetTokenInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_EstimateAmt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateAmtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).EstimateAmt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/EstimateAmt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).EstimateAmt(ctx, req.(*EstimateAmtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_MarkTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).MarkTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/MarkTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).MarkTransfer(ctx, req.(*MarkTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTransferStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTransferStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTransferStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTransferStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTransferStatus(ctx, req.(*GetTransferStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetLPInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLPInfoListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetLPInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetLPInfoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetLPInfoList(ctx, req.(*GetLPInfoListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_MarkLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).MarkLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/MarkLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).MarkLiquidity(ctx, req.(*MarkLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_WithdrawLiquidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawLiquidityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).WithdrawLiquidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/WithdrawLiquidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).WithdrawLiquidity(ctx, req.(*WithdrawLiquidityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_EstimateWithdrawAmt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateWithdrawAmtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).EstimateWithdrawAmt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/EstimateWithdrawAmt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).EstimateWithdrawAmt(ctx, req.(*EstimateWithdrawAmtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_QueryLiquidityStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryLiquidityStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).QueryLiquidityStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/QueryLiquidityStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).QueryLiquidityStatus(ctx, req.(*QueryLiquidityStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UnlockFarmingReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockFarmingRewardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UnlockFarmingReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UnlockFarmingReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UnlockFarmingReward(ctx, req.(*UnlockFarmingRewardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetFarmingRewardDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFarmingRewardDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetFarmingRewardDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetFarmingRewardDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetFarmingRewardDetails(ctx, req.(*GetFarmingRewardDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_TransferHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).TransferHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/TransferHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).TransferHistory(ctx, req.(*TransferHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_LPHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LPHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).LPHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/LPHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).LPHistory(ctx, req.(*LPHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_RewardingData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RewardingDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).RewardingData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/RewardingData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).RewardingData(ctx, req.(*RewardingDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_StakingConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StakingConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).StakingConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/StakingConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).StakingConfig(ctx, req.(*StakingConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UnlockStakingReward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockStakingRewardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UnlockStakingReward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UnlockStakingReward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UnlockStakingReward(ctx, req.(*UnlockStakingRewardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetStakingRewardDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStakingRewardDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetStakingRewardDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetStakingRewardDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetStakingRewardDetails(ctx, req.(*GetStakingRewardDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetTotalLiquidityProviderTokenBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTotalLiquidityProviderTokenBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetTotalLiquidityProviderTokenBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetTotalLiquidityProviderTokenBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetTotalLiquidityProviderTokenBalance(ctx, req.(*GetTotalLiquidityProviderTokenBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UpdateChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UpdateChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UpdateChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UpdateChain(ctx, req.(*UpdateChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_UpdateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).UpdateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/UpdateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).UpdateToken(ctx, req.(*UpdateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Web_GetCampaignScores_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCampaignScoresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebServer).GetCampaignScores(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sgn.gateway.v1.Web/GetCampaignScores",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebServer).GetCampaignScores(ctx, req.(*GetCampaignScoresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Web_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sgn.gateway.v1.Web",
	HandlerType: (*WebServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransferConfigs",
			Handler:    _Web_GetTransferConfigs_Handler,
		},
		{
			MethodName: "GetTokenInfo",
			Handler:    _Web_GetTokenInfo_Handler,
		},
		{
			MethodName: "EstimateAmt",
			Handler:    _Web_EstimateAmt_Handler,
		},
		{
			MethodName: "MarkTransfer",
			Handler:    _Web_MarkTransfer_Handler,
		},
		{
			MethodName: "GetTransferStatus",
			Handler:    _Web_GetTransferStatus_Handler,
		},
		{
			MethodName: "GetLPInfoList",
			Handler:    _Web_GetLPInfoList_Handler,
		},
		{
			MethodName: "MarkLiquidity",
			Handler:    _Web_MarkLiquidity_Handler,
		},
		{
			MethodName: "WithdrawLiquidity",
			Handler:    _Web_WithdrawLiquidity_Handler,
		},
		{
			MethodName: "EstimateWithdrawAmt",
			Handler:    _Web_EstimateWithdrawAmt_Handler,
		},
		{
			MethodName: "QueryLiquidityStatus",
			Handler:    _Web_QueryLiquidityStatus_Handler,
		},
		{
			MethodName: "UnlockFarmingReward",
			Handler:    _Web_UnlockFarmingReward_Handler,
		},
		{
			MethodName: "GetFarmingRewardDetails",
			Handler:    _Web_GetFarmingRewardDetails_Handler,
		},
		{
			MethodName: "TransferHistory",
			Handler:    _Web_TransferHistory_Handler,
		},
		{
			MethodName: "LPHistory",
			Handler:    _Web_LPHistory_Handler,
		},
		{
			MethodName: "RewardingData",
			Handler:    _Web_RewardingData_Handler,
		},
		{
			MethodName: "StakingConfig",
			Handler:    _Web_StakingConfig_Handler,
		},
		{
			MethodName: "UnlockStakingReward",
			Handler:    _Web_UnlockStakingReward_Handler,
		},
		{
			MethodName: "GetStakingRewardDetails",
			Handler:    _Web_GetStakingRewardDetails_Handler,
		},
		{
			MethodName: "GetTotalLiquidityProviderTokenBalance",
			Handler:    _Web_GetTotalLiquidityProviderTokenBalance_Handler,
		},
		{
			MethodName: "UpdateChain",
			Handler:    _Web_UpdateChain_Handler,
		},
		{
			MethodName: "UpdateToken",
			Handler:    _Web_UpdateToken_Handler,
		},
		{
			MethodName: "GetCampaignScores",
			Handler:    _Web_GetCampaignScores_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sgn/gateway/v1/gateway.proto",
}

func (m *GetCampaignScoresRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCampaignScoresRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCampaignScoresRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndBlock != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.EndBlock))
		i--
		dAtA[i] = 0x18
	}
	if m.BeginBlock != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BeginBlock))
		i--
		dAtA[i] = 0x10
	}
	if m.Date != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetCampaignScoresResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCampaignScoresResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCampaignScoresResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x18
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Scores) > 0 {
		for iNdEx := len(m.Scores) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scores[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CampaignScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CampaignScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CampaignScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UsrAddr) > 0 {
		i -= len(m.UsrAddr)
		copy(dAtA[i:], m.UsrAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.UsrAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLiquidityStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidityStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidityStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockDelay != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BlockDelay))
		i--
		dAtA[i] = 0x40
	}
	if len(m.BlockTxLink) > 0 {
		i -= len(m.BlockTxLink)
		copy(dAtA[i:], m.BlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BlockTxLink)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Powers) > 0 {
		for iNdEx := len(m.Powers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Powers[iNdEx])
			copy(dAtA[i:], m.Powers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Powers[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SortedSigs[iNdEx])
			copy(dAtA[i:], m.SortedSigs[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.SortedSigs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.WdOnchain) > 0 {
		i -= len(m.WdOnchain)
		copy(dAtA[i:], m.WdOnchain)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WdOnchain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Chain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Chain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractAddr) > 0 {
		i -= len(m.ContractAddr)
		copy(dAtA[i:], m.ContractAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ContractAddr)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.RpcUrl) > 0 {
		i -= len(m.RpcUrl)
		copy(dAtA[i:], m.RpcUrl)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.RpcUrl)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExploreUrl) > 0 {
		i -= len(m.ExploreUrl)
		copy(dAtA[i:], m.ExploreUrl)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ExploreUrl)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.GasTokenSymbol) > 0 {
		i -= len(m.GasTokenSymbol)
		copy(dAtA[i:], m.GasTokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.GasTokenSymbol)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BlockDelay != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BlockDelay))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChainTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		for iNdEx := len(m.Token) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Token[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Icon) > 0 {
		i -= len(m.Icon)
		copy(dAtA[i:], m.Icon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Icon)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DstBlockTxLink) > 0 {
		i -= len(m.DstBlockTxLink)
		copy(dAtA[i:], m.DstBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DstBlockTxLink)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SrcBlockTxLink) > 0 {
		i -= len(m.SrcBlockTxLink)
		copy(dAtA[i:], m.SrcBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SrcBlockTxLink)))
		i--
		dAtA[i] = 0x4a
	}
	if m.BlockDelay != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.BlockDelay))
		i--
		dAtA[i] = 0x40
	}
	if m.RefundReason != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RefundReason))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Powers) > 0 {
		for iNdEx := len(m.Powers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Powers[iNdEx])
			copy(dAtA[i:], m.Powers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Powers[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.SortedSigs) > 0 {
		for iNdEx := len(m.SortedSigs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SortedSigs[iNdEx])
			copy(dAtA[i:], m.SortedSigs[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.SortedSigs[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.WdOnchain) > 0 {
		i -= len(m.WdOnchain)
		copy(dAtA[i:], m.WdOnchain)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WdOnchain)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTransferConfigsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferConfigsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferConfigsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTransferConfigsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTransferConfigsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTransferConfigsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FarmingRewardContractAddr) > 0 {
		i -= len(m.FarmingRewardContractAddr)
		copy(dAtA[i:], m.FarmingRewardContractAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.FarmingRewardContractAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ChainToken) > 0 {
		for k := range m.ChainToken {
			v := m.ChainToken[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGateway(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Chains) > 0 {
		for iNdEx := len(m.Chains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTokenInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTokenInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TokenInfo != nil {
		{
			size, err := m.TokenInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstimateAmtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateAmtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateAmtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x30
	}
	if len(m.UsrAddr) > 0 {
		i -= len(m.UsrAddr)
		copy(dAtA[i:], m.UsrAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.UsrAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Amt) > 0 {
		i -= len(m.Amt)
		copy(dAtA[i:], m.Amt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amt)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DstChainId))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SrcChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EstimateAmtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateAmtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateAmtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BaseFee) > 0 {
		i -= len(m.BaseFee)
		copy(dAtA[i:], m.BaseFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BaseFee)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxSlippage != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MaxSlippage))
		i--
		dAtA[i] = 0x30
	}
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PercFee) > 0 {
		i -= len(m.PercFee)
		copy(dAtA[i:], m.PercFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.PercFee)))
		i--
		dAtA[i] = 0x22
	}
	if m.BridgeRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BridgeRate))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.EqValueTokenAmt) > 0 {
		i -= len(m.EqValueTokenAmt)
		copy(dAtA[i:], m.EqValueTokenAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EqValueTokenAmt)))
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EstimateWithdrawAmtRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateWithdrawAmtRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateWithdrawAmtRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsrAddr) > 0 {
		i -= len(m.UsrAddr)
		copy(dAtA[i:], m.UsrAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.UsrAddr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DstChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DstChainId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SrcWithdraws) > 0 {
		for iNdEx := len(m.SrcWithdraws) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SrcWithdraws[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EstimateWithdrawAmtResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateWithdrawAmtResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateWithdrawAmtResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReqAmt) > 0 {
		for k := range m.ReqAmt {
			v := m.ReqAmt[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintGateway(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EstimateWithdrawAmt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EstimateWithdrawAmt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EstimateWithdrawAmt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxSlippage != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MaxSlippage))
		i--
		dAtA[i] = 0x30
	}
	if m.SlippageTolerance != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SlippageTolerance))
		i--
		dAtA[i] = 0x28
	}
	if len(m.BaseFee) > 0 {
		i -= len(m.BaseFee)
		copy(dAtA[i:], m.BaseFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BaseFee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PercFee) > 0 {
		i -= len(m.PercFee)
		copy(dAtA[i:], m.PercFee)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.PercFee)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BridgeRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.BridgeRate))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.EqValueTokenAmt) > 0 {
		i -= len(m.EqValueTokenAmt)
		copy(dAtA[i:], m.EqValueTokenAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EqValueTokenAmt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkTransferRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkTransferRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkTransferRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SrcTxHash) > 0 {
		i -= len(m.SrcTxHash)
		copy(dAtA[i:], m.SrcTxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SrcTxHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x22
	}
	if m.DstMinReceivedInfo != nil {
		{
			size, err := m.DstMinReceivedInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcSendInfo != nil {
		{
			size, err := m.SrcSendInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLPInfoListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLPInfoListRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLPInfoListRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FarmingApy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FarmingApy))))
		i--
		dAtA[i] = 0x61
	}
	if m.LpFeeEarningApy != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LpFeeEarningApy))))
		i--
		dAtA[i] = 0x59
	}
	if len(m.TotalLiquidityAmt) > 0 {
		i -= len(m.TotalLiquidityAmt)
		copy(dAtA[i:], m.TotalLiquidityAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TotalLiquidityAmt)))
		i--
		dAtA[i] = 0x52
	}
	if m.TotalLiquidity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalLiquidity))))
		i--
		dAtA[i] = 0x49
	}
	if m.Volume_24H != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume_24H))))
		i--
		dAtA[i] = 0x41
	}
	if m.FarmingRewardEarning != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FarmingRewardEarning))))
		i--
		dAtA[i] = 0x39
	}
	if m.LpFeeEarning != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LpFeeEarning))))
		i--
		dAtA[i] = 0x31
	}
	if m.HasFarmingSessions {
		i--
		if m.HasFarmingSessions {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.LiquidityAmt) > 0 {
		i -= len(m.LiquidityAmt)
		copy(dAtA[i:], m.LiquidityAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LiquidityAmt)))
		i--
		dAtA[i] = 0x22
	}
	if m.Liquidity != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Liquidity))))
		i--
		dAtA[i] = 0x19
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLPInfoListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLPInfoListResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLPInfoListResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LpInfo) > 0 {
		for iNdEx := len(m.LpInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LpInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawLiquidityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawLiquidityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawLiquidityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MethodType != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MethodType))
		i--
		dAtA[i] = 0x20
	}
	if len(m.EstimatedReceivedAmt) > 0 {
		i -= len(m.EstimatedReceivedAmt)
		copy(dAtA[i:], m.EstimatedReceivedAmt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.EstimatedReceivedAmt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WithdrawReq) > 0 {
		i -= len(m.WithdrawReq)
		copy(dAtA[i:], m.WithdrawReq)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.WithdrawReq)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WithdrawLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WithdrawLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WithdrawLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x10
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkLiquidityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkLiquidityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkLiquidityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x32
	}
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x28
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.TokenAddr) > 0 {
		i -= len(m.TokenAddr)
		copy(dAtA[i:], m.TokenAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amt) > 0 {
		i -= len(m.Amt)
		copy(dAtA[i:], m.Amt)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amt)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.LpAddr) > 0 {
		i -= len(m.LpAddr)
		copy(dAtA[i:], m.LpAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LpAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarkLiquidityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarkLiquidityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarkLiquidityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockFarmingRewardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockFarmingRewardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockFarmingRewardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockFarmingRewardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockFarmingRewardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockFarmingRewardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFarmingRewardDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFarmingRewardDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFarmingRewardDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFarmingRewardDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFarmingRewardDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFarmingRewardDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		for iNdEx := len(m.Details) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Details[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryLiquidityStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryLiquidityStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryLiquidityStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LpAddr) > 0 {
		i -= len(m.LpAddr)
		copy(dAtA[i:], m.LpAddr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.LpAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefundReason != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RefundReason))
		i--
		dAtA[i] = 0x40
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.DstBlockTxLink) > 0 {
		i -= len(m.DstBlockTxLink)
		copy(dAtA[i:], m.DstBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DstBlockTxLink)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SrcBlockTxLink) > 0 {
		i -= len(m.SrcBlockTxLink)
		copy(dAtA[i:], m.SrcBlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SrcBlockTxLink)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ts != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Ts))
		i--
		dAtA[i] = 0x20
	}
	if m.DstReceivedInfo != nil {
		{
			size, err := m.DstReceivedInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SrcSendInfo != nil {
		{
			size, err := m.SrcSendInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TransferId) > 0 {
		i -= len(m.TransferId)
		copy(dAtA[i:], m.TransferId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TransferId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MethodType != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MethodType))
		i--
		dAtA[i] = 0x48
	}
	if m.SeqNum != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.SeqNum))
		i--
		dAtA[i] = 0x40
	}
	if m.Type != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.BlockTxLink) > 0 {
		i -= len(m.BlockTxLink)
		copy(dAtA[i:], m.BlockTxLink)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BlockTxLink)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Ts != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Ts))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.CurrentSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.History) > 0 {
		for iNdEx := len(m.History) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.History[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PageSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PageSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.CurrentSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NextPageToken) > 0 {
		i -= len(m.NextPageToken)
		copy(dAtA[i:], m.NextPageToken)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.NextPageToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.History) > 0 {
		for iNdEx := len(m.History) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.History[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardingDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardingDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardingDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Amt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amt))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *RewardingDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardingDataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardingDataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnlockedCumulativeRewards) > 0 {
		for iNdEx := len(m.UnlockedCumulativeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnlockedCumulativeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.HistoricalCumulativeRewards) > 0 {
		for iNdEx := len(m.HistoricalCumulativeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoricalCumulativeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.UsdPrice) > 0 {
		for k := range m.UsdPrice {
			v := m.UsdPrice[k]
			baseI := i
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(v))))
			i--
			dAtA[i] = 0x11
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGateway(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateChainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateChainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateChainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TxUrlPrefix) > 0 {
		i -= len(m.TxUrlPrefix)
		copy(dAtA[i:], m.TxUrlPrefix)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxUrlPrefix)))
		i--
		dAtA[i] = 0x12
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateChainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateChainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateChainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxUrlPrefix) > 0 {
		i -= len(m.TxUrlPrefix)
		copy(dAtA[i:], m.TxUrlPrefix)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TxUrlPrefix)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Chain != nil {
		{
			size, err := m.Chain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenIcon) > 0 {
		i -= len(m.TokenIcon)
		copy(dAtA[i:], m.TokenIcon)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenIcon)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenName) > 0 {
		i -= len(m.TokenName)
		copy(dAtA[i:], m.TokenName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateTokenResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Token != nil {
		{
			size, err := m.Token.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakingConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakingConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakingConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *StakingConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakingConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakingConfigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CelrContract) > 0 {
		i -= len(m.CelrContract)
		copy(dAtA[i:], m.CelrContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.CelrContract)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StakingRewardContract) > 0 {
		i -= len(m.StakingRewardContract)
		copy(dAtA[i:], m.StakingRewardContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.StakingRewardContract)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StakingContract) > 0 {
		i -= len(m.StakingContract)
		copy(dAtA[i:], m.StakingContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.StakingContract)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ViewerContract) > 0 {
		i -= len(m.ViewerContract)
		copy(dAtA[i:], m.ViewerContract)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ViewerContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockStakingRewardRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockStakingRewardRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockStakingRewardRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnlockStakingRewardResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockStakingRewardResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnlockStakingRewardResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStakingRewardDetailsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStakingRewardDetailsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStakingRewardDetailsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStakingRewardDetailsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStakingRewardDetailsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStakingRewardDetailsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		{
			size, err := m.Detail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenSymbol) > 0 {
		i -= len(m.TokenSymbol)
		copy(dAtA[i:], m.TokenSymbol)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.TokenSymbol)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainIds) > 0 {
		dAtA41 := make([]byte, len(m.ChainIds)*10)
		var j40 int
		for _, num := range m.ChainIds {
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintGateway(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalLiq) > 0 {
		for k := range m.TotalLiq {
			v := m.TotalLiq[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGateway(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintGateway(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintGateway(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ErrMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ErrMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGateway(dAtA []byte, offset int, v uint64) int {
	offset -= sovGateway(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetCampaignScoresRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Date != 0 {
		n += 1 + sovGateway(uint64(m.Date))
	}
	if m.BeginBlock != 0 {
		n += 1 + sovGateway(uint64(m.BeginBlock))
	}
	if m.EndBlock != 0 {
		n += 1 + sovGateway(uint64(m.EndBlock))
	}
	return n
}

func (m *GetCampaignScoresResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scores) > 0 {
		for _, e := range m.Scores {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Begin != 0 {
		n += 1 + sovGateway(uint64(m.Begin))
	}
	return n
}

func (m *CampaignScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsrAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovGateway(uint64(m.Score))
	}
	return n
}

func (m *QueryLiquidityStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	l = len(m.WdOnchain)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, b := range m.SortedSigs {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, b := range m.Signers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Powers) > 0 {
		for _, b := range m.Powers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.BlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BlockDelay != 0 {
		n += 1 + sovGateway(uint64(m.BlockDelay))
	}
	return n
}

func (m *Chain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGateway(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BlockDelay != 0 {
		n += 1 + sovGateway(uint64(m.BlockDelay))
	}
	l = len(m.GasTokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ExploreUrl)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.RpcUrl)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ContractAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ChainTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Token) > 0 {
		for _, e := range m.Token {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *TokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TransferInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTransferStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTransferStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	l = len(m.WdOnchain)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.SortedSigs) > 0 {
		for _, b := range m.SortedSigs {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Signers) > 0 {
		for _, b := range m.Signers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.Powers) > 0 {
		for _, b := range m.Powers {
			l = len(b)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.RefundReason != 0 {
		n += 1 + sovGateway(uint64(m.RefundReason))
	}
	if m.BlockDelay != 0 {
		n += 1 + sovGateway(uint64(m.BlockDelay))
	}
	l = len(m.SrcBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DstBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTransferConfigsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTransferConfigsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.Chains) > 0 {
		for _, e := range m.Chains {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.ChainToken) > 0 {
		for k, v := range m.ChainToken {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGateway(uint64(l))
			}
			mapEntrySize := 1 + sovGateway(uint64(k)) + l
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	l = len(m.FarmingRewardContractAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTokenInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTokenInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.TokenInfo != nil {
		l = m.TokenInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EstimateAmtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcChainId != 0 {
		n += 1 + sovGateway(uint64(m.SrcChainId))
	}
	if m.DstChainId != 0 {
		n += 1 + sovGateway(uint64(m.DstChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.UsrAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	return n
}

func (m *EstimateAmtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.EqValueTokenAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BridgeRate != 0 {
		n += 5
	}
	l = len(m.PercFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	if m.MaxSlippage != 0 {
		n += 1 + sovGateway(uint64(m.MaxSlippage))
	}
	l = len(m.BaseFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *WithdrawInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	return n
}

func (m *EstimateWithdrawAmtRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SrcWithdraws) > 0 {
		for _, e := range m.SrcWithdraws {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.DstChainId != 0 {
		n += 1 + sovGateway(uint64(m.DstChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.UsrAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EstimateWithdrawAmtResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.ReqAmt) > 0 {
		for k, v := range m.ReqAmt {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovGateway(uint64(l))
			}
			mapEntrySize := 1 + sovGateway(uint64(k)) + l
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EstimateWithdrawAmt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EqValueTokenAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.BridgeRate != 0 {
		n += 5
	}
	l = len(m.PercFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.BaseFee)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 1 + sovGateway(uint64(m.SlippageTolerance))
	}
	if m.MaxSlippage != 0 {
		n += 1 + sovGateway(uint64(m.MaxSlippage))
	}
	return n
}

func (m *MarkTransferRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SrcSendInfo != nil {
		l = m.SrcSendInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DstMinReceivedInfo != nil {
		l = m.DstMinReceivedInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.SrcTxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	return n
}

func (m *MarkTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetLPInfoListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *LPInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Liquidity != 0 {
		n += 9
	}
	l = len(m.LiquidityAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.HasFarmingSessions {
		n += 2
	}
	if m.LpFeeEarning != 0 {
		n += 9
	}
	if m.FarmingRewardEarning != 0 {
		n += 9
	}
	if m.Volume_24H != 0 {
		n += 9
	}
	if m.TotalLiquidity != 0 {
		n += 9
	}
	l = len(m.TotalLiquidityAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.LpFeeEarningApy != 0 {
		n += 9
	}
	if m.FarmingApy != 0 {
		n += 9
	}
	return n
}

func (m *GetLPInfoListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.LpInfo) > 0 {
		for _, e := range m.LpInfo {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *WithdrawLiquidityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WithdrawReq)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.EstimatedReceivedAmt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.MethodType != 0 {
		n += 1 + sovGateway(uint64(m.MethodType))
	}
	return n
}

func (m *WithdrawLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	return n
}

func (m *MarkLiquidityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.LpAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amt)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TokenAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	return n
}

func (m *MarkLiquidityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UnlockFarmingRewardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UnlockFarmingRewardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetFarmingRewardDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetFarmingRewardDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *QueryLiquidityStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.LpAddr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	return n
}

func (m *TransferHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransferId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.SrcSendInfo != nil {
		l = m.SrcSendInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DstReceivedInfo != nil {
		l = m.DstReceivedInfo.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovGateway(uint64(m.Ts))
	}
	l = len(m.SrcBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DstBlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	if m.RefundReason != 0 {
		n += 1 + sovGateway(uint64(m.RefundReason))
	}
	return n
}

func (m *LPHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Ts != 0 {
		n += 1 + sovGateway(uint64(m.Ts))
	}
	l = len(m.BlockTxLink)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovGateway(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovGateway(uint64(m.Type))
	}
	if m.SeqNum != 0 {
		n += 1 + sovGateway(uint64(m.SeqNum))
	}
	if m.MethodType != 0 {
		n += 1 + sovGateway(uint64(m.MethodType))
	}
	return n
}

func (m *TransferHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGateway(uint64(m.PageSize))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TransferHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CurrentSize != 0 {
		n += 1 + sovGateway(uint64(m.CurrentSize))
	}
	return n
}

func (m *LPHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovGateway(uint64(m.PageSize))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *LPHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.History) > 0 {
		for _, e := range m.History {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.CurrentSize != 0 {
		n += 1 + sovGateway(uint64(m.CurrentSize))
	}
	return n
}

func (m *RewardingDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *Reward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amt != 0 {
		n += 9
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *RewardingDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.UsdPrice) > 0 {
		for k, v := range m.UsdPrice {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGateway(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	if len(m.HistoricalCumulativeRewards) > 0 {
		for _, e := range m.HistoricalCumulativeRewards {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.UnlockedCumulativeRewards) > 0 {
		for _, e := range m.UnlockedCumulativeRewards {
			l = e.Size()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *UpdateChainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TxUrlPrefix)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UpdateChainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Chain != nil {
		l = m.Chain.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TxUrlPrefix)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UpdateTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovGateway(uint64(m.ChainId))
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TokenName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.TokenIcon)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UpdateTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *StakingConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *StakingConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ViewerContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.StakingContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.StakingRewardContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.CelrContract)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UnlockStakingRewardRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *UnlockStakingRewardResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetStakingRewardDetailsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetStakingRewardDetailsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTotalLiquidityProviderTokenBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChainIds) > 0 {
		l = 0
		for _, e := range m.ChainIds {
			l += sovGateway(uint64(e))
		}
		n += 1 + sovGateway(uint64(l)) + l
	}
	l = len(m.TokenSymbol)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *GetTotalLiquidityProviderTokenBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.TotalLiq) > 0 {
		for k, v := range m.TotalLiq {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGateway(uint64(k)) + 1 + len(v) + sovGateway(uint64(len(v)))
			n += mapEntrySize + 1 + sovGateway(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ErrMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovGateway(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func sovGateway(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetCampaignScoresRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCampaignScoresRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCampaignScoresRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginBlock", wireType)
			}
			m.BeginBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndBlock", wireType)
			}
			m.EndBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCampaignScoresResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCampaignScoresResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCampaignScoresResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scores = append(m.Scores, &CampaignScore{})
			if err := m.Scores[len(m.Scores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CampaignScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CampaignScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CampaignScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLiquidityStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidityStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidityStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.LPHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdOnchain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WdOnchain = append(m.WdOnchain[:0], dAtA[iNdEx:postIndex]...)
			if m.WdOnchain == nil {
				m.WdOnchain = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, make([]byte, postIndex-iNdEx))
			copy(m.SortedSigs[len(m.SortedSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, make([]byte, postIndex-iNdEx))
			copy(m.Signers[len(m.Signers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Powers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Powers = append(m.Powers, make([]byte, postIndex-iNdEx))
			copy(m.Powers[len(m.Powers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDelay", wireType)
			}
			m.BlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDelay", wireType)
			}
			m.BlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasTokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasTokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExploreUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExploreUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = append(m.Token, &TokenInfo{})
			if err := m.Token[len(m.Token)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.TransferHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WdOnchain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WdOnchain = append(m.WdOnchain[:0], dAtA[iNdEx:postIndex]...)
			if m.WdOnchain == nil {
				m.WdOnchain = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortedSigs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortedSigs = append(m.SortedSigs, make([]byte, postIndex-iNdEx))
			copy(m.SortedSigs[len(m.SortedSigs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, make([]byte, postIndex-iNdEx))
			copy(m.Signers[len(m.Signers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Powers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Powers = append(m.Powers, make([]byte, postIndex-iNdEx))
			copy(m.Powers[len(m.Powers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundReason", wireType)
			}
			m.RefundReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundReason |= types.XferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockDelay", wireType)
			}
			m.BlockDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockDelay |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferConfigsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferConfigsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferConfigsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTransferConfigsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTransferConfigsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTransferConfigsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chains = append(m.Chains, &Chain{})
			if err := m.Chains[len(m.Chains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainToken == nil {
				m.ChainToken = make(map[uint32]*ChainTokenInfo)
			}
			var mapkey uint32
			var mapvalue *ChainTokenInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGateway
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGateway
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ChainTokenInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChainToken[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingRewardContractAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FarmingRewardContractAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenInfo == nil {
				m.TokenInfo = &TokenInfo{}
			}
			if err := m.TokenInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateAmtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateAmtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateAmtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcChainId", wireType)
			}
			m.SrcChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstChainId", wireType)
			}
			m.DstChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateAmtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateAmtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateAmtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqValueTokenAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqValueTokenAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BridgeRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSlippage", wireType)
			}
			m.MaxSlippage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSlippage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateWithdrawAmtRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateWithdrawAmtRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateWithdrawAmtRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcWithdraws", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcWithdraws = append(m.SrcWithdraws, &WithdrawInfo{})
			if err := m.SrcWithdraws[len(m.SrcWithdraws)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstChainId", wireType)
			}
			m.DstChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsrAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsrAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateWithdrawAmtResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateWithdrawAmtResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateWithdrawAmtResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqAmt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReqAmt == nil {
				m.ReqAmt = make(map[uint32]*EstimateWithdrawAmt)
			}
			var mapkey uint32
			var mapvalue *EstimateWithdrawAmt
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthGateway
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthGateway
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EstimateWithdrawAmt{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReqAmt[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EstimateWithdrawAmt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EstimateWithdrawAmt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EstimateWithdrawAmt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EqValueTokenAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EqValueTokenAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BridgeRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.BridgeRate = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PercFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PercFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			m.SlippageTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlippageTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSlippage", wireType)
			}
			m.MaxSlippage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSlippage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkTransferRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkTransferRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkTransferRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSendInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcSendInfo == nil {
				m.SrcSendInfo = &TransferInfo{}
			}
			if err := m.SrcSendInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstMinReceivedInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstMinReceivedInfo == nil {
				m.DstMinReceivedInfo = &TransferInfo{}
			}
			if err := m.DstMinReceivedInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TransferType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLPInfoListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLPInfoListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLPInfoListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Liquidity = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiquidityAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFarmingSessions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFarmingSessions = bool(v != 0)
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpFeeEarning", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LpFeeEarning = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingRewardEarning", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FarmingRewardEarning = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume_24H", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume_24H = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiquidity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalLiquidity = float64(math.Float64frombits(v))
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiquidityAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalLiquidityAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpFeeEarningApy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LpFeeEarningApy = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FarmingApy", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FarmingApy = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLPInfoListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLPInfoListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLPInfoListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpInfo = append(m.LpInfo, &LPInfo{})
			if err := m.LpInfo[len(m.LpInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawLiquidityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawLiquidityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawLiquidityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawReq", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WithdrawReq = append(m.WithdrawReq[:0], dAtA[iNdEx:postIndex]...)
			if m.WithdrawReq == nil {
				m.WithdrawReq = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimatedReceivedAmt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EstimatedReceivedAmt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodType", wireType)
			}
			m.MethodType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MethodType |= WithdrawMethodType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WithdrawLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WithdrawLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WithdrawLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkLiquidityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkLiquidityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkLiquidityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarkLiquidityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarkLiquidityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarkLiquidityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockFarmingRewardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockFarmingRewardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockFarmingRewardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockFarmingRewardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockFarmingRewardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockFarmingRewardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFarmingRewardDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFarmingRewardDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFarmingRewardDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &types1.RewardClaimDetails{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryLiquidityStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryLiquidityStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryLiquidityStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransferId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSendInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SrcSendInfo == nil {
				m.SrcSendInfo = &TransferInfo{}
			}
			if err := m.SrcSendInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstReceivedInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DstReceivedInfo == nil {
				m.DstReceivedInfo = &TransferInfo{}
			}
			if err := m.DstReceivedInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstBlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstBlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.TransferHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundReason", wireType)
			}
			m.RefundReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundReason |= types.XferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			m.Ts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ts |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTxLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockTxLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= types.LPHistoryStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= LPType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodType", wireType)
			}
			m.MethodType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MethodType |= WithdrawMethodType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &TransferHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSize", wireType)
			}
			m.CurrentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.History = append(m.History, &LPHistory{})
			if err := m.History[len(m.History)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSize", wireType)
			}
			m.CurrentSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardingDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardingDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardingDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amt = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &types.Token{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardingDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardingDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardingDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsdPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsdPrice == nil {
				m.UsdPrice = make(map[string]float64)
			}
			var mapkey string
			var mapvalue float64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGateway
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGateway
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					mapvaluetemp = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					mapvalue = math.Float64frombits(mapvaluetemp)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UsdPrice[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalCumulativeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoricalCumulativeRewards = append(m.HistoricalCumulativeRewards, &Reward{})
			if err := m.HistoricalCumulativeRewards[len(m.HistoricalCumulativeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockedCumulativeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnlockedCumulativeRewards = append(m.UnlockedCumulativeRewards, &Reward{})
			if err := m.UnlockedCumulativeRewards[len(m.UnlockedCumulativeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateChainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateChainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateChainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxUrlPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxUrlPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateChainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateChainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateChainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chain == nil {
				m.Chain = &Chain{}
			}
			if err := m.Chain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxUrlPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxUrlPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &TokenInfo{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakingConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakingConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakingConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakingConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakingConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakingConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewerContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ViewerContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingRewardContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingRewardContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CelrContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CelrContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockStakingRewardRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockStakingRewardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockStakingRewardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockStakingRewardResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockStakingRewardResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockStakingRewardResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStakingRewardDetailsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStakingRewardDetailsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStakingRewardDetailsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStakingRewardDetailsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStakingRewardDetailsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStakingRewardDetailsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &types2.StakingRewardClaimInfo{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTotalLiquidityProviderTokenBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChainIds = append(m.ChainIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGateway
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGateway
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChainIds) == 0 {
					m.ChainIds = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChainIds = append(m.ChainIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTotalLiquidityProviderTokenBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTotalLiquidityProviderTokenBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalLiq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalLiq == nil {
				m.TotalLiq = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGateway
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGateway
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGateway(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGateway
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TotalLiq[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGateway
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGateway
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGateway        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGateway = fmt.Errorf("proto: unexpected end of group")
)
